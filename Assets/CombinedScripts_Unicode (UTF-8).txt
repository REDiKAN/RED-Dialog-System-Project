// ===== Combined Scripts Header =====
// Generation Time: 05.12.2025 18:39:45
// Total Files: 1
// =================================

//==== File 1 of 1: D:/Work/REDDialogSystemProject/Assets\Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using System;
using System.Collections;
using DialogueSystem;

/// <summary>
/// Управляет выполнением диалогов в реальном времени
/// </summary>
public class DialogueManager : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private ChatPanel chatPanel;
    [SerializeField] private OptionPanel optionPanel;

    [Header("Dialogue Settings")]
    [SerializeField] private float messageDelay = 0.5f; // Задержка между сообщениями

    [SerializeField] private DialogueContainer currentDialogue;
    private object currentNode; // Исправлено: BaseNodeData -> object (ошибки 1,9)
    private Dictionary<string, int> intVariables = new Dictionary<string, int>();
    private Dictionary<string, string> stringVariables = new Dictionary<string, string>();
    private List<object> visitedNodes = new List<object>(); // Исправлено: BaseNodeData -> object

    private readonly System.Random random = new System.Random();

    [SerializeField] private TimerDisplayController _timerDisplayController;

    [SerializeField] private Button _continueButton; // Новая кнопка для продолжения диалога
    private SpeechNodeData _pendingSpeechNode; // Ожидаемый узел для отправки
    private SpeechNodeImageData _pendingSpeechImageNode; // Ожидаемый узел изображения
    private OptionNodeData _pendingOptionNode; // Для совместимости с вариантами ответов

    private void Start()
    {
        // Подписываемся на событие выбора опции
        if (optionPanel != null)
        {
            optionPanel.onOptionSelected += HandleOptionSelection;
        }
        else
        {
            Debug.LogError("OptionPanel not assigned in DialogueManager");
        }

        if (chatPanel == null)
        {
            Debug.LogError("ChatPanel not assigned in DialogueManager");
        }

        if (_continueButton != null)
        {
            _continueButton.onClick.AddListener(OnContinueButtonPressed);
            _continueButton.gameObject.SetActive(false); // Изначально скрыта
        }
        else
        {
            Debug.LogWarning("Continue button not assigned in DialogueManager. Button press feature will not work.");
        }

        StartDialogue(currentDialogue);
    }
    /// <summary>
    /// Запускает диалог по указанному контейнеру
    /// </summary>
    /// <param name="dialogueContainer">Контейнер диалога для запуска</param>
    public void StartDialogue(DialogueContainer dialogueContainer)
    {
        currentDialogue = dialogueContainer;
        ResetVariables();
        visitedNodes.Clear();

        // Инициализация переменных из Exposed Properties
        foreach (var prop in currentDialogue.IntExposedProperties)
        {
            intVariables[prop.PropertyName] = prop.IntValue;
        }

        foreach (var prop in currentDialogue.StringExposedProperties)
        {
            stringVariables[prop.PropertyName] = prop.StringValue;
        }

        // Начинаем диалог с EntryNode
        currentNode = currentDialogue.EntryNodeData;
        ProcessNextNode();
    }

    /// <summary>
    /// Сбрасывает все переменные диалога к значениям по умолчанию
    /// </summary>
    private void ResetVariables()
    {
        intVariables.Clear();
        stringVariables.Clear();
    }

    private void ProcessNextNode()
    {
        if (currentNode == null)
            return;

        if (!visitedNodes.Contains(currentNode))
            visitedNodes.Add(currentNode);

        switch (currentNode)
        {
            case EntryNodeData entryNode:
                ProcessEntryNode(entryNode);
                break;
            case SpeechNodeData speechNode:
                ProcessSpeechNode(speechNode);
                break;
            case SpeechNodeImageData speechImageNode:
                ProcessSpeechImageNode(speechImageNode);
                break;
            case IntConditionNodeData intCondition:
                ProcessIntCondition(intCondition);
                break;
            case StringConditionNodeData stringCondition:
                ProcessStringCondition(stringCondition);
                break;
            case ModifyIntNodeData modifyNode:
                ProcessModifyIntNode(modifyNode);
                break;
            case EndNodeData endNode:
                ProcessEndNode(endNode);
                break;
            case OptionNodeData optionNode:
                ProcessOptionNode(optionNode);
                break;
            case OptionNodeImageData optionImageNode:
                ProcessOptionImageNode(optionImageNode);
                break;
            case EventNodeData eventNode:
                eventNode.Event.Invoke();
                var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == eventNode.Guid);
                if (nextLink != null)
                {
                    currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
                    ProcessNextNode();
                } else currentNode = null;
                break;
            case CharacterIntConditionNodeData charIntCondition:
                ProcessCharacterIntCondition(charIntCondition);
                break;
            case CharacterModifyIntNodeData charModifyInt:
                ProcessCharacterModifyInt(charModifyInt);
                break;
            case DebugLogNodeData debugLog:
                Debug.Log(debugLog.MessageText);
                GoToNextNode(debugLog.Guid);
                break;
            case DebugWarningNodeData debugWarn:
                Debug.LogWarning(debugWarn.MessageText);
                GoToNextNode(debugWarn.Guid);
                break;
            case DebugErrorNodeData debugErr:
                Debug.LogError(debugErr.MessageText);
                GoToNextNode(debugErr.Guid);
                break;
            case SpeechRandNodeData speechRandNode:
                ProcessSpeechRandNode(speechRandNode);
                break;
            case RandomBranchNodeData randomBranchNode:
                ProcessRandomBranchNode(randomBranchNode);
                break;
            case TimerNodeData timerNode:
                ProcessTimerNode(timerNode);
                break;
            case PauseNodeData pauseNode:
                ProcessPauseNode(pauseNode);
                return;
            case WireNodeData wireNode:
                GoToNextNode(wireNode.Guid);
                break;
            default:
                Debug.LogWarning($"Неизвестный тип узла: {currentNode?.GetType().Name}");
                currentNode = null;
                break;
        }
    }

    private void ProcessPauseNode(PauseNodeData pauseNode)
    {
        if (_timerDisplayController == null)
        {
            Debug.LogError("TimerDisplayController is not assigned in DialogueManager. Pause timer will not be displayed.");
            // fallback: просто ждём без отображения
            StartCoroutine(DelayedGoToNextNode(pauseNode));
            return;
        }

        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == pauseNode.Guid);
        string nextGuid = nextLink?.TargetNodeGuid;

        void OnPauseTimeout()
        {
            if (!string.IsNullOrEmpty(nextGuid))
            {
                currentNode = GetNodeByGuid(nextGuid);
                ProcessNextNode();
            }
            else
            {
                currentNode = null;
            }
        }

        _timerDisplayController.StartTimer(pauseNode.DurationSeconds, OnPauseTimeout);
    }

    private IEnumerator DelayedGoToNextNode(PauseNodeData pauseNode)
    {
        yield return new WaitForSeconds(pauseNode.DurationSeconds);
        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == pauseNode.Guid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    private void ProcessTimerNode(TimerNodeData timerNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == timerNode.Guid)
            .ToList();

        var optionLinks = outgoingLinks
            .Where(link => link.PortName == "Options")
            .Select(link => GetNodeByGuid(link.TargetNodeGuid))
            .Where(node => node is OptionNodeData or OptionNodeImageData)
            .ToList();

        string timeoutTargetGuid = null;
        var timeoutLink = outgoingLinks.FirstOrDefault(l => l.PortName == "Timeout");
        if (timeoutLink != null)
            timeoutTargetGuid = timeoutLink.TargetNodeGuid;

        if (optionLinks.Count > 0 && optionPanel != null)
        {
            var options = new List<Option>();
            foreach (var optNode in optionLinks)
            {
                string text = "Изображение";
                if (optNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";

                // ← Ищем связь ИЗ опции к следующему узлу — для ВСЕХ типов опций
                var nextLink = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optNode).Guid);

                if (nextLink != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLink.TargetNodeGuid
                    });
                }
            }

            if (options.Count > 0)
            {
                optionPanel.ShowOptions(options);
            }
        }

        void OnTimeout()
        {
            if (optionPanel != null && optionPanel.gameObject.activeSelf)
                optionPanel.Hide();

            if (!string.IsNullOrEmpty(timeoutTargetGuid))
            {
                currentNode = GetNodeByGuid(timeoutTargetGuid);
                ProcessNextNode();
            }
            else
            {
                currentNode = null;
            }
        }

        _timerDisplayController?.StartTimer(timerNode.DurationSeconds, OnTimeout);
    }

    private void ProcessRandomBranchNode(RandomBranchNodeData randomBranchNode)
    {
        if (randomBranchNode.Variants.Count == 0)
        {
            Debug.LogError($"RandomBranchNode {randomBranchNode.Guid} has no variants");
            currentNode = null;
            return;
        }

        // Взвешенный случайный выбор
        float totalWeight = 0f;
        foreach (var variant in randomBranchNode.Variants)
            totalWeight += variant.WeightPercent;

        string selectedPort = "";
        if (totalWeight <= 0f)
        {
            // fallback: первый вариант
            selectedPort = randomBranchNode.Variants[0].PortName;
        }
        else
        {
            float pick = (float)random.NextDouble() * totalWeight;
            float current = 0f;
            foreach (var variant in randomBranchNode.Variants)
            {
                current += variant.WeightPercent;
                if (pick <= current)
                {
                    selectedPort = variant.PortName;
                    break;
                }
            }
        }

        // Находим связь по выбранному порту
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == randomBranchNode.Guid && l.PortName == selectedPort)
            .ToList();

        if (outgoingLinks.Count > 0)
        {
            if (outgoingLinks.Count > 1)
            {
                Debug.LogWarning($"RandomBranchNode {randomBranchNode.Guid} has multiple connections for port {selectedPort}. Using first.");
            }

            currentNode = GetNodeByGuid(outgoingLinks.First().TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            Debug.LogWarning($"RandomBranchNode {randomBranchNode.Guid} has no connection for selected port {selectedPort}");
            currentNode = null;
        }
    }

    private void ProcessSpeechRandNode(SpeechRandNodeData speechRandNode)
    {
        CharacterData speaker = null;
        if (!string.IsNullOrEmpty(speechRandNode.SpeakerName))
            speaker = CharacterManager.Instance?.GetCharacter(speechRandNode.SpeakerName);

        string selectedText = "";

        if (speechRandNode.Variants.Count > 0)
        {
            // Взвешенный случайный выбор
            float totalWeight = 0f;
            foreach (var v in speechRandNode.Variants)
                totalWeight += v.WeightPercent;

            if (totalWeight <= 0f)
            {
                // fallback: первый
                selectedText = speechRandNode.Variants[0].Text;
            }
            else
            {
                float pick = (float)random.NextDouble() * totalWeight;
                float current = 0f;
                foreach (var v in speechRandNode.Variants)
                {
                    current += v.WeightPercent;
                    if (pick <= current)
                    {
                        selectedText = v.Text;
                        break;
                    }
                }
            }
        }
        // Если список пуст — selectedText остаётся ""

        var message = new Message
        {
            Type = SenderType.NPC,
            Text = selectedText,
            Image = null,
            Audio = null,
            Sender = speaker
        };
        chatPanel.AddMessage(message, MessageTypeDialogue.Speech);

        // Обработка исходящих связей — как в SpeechNode
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechRandNode.Guid)
            .ToList();

        var optionLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is OptionNodeData || target is OptionNodeImageData;
        }).ToList();

        if (optionLinks.Any())
        {
            var options = new List<Option>();
            foreach (var linkToOption in optionLinks)
            {
                var optionNode = GetNodeByGuid(linkToOption.TargetNodeGuid);
                if (optionNode == null) continue;
                string text = "Изображение";
                if (optionNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";
                var nextLinkAfterOption = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optionNode).Guid);
                if (nextLinkAfterOption != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLinkAfterOption.TargetNodeGuid
                    });
                }
            }
            if (options.Count > 0 && optionPanel != null)
            {
                optionPanel.ShowOptions(options);
            }
            else
            {
                Debug.LogError("Нет валидных вариантов для отображения!");
                currentNode = null;
            }
            return;
        }

        var speechLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is SpeechNodeData || target is SpeechNodeImageData || target is SpeechRandNodeData;
        }).ToList();

        if (speechLinks.Any())
        {
            if (speechLinks.Count > 1)
            {
                Debug.LogWarning($"SpeechRandNode {speechRandNode.Guid} имеет несколько исходящих Speech-связей. Будет использована первая.");
            }
            string nextGuid = speechLinks.First().TargetNodeGuid;
            StartCoroutine(DelayedGoToNode(nextGuid));
            return;
        }

        var nextLinearLink = outgoingLinks.FirstOrDefault();
        if (nextLinearLink != null)
        {
            currentNode = GetNodeByGuid(nextLinearLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает EntryNodeData
    /// </summary>
    /// <param name="entryNode">Данные начального узла</param>
    private void ProcessEntryNode(EntryNodeData entryNode)
    {
        // Находим следующий узел после EntryNode
        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == entryNode.Guid);

        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            // Если нет следующего узла, завершаем диалог
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает SpeechNodeData
    /// </summary>
    /// <param name="speechNode">Данные узла речи</param>
    private void ProcessSpeechNode(SpeechNodeData speechNode)
    {
        CharacterData speaker = GetCharacterByName(speechNode.SpeakerName);
        if (speaker == null)
        {
            Debug.LogError($"SpeechNode '{speechNode.Guid}' has no valid speaker. Assign a CharacterData in the graph editor.");
            return;
        }

        var message = new Message
        {
            Type = SenderType.NPC,
            Text = speechNode.DialogueText,
            Image = null,
            Audio = AssetLoader.LoadAudioClip(speechNode.AudioClipGuid),
            Sender = speaker
        };

        chatPanel.AddMessage(message, MessageTypeDialogue.Speech);

        // Если персонаж требует нажатия кнопки для продолжения
        if (speaker.RequireButtonPressForMessages)
        {
            _pendingSpeechNode = speechNode;
            ShowContinueButton();
            return; // Останавливаем выполнение до нажатия кнопки
        }

        // Исходная логика продолжения с задержкой
        if (message.Audio != null)
            StartCoroutine(PlayAudioAfterDelay(message.Audio, messageDelay));

        ProcessSpeechNodeContinuation(speechNode);
    }

    private void ProcessSpeechNodeContinuation(SpeechNodeData speechNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechNode.Guid)
            .ToList();

        // ... остальная логика продолжения диалога ...
    }

    /// <summary>
    /// Обрабатывает SpeechNodeImageData
    /// </summary>
    /// <param name="speechImageNode">Данные узла изображения речи</param>
    private void ProcessSpeechImageNode(SpeechNodeImageData speechImageNode)
    {
        CharacterData speaker = GetCharacterByName(speechImageNode.SpeakerName);
        if (speaker == null)
        {
            Debug.LogError($"SpeechImageNode '{speechImageNode.Guid}' has no valid speaker...");
            return;
        }

        var message = new Message
        {
            Type = SenderType.NPC,
            Text = null,
            Image = !string.IsNullOrEmpty(speechImageNode.ImageSpritePath) ? Resources.Load<Sprite>(speechImageNode.ImageSpritePath) : null,
            Audio = null,
            Sender = speaker
        };

        chatPanel.AddMessage(message, MessageTypeDialogue.SpeechImage);

        // Если персонаж требует нажатия кнопки для продолжения
        if (speaker.RequireButtonPressForMessages)
        {
            _pendingSpeechImageNode = speechImageNode;
            ShowContinueButton();
            return; // Останавливаем выполнение до нажатия кнопки
        }

        // Исходная логика продолжения с задержкой
        ProcessSpeechImageNodeContinuation(speechImageNode);
    }

    private void ProcessSpeechImageNodeContinuation(SpeechNodeImageData speechImageNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechImageNode.Guid)
            .ToList();

        // ... остальная логика продолжения диалога ...
    }

    private void ShowContinueButton()
    {
        if (_continueButton != null)
        {
            _continueButton.gameObject.SetActive(true);
            // Можно добавить анимацию или визуальные эффекты для кнопки
        }
    }

    private void HideContinueButton()
    {
        if (_continueButton != null)
        {
            _continueButton.gameObject.SetActive(false);
        }
    }

    private void OnContinueButtonPressed()
    {
        HideContinueButton();

        // Продолжаем диалог в зависимости от типа ожидаемого узла
        if (_pendingSpeechNode != null)
        {
            ProcessSpeechNodeContinuation(_pendingSpeechNode);
            _pendingSpeechNode = null;
        }
        else if (_pendingSpeechImageNode != null)
        {
            ProcessSpeechImageNodeContinuation(_pendingSpeechImageNode);
            _pendingSpeechImageNode = null;
        }
    }

    private IEnumerator DelayedGoToNode(string nextNodeGuid, float delay = -1f)
    {
        if (delay < 0f) delay = messageDelay;
        yield return new WaitForSeconds(delay);
        currentNode = GetNodeByGuid(nextNodeGuid);
        ProcessNextNode();
    }

    /// <summary>
    /// Обрабатывает OptionNodeData
    /// </summary>
    private void ProcessOptionNode(OptionNodeData optionNode)
    {
        // Создаем список вариантов ответа
        var options = new List<Option>();

        // Находим все связи от этого узла
        var optionLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == optionNode.Guid)
            .ToList();

        foreach (var link in optionLinks)
        {
            var targetNode = GetNodeByGuid(link.TargetNodeGuid);
            string optionText = "Вариант ответа";

            if (targetNode is OptionNodeData optionTarget)
            {
                optionText = !string.IsNullOrEmpty(optionTarget.ResponseText) ?
                    optionTarget.ResponseText : "Вариант ответа";
            }
            else if (targetNode is OptionNodeImageData)
            {
                optionText = "Изображение";
            }

            options.Add(new Option
            {
                Text = optionText,
                NextNodeGuid = link.TargetNodeGuid
            });
        }

        // Показываем варианты ответа
        if (options.Count > 0 && optionPanel != null)
        {
            optionPanel.ShowOptions(options);
            currentNode = optionNode;
        }
        else
        {
            Debug.LogWarning($"No options found for OptionNode {optionNode.Guid}");

            // Пытаемся найти следующий узел
            var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == optionNode.Guid);
            if (nextLink != null)
            {
                currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
                ProcessNextNode();
            }
            else
            {
                currentNode = null;
            }
        }
    }

    /// <summary>
    /// Обрабатывает OptionNodeImageData
    /// </summary>
    /// <param name="optionImageNode">Данные узла изображения вариантов ответа</param>
    private void ProcessOptionImageNode(OptionNodeImageData optionImageNode)
    {
        // Получаем варианты ответов из узла
        var options = new List<Option>();

        // Получаем связанные OptionNodeData для всех выходов
        var optionLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == optionImageNode.Guid)
            .ToList();

        foreach (var link in optionLinks)
        {
            var targetNode = GetNodeByGuid(link.TargetNodeGuid);
            if (targetNode is OptionNodeData optionTarget)
            {
                options.Add(new Option
                {
                    Text = optionTarget.ResponseText,
                    NextNodeGuid = link.TargetNodeGuid
                });
            }
            else if (targetNode is OptionNodeImageData optionImageTarget)
            {
                // Для изображений вариантов ответа
                options.Add(new Option
                {
                    Text = "Изображение", // Исправлено: OptionNodeImageData не имеет ResponseText
                    NextNodeGuid = link.TargetNodeGuid
                });
            }
        }

        // Показываем панель вариантов ответов
        optionPanel.ShowOptions(options);

        // Устанавливаем текущий узел как OptionNode для последующей обработки выбора
        currentNode = optionImageNode;
    }

    /// <summary>
    /// Обрабатывает IntConditionNodeData
    /// </summary>
    /// <param name="intCondition">Данные числового условия</param>
    private void ProcessIntCondition(IntConditionNodeData intCondition)
    {
        // Проверяем условие
        bool conditionResult = ConditionHandler.EvaluateIntCondition(
            intCondition, intVariables);

        // Определяем следующий узел в зависимости от результата
        var nextLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == intCondition.Guid)
            .ToList();

        // Находим подходящий выход
        foreach (var link in nextLinks)
        {
            if (link.PortName == "True" && conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
            else if (link.PortName == "False" && !conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
        }

        // Если подходящий выход не найден, завершаем диалог
        Debug.LogWarning($"Не найден подходящий выход для условия IntConditionNode {intCondition.Guid}");
        currentNode = null;
    }

    /// <summary>
    /// Обрабатывает StringConditionNodeData
    /// </summary>
    /// <param name="stringCondition">Данные строкового условия</param>
    private void ProcessStringCondition(StringConditionNodeData stringCondition)
    {
        // Проверяем условие
        bool conditionResult = ConditionHandler.EvaluateStringCondition(
            stringCondition, stringVariables);

        // Определяем следующий узел в зависимости от результата
        var nextLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == stringCondition.Guid)
            .ToList();

        // Находим подходящий выход
        foreach (var link in nextLinks)
        {
            if (link.PortName == "True" && conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
            else if (link.PortName == "False" && !conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
        }

        // Если подходящий выход не найден, завершаем диалог
        Debug.LogWarning($"Не найден подходящий выход для условия StringConditionNode {stringCondition.Guid}");
        currentNode = null;
    }

    /// <summary>
    /// Обрабатывает ModifyIntNodeData
    /// </summary>
    /// <param name="modifyNode">Данные модификатора числа</param>
    private void ProcessModifyIntNode(ModifyIntNodeData modifyNode)
    {
        // Проверяем наличие переменной
        if (!intVariables.ContainsKey(modifyNode.SelectedProperty))
        {
            Debug.LogError($"Переменная {modifyNode.SelectedProperty} не найдена в intVariables");
            currentNode = null;
            return;
        }

        // Применяем операцию
        switch (modifyNode.Operator)
        {
            case OperatorType.Set:
                intVariables[modifyNode.SelectedProperty] = modifyNode.Value;
                break;
            case OperatorType.Add:
                intVariables[modifyNode.SelectedProperty] += modifyNode.Value;
                break;
            case OperatorType.Subtract:
                intVariables[modifyNode.SelectedProperty] -= modifyNode.Value;
                break;
            case OperatorType.Multiply:
                intVariables[modifyNode.SelectedProperty] *= modifyNode.Value;
                break;
            case OperatorType.Divide:
                if (modifyNode.Value != 0)
                    intVariables[modifyNode.SelectedProperty] /= modifyNode.Value;
                else
                    Debug.LogWarning("Деление на ноль в ModifyIntNode");
                break;
            case OperatorType.Increment:
                intVariables[modifyNode.SelectedProperty]++;
                break;
            case OperatorType.Decrement:
                intVariables[modifyNode.SelectedProperty]--;
                break;
        }

        // Находим следующий узел
        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == modifyNode.Guid);

        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает EndNodeData
    /// </summary>
    /// <param name="endNode">Данные конечного узла</param>
    private void ProcessEndNode(EndNodeData endNode)
    {
        // Добавляем системное сообщение о завершении диалога
        var message = new Message
        {
            Type = SenderType.System,
            Text = "Диалог завершен"
        };
        chatPanel.AddMessage(message, MessageTypeDialogue.System);

        // Если указан следующий диалог, запускаем его
        if (!string.IsNullOrEmpty(endNode.NextDialogueName))
        {
            DialogueContainer nextDialogue = Resources.Load<DialogueContainer>(endNode.NextDialogueName);
            if (nextDialogue != null)
            {
                StartDialogue(nextDialogue);
            }
            else
            {
                Debug.LogError($"Диалог {endNode.NextDialogueName} не найден в ресурсах");
            }
        }
        else
        {
            // Завершаем текущий диалог
            currentNode = null;
        }
    }

    /// <summary>
    /// Обработка выбора опции игроком с задержкой перед следующим сообщением
    /// </summary>
    public void HandleOptionSelection(string nextNodeGuid)
    {
        if (optionPanel != null)
            optionPanel.Hide();

        _timerDisplayController?.StopTimer();

        currentNode = GetNodeByGuid(nextNodeGuid);
        ProcessNextNode();
    }

    /// <summary>
    /// Задержка перед обработкой следующего узла (для плавности диалога)
    /// </summary>
    private IEnumerator DelayedProcessNextNode()
    {
        yield return new WaitForSeconds(messageDelay);
        ProcessNextNode();
    }

    /// <summary>
    /// Получает узел по его GUID
    /// </summary>
    /// <param name="guid">GUID узла</param>
    /// <returns>BaseNodeData или null</returns>
    private object GetNodeByGuid(string guid)
    {
        if (string.IsNullOrEmpty(guid))
            return null;

        // Ищем в Speech
        var speechNode = currentDialogue.SpeechNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (speechNode != null) return speechNode;

        var speechImageNode = currentDialogue.SpeechNodeImageDatas.FirstOrDefault(n => n.Guid == guid);
        if (speechImageNode != null) return speechImageNode;

        var optionNode = currentDialogue.OptionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (optionNode != null) return optionNode;

        var optionImageNode = currentDialogue.OptionNodeImageDatas.FirstOrDefault(n => n.Guid == guid);
        if (optionImageNode != null) return optionImageNode;

        var intConditionNode = currentDialogue.IntConditionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (intConditionNode != null) return intConditionNode;

        var stringConditionNode = currentDialogue.StringConditionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (stringConditionNode != null) return stringConditionNode;

        var modifyIntNode = currentDialogue.ModifyIntNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (modifyIntNode != null) return modifyIntNode;

        var endNode = currentDialogue.EndNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (endNode != null) return endNode;

        var charIntConditionNode = currentDialogue.CharacterIntConditionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (charIntConditionNode != null) return charIntConditionNode;

        var charModifyIntNode = currentDialogue.CharacterModifyIntNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (charModifyIntNode != null) return charModifyIntNode;

        var debugLogNode = currentDialogue.DebugLogNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (debugLogNode != null) return debugLogNode;

        var debugWarnNode = currentDialogue.DebugWarningNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (debugWarnNode != null) return debugWarnNode;

        var debugErrNode = currentDialogue.DebugErrorNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (debugErrNode != null) return debugErrNode;

        // Добавлено: поддержка SpeechRandNodeData
        var speechRandNode = currentDialogue.SpeechRandNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (speechRandNode != null) return speechRandNode;

        var timerNode = currentDialogue.TimerNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (timerNode != null) return timerNode;

        var pauseNode = currentDialogue.PauseNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (pauseNode != null) return pauseNode;

        var wireNode = currentDialogue.WireNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (wireNode != null) return wireNode;

        // EntryNode ищем ОТДЕЛЬНО и ТОЛЬКО если guid совпадает
        if (currentDialogue.EntryNodeData?.Guid == guid)
            return currentDialogue.EntryNodeData;

        // Если ничего не найдено — возвращаем null
        return null;
    }

    private void GoToNextNode(string currentGuid)
    {
        var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == currentGuid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Воспроизводит аудио с задержкой после отображения текста
    /// </summary>
    /// <param name="audioClip">Аудио клип для воспроизведения</param>
    /// <param name="delay">Задержка в секундах</param>
    /// <returns>Корутину для воспроизведения аудио</returns>
    private IEnumerator PlayAudioAfterDelay(AudioClip audioClip, float delay)
    {
        yield return new WaitForSeconds(delay);
        AudioSource.PlayClipAtPoint(audioClip, Camera.main.transform.position);
    }

    /// <summary>
    /// Сбрасывает текущий диалог
    /// </summary>
    public void ResetDialogue()
    {
        currentDialogue = null;
        currentNode = null;
        visitedNodes.Clear();
        ResetVariables();
    }

    /// <summary>
    /// Получает персонажа по имени из Resources/Characters
    /// </summary>
    private CharacterData GetCharacterByName(string characterName)
    {
        if (string.IsNullOrEmpty(characterName))
            return null;

        // Ищем в кэше CharacterManager
        var character = CharacterManager.Instance?.GetCharacter(characterName);
        if (character != null)
            return character;

        // Fallback: загрузка напрямую из Resources
        character = Resources.Load<CharacterData>($"Characters/{characterName}");
        if (character == null)
            Debug.LogError($"Character '{characterName}' not found in Resources/Characters");
        return character;
    }

    /// <summary>
    /// Вспомогательный класс для загрузки ассетов в runtime
    /// </summary>
    public static class AssetLoader
    {
        /// <summary>
        /// Загружает аудио клип по GUID (заглушка для runtime)
        /// </summary>
        /// <param name="guid">GUID аудио</param>
        /// <returns>AudioClip или null</returns>
        public static AudioClip LoadAudioClip(string guid)
        {
            // В runtime нет AssetDatabase, поэтому используем заглушку
            // В реальной системе нужно реализовать загрузку из Resources
            return null;
        }

        /// <summary>
        /// Загружает спрайт по GUID (заглушка для runtime)
        /// </summary>
        /// <param name="guid">GUID спрайта</param>
        /// <returns>Sprite или null</returns>
        public static Sprite LoadSprite(string guid)
        {
            // В runtime нет AssetDatabase, поэтому используем заглушку
            // В реальной системе нужно реализовать загрузку из Resources
            return null;
        }
    }

    private void ProcessCharacterIntCondition(CharacterIntConditionNodeData condition)
    {
        var character = CharacterManager.Instance.GetCharacter(condition.CharacterName);
        if (character == null)
        {
            Debug.LogError($"Character '{condition.CharacterName}' not found for condition node.");
            currentNode = null;
            return;
        }

        if (!character.TryGetVariable(condition.SelectedVariable, out var variable))
        {
            Debug.LogError($"Variable '{condition.SelectedVariable}' not found on character '{condition.CharacterName}'.");
            currentNode = null;
            return;
        }

        bool result = false;
        switch (condition.Comparison)
        {
            case ComparisonType.Equal: result = variable.Value == condition.CompareValue; break;
            case ComparisonType.NotEqual: result = variable.Value != condition.CompareValue; break;
            case ComparisonType.Greater: result = variable.Value > condition.CompareValue; break;
            case ComparisonType.Less: result = variable.Value < condition.CompareValue; break;
            case ComparisonType.GreaterOrEqual: result = variable.Value >= condition.CompareValue; break;
            case ComparisonType.LessOrEqual: result = variable.Value <= condition.CompareValue; break;
            default: result = false; break;
        }

        var nextLinks = currentDialogue.NodeLinks.Where(l => l.BaseNodeGuid == condition.Guid).ToList();
        foreach (var link in nextLinks)
        {
            if ((link.PortName == "True" && result) || (link.PortName == "False" && !result))
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
        }
        Debug.LogWarning($"No matching output port for CharacterIntConditionNode {condition.Guid}");
        currentNode = null;
    }

    private void ProcessCharacterModifyInt(CharacterModifyIntNodeData modify)
    {
        var character = CharacterManager.Instance.GetCharacter(modify.CharacterName);
        if (character == null)
        {
            Debug.LogError($"Character '{modify.CharacterName}' not found for modify node.");
            currentNode = null;
            return;
        }

        if (!character.TryGetVariable(modify.SelectedVariable, out var variable))
        {
            Debug.LogError($"Variable '{modify.SelectedVariable}' not found on character '{modify.CharacterName}'.");
            currentNode = null;
            return;
        }

        switch (modify.Operator)
        {
            case OperatorType.Set: variable.Value = modify.Value; break;
            case OperatorType.Add: variable.Value += modify.Value; break;
            case OperatorType.Subtract: variable.Value -= modify.Value; break;
            case OperatorType.Multiply: variable.Value *= modify.Value; break;
            case OperatorType.Divide:
                if (modify.Value != 0) variable.Value /= modify.Value;
                else Debug.LogWarning("Division by zero in CharacterModifyIntNode");
                break;
            case OperatorType.Increment: variable.Value++; break;
            case OperatorType.Decrement: variable.Value--; break;
        }

        var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == modify.Guid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else currentNode = null;
    }
}


// ============ Statistics =============
// Total Files: 1
// Total Size: 44,15 KB
// Total Lines: 1164
// Classes: 2
// Methods: 67
// Comments: 136
// =====================================
