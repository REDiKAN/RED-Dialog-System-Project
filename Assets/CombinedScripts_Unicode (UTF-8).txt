// ===== Combined Scripts Header =====
// Generation Time: 11.12.2025 20:48:58
// Total Files: 100
// =================================

//==== File 1 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\BaseNodeData.cs ====
using UnityEngine;
using System;

[System.Serializable]
public abstract class BaseNodeData
{
    public string Guid;
    public Vector2 Position;
}


//==== File 2 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\CharacterManager.cs ====
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CharacterManager : MonoBehaviour
{
    private static CharacterManager _instance;
    public static CharacterManager Instance => _instance;

    private Dictionary<string, CharacterData> characterCache = new Dictionary<string, CharacterData>();

    private void Awake()
    {
        if (_instance != null)
            Destroy(gameObject);
        else
        {
            _instance = this;
            DontDestroyOnLoad(gameObject);
            LoadAllCharacters();
        }
    }

    /// <summary>
    /// ��������� ���� ���������� �� Resources/Characters
    /// </summary>
    private void LoadAllCharacters()
    {
        var characters = Resources.LoadAll<CharacterData>("Characters");
        foreach (var character in characters)
            characterCache[character.name] = character;
    }

    /// <summary>
    /// �������� ��������� �� �����
    /// </summary>
    /// <param name="characterName">��� ���������</param>
    /// <returns>CharacterData ��� null</returns>
    public CharacterData GetCharacter(string characterName)
    {
        if (characterCache.TryGetValue(characterName, out var character))
            return character;

        Debug.LogError($"�������� {characterName} �� ������ � Resources/Characters");
        return null;
    }

    public List<CharacterData> GetAllCharacters()
    {
        return characterCache.Values.ToList();
    }
}


//==== File 3 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\ChatPanel.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class ChatPanel : MonoBehaviour
{
    [SerializeField] private ScrollRect scrollRect;
    [SerializeField] private Transform contentContainer;

    private Dictionary<(CharacterData, MessageTypeDialogue), bool> _prefabValidationCache = new();

    public void AddMessage(Message message, MessageTypeDialogue messageType)
    {
        if (contentContainer == null)
        {
            Debug.LogError("Content container not assigned in ChatPanel");
            return;
        }
        if (scrollRect == null)
        {
            Debug.LogError("ScrollRect not assigned in ChatPanel");
            return;
        }
        // Определяем нужный префаб по типу сообщения и отправителю
        GameObject prefabToInstantiate = GetPrefabForMessage(message, messageType);
        if (prefabToInstantiate == null)
            return; // ошибка уже залогирована в GetPrefabForMessage

        // Инстанциируем и настраиваем
        GameObject messageGO = Instantiate(prefabToInstantiate, contentContainer);
        messageGO.transform.SetAsLastSibling();

        if (messageGO.TryGetComponent(out IMessageObject messageObject))
        {
            messageObject.InitializationContent(message);
            messageObject.SetCharacterAvatar(message.Sender);
            messageObject.SetCharacterName(message.Sender);
        }

        // Прокрутка вниз с принудительным обновлением UI
        ScrollToBottom();
    }

    private void ScrollToBottom()
    {
        // Принудительно обновляем холст, чтобы убедиться, что размеры контента актуальны
        Canvas.ForceUpdateCanvases();

        // Устанавливаем позицию прокрутки в самый низ
        if (scrollRect.content != null)
            scrollRect.verticalNormalizedPosition = 0f; // Unity использует 0 для "самого низа"
    }

    private GameObject GetPrefabForMessage(Message message, MessageTypeDialogue messageType)
    {
        if (message.Sender == null)
        {
            Debug.LogError($"Message sender is null for type {messageType}");
            return null;
        }

        var character = message.Sender;
        string characterName = $"{character.FirstName} {character.LastName}".Trim();

        // Определяем, какой префаб брать
        Object prefab = null;
        string typeName = "";
        switch (messageType)
        {
            case MessageTypeDialogue.Speech:
            case MessageTypeDialogue.SpeechText:
                prefab = character.SpeechTextMessagePrefab;
                typeName = "SpeechText";
                break;
            case MessageTypeDialogue.SpeechImage:
                prefab = character.SpeechImageMessagePrefab;
                typeName = "SpeechImage";
                break;
            case MessageTypeDialogue.SpeechAudio:
                prefab = character.SpeechAudioMessagePrefab;
                typeName = "SpeechAudio";
                break;
            default:
                // Опции и системные сообщения — не обрабатываем здесь
                Debug.LogError($"Unsupported message type for prefab resolution: {messageType}");
                return null;
        }

        // Проверка: назначен ли префаб?
        if (prefab == null)
        {
            Debug.LogError($"Missing {typeName} message prefab for character '{characterName}'.");
            return null;
        }

        // Кэшированная проверка на IMessageObject
        var cacheKey = (character, messageType);
        if (!_prefabValidationCache.TryGetValue(cacheKey, out bool isValid))
        {
            isValid = prefab is GameObject go && go.TryGetComponent(out IMessageObject _);
            _prefabValidationCache[cacheKey] = isValid;
        }

        if (!isValid)
        {
            Debug.LogError($"Assigned prefab for {typeName} does not implement IMessageObject.");
            return null;
        }

        return (prefab as GameObject);
    }

    public void ForceScrollToBottom()
    {
        // Принудительно обновляем холст, чтобы убедиться, что размеры контента актуальны
        Canvas.ForceUpdateCanvases();
        // Устанавливаем позицию прокрутки в самый низ
        if (scrollRect.content != null)
            scrollRect.verticalNormalizedPosition = 0f; // Unity использует 0 для "самого низа"
    }
}

//==== File 4 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\ConditionHandler.cs ====
using DialogueSystem;
using System.Collections.Generic;
using UnityEngine;
/// <summary>
/// ���������� ������� ��� ���������� �����
/// </summary>
public static class ConditionHandler
{
    /// <summary>
    /// ��������� �������� �������
    /// </summary>
    /// <param name="condition">������ ���� �������</param>
    /// <param name="variables">������� �������� ����������</param>
    /// <returns>��������� �������� �������</returns>
    public static bool EvaluateIntCondition(IntConditionNodeData condition, Dictionary<string, int> variables)
    {
        if (!variables.TryGetValue(condition.SelectedProperty, out int value))
        {
            Debug.LogError($"���������� {condition.SelectedProperty} �� ������� � �������");
            return false;
        }

        switch (condition.Comparison)
        {
            case ComparisonType.Equal:
                return value == condition.CompareValue;
            case ComparisonType.NotEqual:
                return value != condition.CompareValue;
            case ComparisonType.Greater:
                return value > condition.CompareValue;
            case ComparisonType.Less:
                return value < condition.CompareValue;
            case ComparisonType.GreaterOrEqual:
                return value >= condition.CompareValue;
            case ComparisonType.LessOrEqual:
                return value <= condition.CompareValue;
            default:
                return false;
        }
    }

    /// <summary>
    /// ��������� ��������� �������
    /// </summary>
    /// <param name="condition">������ ���� �������</param>
    /// <param name="variables">������� ��������� ����������</param>
    /// <returns>��������� �������� �������</returns>
    public static bool EvaluateStringCondition(StringConditionNodeData condition, Dictionary<string, string> variables)
    {
        if (!variables.TryGetValue(condition.SelectedProperty, out string value))
        {
            Debug.LogError($"���������� {condition.SelectedProperty} �� ������� � �������");
            return false;
        }

        switch (condition.Comparison)
        {
            case StringComparisonType.Equal:
                return value == condition.CompareValue;
            case StringComparisonType.NotEqual:
                return value != condition.CompareValue;
            case StringComparisonType.IsNullOrEmpty:
                return string.IsNullOrEmpty(value);
            default:
                return false;
        }
    }
}

//==== File 5 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\DialogueManager.cs ====
// Assets/Scripts/DialogueManager.cs

using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.UI;
using UnityEngine.Events;
using System;
using System.Collections;
using DialogueSystem;

/// <summary>
/// Управляет выполнением диалогов в реальном времени
/// </summary>
public class DialogueManager : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private ChatPanel chatPanel;
    [SerializeField] private OptionPanel optionPanel;
    [SerializeField] private Button _continueButton; // Кнопка продолжения диалога

    [Header("Dialogue Settings")]
    [SerializeField] private float messageDelay = 0.5f; // Задержка между сообщениями
    [SerializeField] private DialogueContainer currentDialogue;

    private object currentNode;
    private Dictionary<string, int> intVariables = new Dictionary<string, int>();
    private Dictionary<string, string> stringVariables = new Dictionary<string, string>();
    private List<object> visitedNodes = new List<object>();
    private readonly System.Random random = new System.Random();
    [SerializeField] private TimerDisplayController _timerDisplayController;

    private Dictionary<string, bool> _originalButtonPressStates = new Dictionary<string, bool>();

    // Для работы режима ожидания нажатия кнопки
    private SpeechNodeData _pendingSpeechNode;
    private SpeechNodeImageData _pendingSpeechImageNode;
    private SpeechRandNodeData _pendingSpeechRandNode;

    private void Awake()
    {
        // Гарантируем создание CharacterManager при запуске
        if (CharacterManager.Instance == null)
        {
            GameObject managerObject = GameObject.Find("CharacterManager");
            if (managerObject == null)
            {
                managerObject = new GameObject("CharacterManager");
                managerObject.AddComponent<CharacterManager>();
            }
            else
            {
                managerObject.AddComponent<CharacterManager>();
            }
            DontDestroyOnLoad(managerObject);
        }
    }

    private void Start()
    {
        // Подписываемся на событие выбора опции
        if (optionPanel != null)
        {
            optionPanel.onOptionSelected += HandleOptionSelection;
        }
        else
        {
            Debug.LogError("OptionPanel not assigned in DialogueManager");
        }

        if (chatPanel == null)
        {
            Debug.LogError("ChatPanel not assigned in DialogueManager");
        }

        // Настройка кнопки продолжения
        if (_continueButton != null)
        {
            _continueButton.onClick.AddListener(OnContinueButtonPressed);
            _continueButton.gameObject.SetActive(false); // Изначально скрыта
        }
        else
        {
            Debug.LogWarning("Continue button not assigned in DialogueManager. Button press feature will not work.");
        }

        StartDialogue(currentDialogue);
    }

    /// <summary>
    /// Запускает диалог по указанному контейнеру
    /// </summary>
    /// <param name="dialogueContainer">Контейнер диалога для запуска</param>
    private void StartDialogue(DialogueContainer dialogueContainer)
    {
        currentDialogue = dialogueContainer;
        ResetVariables();
        visitedNodes.Clear();

        // Сохраняем исходные состояния всех персонажей перед запуском диалога
        SaveOriginalCharacterStates();

        // Инициализация переменных из Exposed Properties
        foreach (var prop in currentDialogue.IntExposedProperties)
        {
            intVariables[prop.PropertyName] = prop.IntValue;
        }
        foreach (var prop in currentDialogue.StringExposedProperties)
        {
            stringVariables[prop.PropertyName] = prop.StringValue;
        }
        // Начинаем диалог с EntryNode
        currentNode = currentDialogue.EntryNodeData;
        ProcessNextNode();
    }

    private void SaveOriginalCharacterStates()
    {
        _originalButtonPressStates.Clear();

        // Получаем всех персонажей из CharacterManager
        if (CharacterManager.Instance != null)
        {
            var allCharacters = CharacterManager.Instance.GetAllCharacters();
            foreach (var character in allCharacters)
            {
                if (!_originalButtonPressStates.ContainsKey(character.name))
                {
                    _originalButtonPressStates[character.name] = character.RequireButtonPressForMessages;
                }
            }
        }
    }

    /// <summary>
    /// Сбрасывает все переменные диалога к значениям по умолчанию
    /// </summary>
    private void ResetVariables()
    {
        intVariables.Clear();
        stringVariables.Clear();
    }

    private void ProcessNextNode()
    {
        if (currentNode == null)
            return;

        if (!visitedNodes.Contains(currentNode))
            visitedNodes.Add(currentNode);

        switch (currentNode)
        {
            case EntryNodeData entryNode:
                ProcessEntryNode(entryNode);
                break;
            case SpeechNodeData speechNode:
                ProcessSpeechNode(speechNode);
                break;
            case SpeechNodeImageData speechImageNode:
                ProcessSpeechImageNode(speechImageNode);
                break;
            case IntConditionNodeData intCondition:
                ProcessIntCondition(intCondition);
                break;
            case StringConditionNodeData stringCondition:
                ProcessStringCondition(stringCondition);
                break;
            case ModifyIntNodeData modifyNode:
                ProcessModifyIntNode(modifyNode);
                break;
            case EndNodeData endNode:
                ProcessEndNode(endNode);
                break;
            case OptionNodeData optionNode:
                ProcessOptionNode(optionNode);
                break;
            case OptionNodeImageData optionImageNode:
                ProcessOptionImageNode(optionImageNode);
                break;
            case EventNodeData eventNode:
                eventNode.Event.Invoke();
                var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == eventNode.Guid);
                if (nextLink != null)
                {
                    currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
                    ProcessNextNode();
                }
                else
                    currentNode = null;
                break;
            case CharacterIntConditionNodeData charIntCondition:
                ProcessCharacterIntCondition(charIntCondition);
                break;
            case CharacterModifyIntNodeData charModifyInt:
                ProcessCharacterModifyInt(charModifyInt);
                break;
            case DebugLogNodeData debugLog:
                Debug.Log(debugLog.MessageText);
                GoToNextNode(debugLog.Guid);
                break;
            case DebugWarningNodeData debugWarn:
                Debug.LogWarning(debugWarn.MessageText);
                GoToNextNode(debugWarn.Guid);
                break;
            case DebugErrorNodeData debugErr:
                Debug.LogError(debugErr.MessageText);
                GoToNextNode(debugErr.Guid);
                break;
            case SpeechRandNodeData speechRandNode:
                ProcessSpeechRandNode(speechRandNode);
                break;
            case RandomBranchNodeData randomBranchNode:
                ProcessRandomBranchNode(randomBranchNode);
                break;
            case TimerNodeData timerNode:
                ProcessTimerNode(timerNode);
                break;
            case PauseNodeData pauseNode:
                ProcessPauseNode(pauseNode);
                return;
            case WireNodeData wireNode:
                GoToNextNode(wireNode.Guid);
                break;
            case CharacterButtonPressNodeData characterButtonPressNode:
                ProcessCharacterButtonPressNode(characterButtonPressNode);
                break;
            default:
                Debug.LogWarning($"Неизвестный тип узла: {currentNode?.GetType().Name}");
                currentNode = null;
                break;
        }
    }

    private void ProcessPauseNode(PauseNodeData pauseNode)
    {
        if (_timerDisplayController == null)
        {
            Debug.LogError("TimerDisplayController is not assigned in DialogueManager. Pause timer will not be displayed.");
            // fallback: просто ждём без отображения
            StartCoroutine(DelayedGoToNextNode(pauseNode));
            return;
        }

        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == pauseNode.Guid);
        string nextGuid = nextLink?.TargetNodeGuid;

        void OnPauseTimeout()
        {
            if (!string.IsNullOrEmpty(nextGuid))
            {
                currentNode = GetNodeByGuid(nextGuid);
                ProcessNextNode();
            }
            else
            {
                currentNode = null;
            }
        }

        _timerDisplayController.StartTimer(pauseNode.DurationSeconds, OnPauseTimeout);
    }

    private void ProcessCharacterButtonPressNode(CharacterButtonPressNodeData nodeData)
    {
        var character = CharacterManager.Instance.GetCharacter(nodeData.CharacterName);
        if (character == null)
        {
            Debug.LogError($"Character '{nodeData.CharacterName}' not found for button press node '{nodeData.Guid}'.");
            GoToNextNode(nodeData.Guid);
            return;
        }

        // Если мы впервые меняем этого персонажа в текущем диалоге, сохраняем исходное состояние
        if (!_originalButtonPressStates.ContainsKey(nodeData.CharacterName))
        {
            _originalButtonPressStates[nodeData.CharacterName] = character.RequireButtonPressForMessages;
        }

        character.RequireButtonPressForMessages = nodeData.RequireButtonPress;
        Debug.Log($"Changed RequireButtonPressForMessages for character '{nodeData.CharacterName}' to {nodeData.RequireButtonPress}");
        GoToNextNode(nodeData.Guid);
    }

    private IEnumerator DelayedGoToNextNode(PauseNodeData pauseNode)
    {
        yield return new WaitForSeconds(pauseNode.DurationSeconds);
        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == pauseNode.Guid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    private void ProcessTimerNode(TimerNodeData timerNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == timerNode.Guid)
            .ToList();

        var optionLinks = outgoingLinks
            .Where(link => link.PortName == "Options")
            .Select(link => GetNodeByGuid(link.TargetNodeGuid))
            .Where(node => node is OptionNodeData or OptionNodeImageData)
            .ToList();

        string timeoutTargetGuid = null;
        var timeoutLink = outgoingLinks.FirstOrDefault(l => l.PortName == "Timeout");
        if (timeoutLink != null)
            timeoutTargetGuid = timeoutLink.TargetNodeGuid;

        if (optionLinks.Count > 0 && optionPanel != null)
        {
            var options = new List<Option>();
            foreach (var optNode in optionLinks)
            {
                string text = "Изображение";
                if (optNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";

                // Ищем связь ИЗ опции к следующему узлу
                var nextLink = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optNode).Guid);
                if (nextLink != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLink.TargetNodeGuid
                    });
                }
            }
            if (options.Count > 0)
            {
                optionPanel.ShowOptions(options);
            }
        }

        void OnTimeout()
        {
            if (optionPanel != null && optionPanel.gameObject.activeSelf)
                optionPanel.Hide();

            if (!string.IsNullOrEmpty(timeoutTargetGuid))
            {
                currentNode = GetNodeByGuid(timeoutTargetGuid);
                ProcessNextNode();
            }
            else
            {
                currentNode = null;
            }
        }

        _timerDisplayController?.StartTimer(timerNode.DurationSeconds, OnTimeout);
    }

    private void ProcessRandomBranchNode(RandomBranchNodeData randomBranchNode)
    {
        if (randomBranchNode.Variants.Count == 0)
        {
            Debug.LogError($"RandomBranchNode {randomBranchNode.Guid} has no variants");
            currentNode = null;
            return;
        }

        // Взвешенный случайный выбор
        float totalWeight = 0f;
        foreach (var variant in randomBranchNode.Variants)
            totalWeight += variant.WeightPercent;

        string selectedPort = "";
        if (totalWeight <= 0f)
        {
            // fallback: первый вариант
            selectedPort = randomBranchNode.Variants[0].PortName;
        }
        else
        {
            float pick = (float)random.NextDouble() * totalWeight;
            float current = 0f;
            foreach (var variant in randomBranchNode.Variants)
            {
                current += variant.WeightPercent;
                if (pick <= current)
                {
                    selectedPort = variant.PortName;
                    break;
                }
            }
        }

        // Находим связь по выбранному порту
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == randomBranchNode.Guid && l.PortName == selectedPort)
            .ToList();

        if (outgoingLinks.Count > 0)
        {
            if (outgoingLinks.Count > 1)
            {
                Debug.LogWarning($"RandomBranchNode {randomBranchNode.Guid} has multiple connections for port {selectedPort}. Using first.");
            }
            currentNode = GetNodeByGuid(outgoingLinks.First().TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            Debug.LogWarning($"RandomBranchNode {randomBranchNode.Guid} has no connection for selected port {selectedPort}");
            currentNode = null;
        }
    }

    private void ProcessSpeechRandNode(SpeechRandNodeData speechRandNode)
    {
        CharacterData speaker = null;
        if (!string.IsNullOrEmpty(speechRandNode.SpeakerName))
            speaker = CharacterManager.Instance?.GetCharacter(speechRandNode.SpeakerName);

        string selectedText = "";
        if (speechRandNode.Variants.Count > 0)
        {
            // Взвешенный случайный выбор
            float totalWeight = 0f;
            foreach (var v in speechRandNode.Variants)
                totalWeight += v.WeightPercent;

            if (totalWeight <= 0f)
            {
                // fallback: первый
                selectedText = speechRandNode.Variants[0].Text;
            }
            else
            {
                float pick = (float)random.NextDouble() * totalWeight;
                float current = 0f;
                foreach (var v in speechRandNode.Variants)
                {
                    current += v.WeightPercent;
                    if (pick <= current)
                    {
                        selectedText = v.Text;
                        break;
                    }
                }
            }
        }

        // Если список пуст — selectedText остаётся ""
        var message = new Message
        {
            Type = SenderType.NPC,
            Text = selectedText,
            Image = null,
            Audio = null,
            Sender = speaker
        };

        chatPanel.AddMessage(message, MessageTypeDialogue.Speech);
        chatPanel.ForceScrollToBottom();

        // Если персонаж требует нажатия кнопки для продолжения
        if (speaker != null && speaker.RequireButtonPressForMessages)
        {
            _pendingSpeechRandNode = speechRandNode;
            ShowContinueButton();
            return; // Останавливаем выполнение до нажатия кнопки
        }

        // Обработка исходящих связей
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechRandNode.Guid)
            .ToList();

        var optionLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is OptionNodeData || target is OptionNodeImageData;
        }).ToList();

        if (optionLinks.Any())
        {
            var options = new List<Option>();
            foreach (var linkToOption in optionLinks)
            {
                var optionNode = GetNodeByGuid(linkToOption.TargetNodeGuid);
                if (optionNode == null) continue;

                string text = "Изображение";
                if (optionNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";

                var nextLinkAfterOption = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optionNode).Guid);

                if (nextLinkAfterOption != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLinkAfterOption.TargetNodeGuid
                    });
                }
            }

            if (options.Count > 0 && optionPanel != null)
            {
                optionPanel.ShowOptions(options);
            }
            else
            {
                Debug.LogError("Нет валидных вариантов для отображения!");
                currentNode = null;
            }
            return;
        }

        var speechLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is SpeechNodeData || target is SpeechNodeImageData || target is SpeechRandNodeData;
        }).ToList();

        if (speechLinks.Any())
        {
            if (speechLinks.Count > 1)
            {
                Debug.LogWarning($"SpeechRandNode {speechRandNode.Guid} имеет несколько исходящих Speech-связей. Будет использована первая.");
            }
            string nextGuid = speechLinks.First().TargetNodeGuid;
            StartCoroutine(DelayedGoToNode(nextGuid));
            return;
        }

        var nextLinearLink = outgoingLinks.FirstOrDefault();
        if (nextLinearLink != null)
        {
            currentNode = GetNodeByGuid(nextLinearLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает EntryNodeData
    /// </summary>
    /// <param name="entryNode">Данные начального узла</param>
    private void ProcessEntryNode(EntryNodeData entryNode)
    {
        // Находим следующий узел после EntryNode
        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == entryNode.Guid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            // Если нет следующего узла, завершаем диалог
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает SpeechNodeData
    /// </summary>
    /// <param name="speechNode">Данные узла речи</param>
    private void ProcessSpeechNode(SpeechNodeData speechNode)
    {
        CharacterData speaker = GetCharacterByName(speechNode.SpeakerName);
        if (speaker == null)
        {
            Debug.LogError($"SpeechNode '{speechNode.Guid}' has no valid speaker. Assign a CharacterData in the graph editor.");
            return;
        }

        var message = new Message
        {
            Type = SenderType.NPC,
            Text = speechNode.DialogueText,
            Image = null,
            Audio = AssetLoader.LoadAudioClip(speechNode.AudioClipGuid),
            Sender = speaker
        };

        chatPanel.AddMessage(message, MessageTypeDialogue.Speech);
        chatPanel.ForceScrollToBottom();

        // Если персонаж требует нажатия кнопки для продолжения
        if (speaker.RequireButtonPressForMessages)
        {
            _pendingSpeechNode = speechNode;
            ShowContinueButton();
            return; // Останавливаем выполнение до нажатия кнопки
        }

        // Исходная логика продолжения с задержкой
        if (message.Audio != null)
            StartCoroutine(PlayAudioAfterDelay(message.Audio, messageDelay));

        ProcessSpeechNodeContinuation(speechNode);
    }

    private void ProcessSpeechNodeContinuation(SpeechNodeData speechNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechNode.Guid)
            .ToList();

        // Проверяем: есть ли исходящие связи к OptionNode?
        var optionLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is OptionNodeData || target is OptionNodeImageData;
        }).ToList();

        if (optionLinks.Any())
        {
            // Режим выбора опций
            var options = new List<Option>();
            foreach (var linkToOption in optionLinks)
            {
                var optionNode = GetNodeByGuid(linkToOption.TargetNodeGuid);
                if (optionNode == null) continue;

                string text = "Изображение";
                if (optionNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";

                var nextLinkAfterOption = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optionNode).Guid);

                if (nextLinkAfterOption != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLinkAfterOption.TargetNodeGuid
                    });
                }
            }

            if (options.Count > 0 && optionPanel != null)
            {
                optionPanel.ShowOptions(options);
            }
            else
            {
                Debug.LogError("Нет валидных вариантов для отображения!");
                currentNode = null;
            }
            return;
        }

        // Нет Option — проверяем: есть ли Speech-связи?
        var speechLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is SpeechNodeData || target is SpeechNodeImageData;
        }).ToList();

        if (speechLinks.Any())
        {
            // Цепочка Speech → Speech: запускаем следующее сообщение с задержкой
            if (speechLinks.Count > 1)
            {
                Debug.LogWarning($"SpeechNode {speechNode.Guid} имеет несколько исходящих Speech-связей. Будет использована первая.");
            }
            string nextGuid = speechLinks.First().TargetNodeGuid;
            StartCoroutine(DelayedGoToNode(nextGuid));
            return;
        }

        // Нет ни Option, ни Speech — линейный переход (к Condition, Modify, End и т.д.)
        var nextLinearLink = outgoingLinks.FirstOrDefault();
        if (nextLinearLink != null)
        {
            currentNode = GetNodeByGuid(nextLinearLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает SpeechNodeImageData
    /// </summary>
    /// <param name="speechImageNode">Данные узла изображения речи</param>
    private void ProcessSpeechImageNode(SpeechNodeImageData speechImageNode)
    {
        CharacterData speaker = GetCharacterByName(speechImageNode.SpeakerName);
        if (speaker == null)
        {
            Debug.LogError($"SpeechImageNode '{speechImageNode.Guid}' has no valid speaker...");
            return;
        }

        var message = new Message
        {
            Type = SenderType.NPC,
            Text = null,
            Image = !string.IsNullOrEmpty(speechImageNode.ImageSpritePath) ?
                Resources.Load<Sprite>(speechImageNode.ImageSpritePath) : null,
            Audio = null,
            Sender = speaker
        };

        chatPanel.AddMessage(message, MessageTypeDialogue.SpeechImage);
        chatPanel.ForceScrollToBottom();

        // Если персонаж требует нажатия кнопки для продолжения
        if (speaker.RequireButtonPressForMessages)
        {
            _pendingSpeechImageNode = speechImageNode;
            ShowContinueButton();
            return; // Останавливаем выполнение до нажатия кнопки
        }

        // Исходная логика продолжения с задержкой
        ProcessSpeechImageNodeContinuation(speechImageNode);
    }

    private void ProcessSpeechImageNodeContinuation(SpeechNodeImageData speechImageNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechImageNode.Guid)
            .ToList();

        // Проверяем: есть ли исходящие связи к OptionNode?
        var optionLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is OptionNodeData || target is OptionNodeImageData;
        }).ToList();

        if (optionLinks.Any())
        {
            var options = new List<Option>();
            foreach (var linkToOption in optionLinks)
            {
                var optionNode = GetNodeByGuid(linkToOption.TargetNodeGuid);
                if (optionNode == null) continue;

                string text = "Изображение";
                if (optionNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";

                var nextLinkAfterOption = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optionNode).Guid);

                if (nextLinkAfterOption != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLinkAfterOption.TargetNodeGuid
                    });
                }
            }

            if (options.Count > 0 && optionPanel != null)
            {
                optionPanel.ShowOptions(options);
            }
            else
            {
                Debug.LogError("Нет валидных вариантов для отображения!");
                currentNode = null;
            }
            return;
        }

        // Нет Option — проверяем Speech-связи
        var speechLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is SpeechNodeData || target is SpeechNodeImageData;
        }).ToList();

        if (speechLinks.Any())
        {
            if (speechLinks.Count > 1)
            {
                Debug.LogWarning($"SpeechImageNode {speechImageNode.Guid} имеет несколько исходящих Speech-связей. Будет использована первая.");
            }
            string nextGuid = speechLinks.First().TargetNodeGuid;
            StartCoroutine(DelayedGoToNode(nextGuid));
            return;
        }

        // Линейный переход
        var nextLinearLink = outgoingLinks.FirstOrDefault();
        if (nextLinearLink != null)
        {
            currentNode = GetNodeByGuid(nextLinearLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    private void ShowContinueButton()
    {
        if (_continueButton != null)
        {
            _continueButton.gameObject.SetActive(true);
        }
    }

    private void HideContinueButton()
    {
        if (_continueButton != null)
        {
            _continueButton.gameObject.SetActive(false);
        }
    }

    private void OnContinueButtonPressed()
    {
        HideContinueButton();

        // Продолжаем диалог в зависимости от типа ожидаемого узла
        if (_pendingSpeechNode != null)
        {
            ProcessSpeechNodeContinuation(_pendingSpeechNode);
            _pendingSpeechNode = null;
        }
        else if (_pendingSpeechImageNode != null)
        {
            ProcessSpeechImageNodeContinuation(_pendingSpeechImageNode);
            _pendingSpeechImageNode = null;
        }
        else if (_pendingSpeechRandNode != null)
        {
            ProcessSpeechRandNodeContinuation(_pendingSpeechRandNode);
            _pendingSpeechRandNode = null;
        }
    }

    private void ProcessSpeechRandNodeContinuation(SpeechRandNodeData speechRandNode)
    {
        var outgoingLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == speechRandNode.Guid)
            .ToList();

        var optionLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is OptionNodeData || target is OptionNodeImageData;
        }).ToList();

        if (optionLinks.Any())
        {
            var options = new List<Option>();
            foreach (var linkToOption in optionLinks)
            {
                var optionNode = GetNodeByGuid(linkToOption.TargetNodeGuid);
                if (optionNode == null) continue;

                string text = "Изображение";
                if (optionNode is OptionNodeData opt)
                    text = !string.IsNullOrEmpty(opt.ResponseText) ? opt.ResponseText : "Неизвестный вариант";

                var nextLinkAfterOption = currentDialogue.NodeLinks
                    .FirstOrDefault(l => l.BaseNodeGuid == ((BaseNodeData)optionNode).Guid);

                if (nextLinkAfterOption != null)
                {
                    options.Add(new Option
                    {
                        Text = text,
                        NextNodeGuid = nextLinkAfterOption.TargetNodeGuid
                    });
                }
            }

            if (options.Count > 0 && optionPanel != null)
            {
                optionPanel.ShowOptions(options);
            }
            else
            {
                Debug.LogError("Нет валидных вариантов для отображения!");
                currentNode = null;
            }
            return;
        }

        var speechLinks = outgoingLinks.Where(link =>
        {
            var target = GetNodeByGuid(link.TargetNodeGuid);
            return target is SpeechNodeData || target is SpeechNodeImageData || target is SpeechRandNodeData;
        }).ToList();

        if (speechLinks.Any())
        {
            if (speechLinks.Count > 1)
            {
                Debug.LogWarning($"SpeechRandNode {speechRandNode.Guid} имеет несколько исходящих Speech-связей. Будет использована первая.");
            }
            string nextGuid = speechLinks.First().TargetNodeGuid;
            StartCoroutine(DelayedGoToNode(nextGuid));
            return;
        }

        var nextLinearLink = outgoingLinks.FirstOrDefault();
        if (nextLinearLink != null)
        {
            currentNode = GetNodeByGuid(nextLinearLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    private IEnumerator DelayedGoToNode(string nextNodeGuid, float delay = -1f)
    {
        if (delay < 0f) delay = messageDelay;
        yield return new WaitForSeconds(delay);
        currentNode = GetNodeByGuid(nextNodeGuid);
        ProcessNextNode();
    }

    /// <summary>
    /// Обрабатывает OptionNodeData
    /// </summary>
    private void ProcessOptionNode(OptionNodeData optionNode)
    {
        // Создаем список вариантов ответа
        var options = new List<Option>();
        // Находим все связи от этого узла
        var optionLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == optionNode.Guid)
            .ToList();

        foreach (var link in optionLinks)
        {
            var targetNode = GetNodeByGuid(link.TargetNodeGuid);
            string optionText = "Вариант ответа";
            if (targetNode is OptionNodeData optionTarget)
            {
                optionText = !string.IsNullOrEmpty(optionTarget.ResponseText) ?
                    optionTarget.ResponseText : "Вариант ответа";
            }
            else if (targetNode is OptionNodeImageData)
            {
                optionText = "Изображение";
            }
            options.Add(new Option
            {
                Text = optionText,
                NextNodeGuid = link.TargetNodeGuid
            });
        }

        // Показываем варианты ответа
        if (options.Count > 0 && optionPanel != null)
        {
            optionPanel.ShowOptions(options);
            currentNode = optionNode;
        }
        else
        {
            Debug.LogWarning($"No options found for OptionNode {optionNode.Guid}");
            // Пытаемся найти следующий узел
            var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == optionNode.Guid);
            if (nextLink != null)
            {
                currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
                ProcessNextNode();
            }
            else
            {
                currentNode = null;
            }
        }
    }

    /// <summary>
    /// Обрабатывает OptionNodeImageData
    /// </summary>
    /// <param name="optionImageNode">Данные узла изображения вариантов ответа</param>
    private void ProcessOptionImageNode(OptionNodeImageData optionImageNode)
    {
        // Получаем варианты ответов из узла
        var options = new List<Option>();
        // Получаем связанные OptionNodeData для всех выходов
        var optionLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == optionImageNode.Guid)
            .ToList();

        foreach (var link in optionLinks)
        {
            var targetNode = GetNodeByGuid(link.TargetNodeGuid);
            if (targetNode is OptionNodeData optionTarget)
            {
                options.Add(new Option
                {
                    Text = optionTarget.ResponseText,
                    NextNodeGuid = link.TargetNodeGuid
                });
            }
            else if (targetNode is OptionNodeImageData optionImageTarget)
            {
                // Для изображений вариантов ответа
                options.Add(new Option
                {
                    Text = "Изображение",
                    NextNodeGuid = link.TargetNodeGuid
                });
            }
        }

        // Показываем панель вариантов ответов
        optionPanel.ShowOptions(options);
        // Устанавливаем текущий узел как OptionNode для последующей обработки выбора
        currentNode = optionImageNode;
    }

    /// <summary>
    /// Обрабатывает IntConditionNodeData
    /// </summary>
    /// <param name="intCondition">Данные числового условия</param>
    private void ProcessIntCondition(IntConditionNodeData intCondition)
    {
        // Проверяем условие
        bool conditionResult = ConditionHandler.EvaluateIntCondition(
            intCondition, intVariables);

        // Определяем следующий узел в зависимости от результата
        var nextLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == intCondition.Guid)
            .ToList();

        // Находим подходящий выход
        foreach (var link in nextLinks)
        {
            if (link.PortName == "True" && conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
            else if (link.PortName == "False" && !conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
        }

        // Если подходящий выход не найден, завершаем диалог
        Debug.LogWarning($"Не найден подходящий выход для условия IntConditionNode {intCondition.Guid}");
        currentNode = null;
    }

    /// <summary>
    /// Обрабатывает StringConditionNodeData
    /// </summary>
    /// <param name="stringCondition">Данные строкового условия</param>
    private void ProcessStringCondition(StringConditionNodeData stringCondition)
    {
        // Проверяем условие
        bool conditionResult = ConditionHandler.EvaluateStringCondition(
            stringCondition, stringVariables);

        // Определяем следующий узел в зависимости от результата
        var nextLinks = currentDialogue.NodeLinks
            .Where(l => l.BaseNodeGuid == stringCondition.Guid)
            .ToList();

        // Находим подходящий выход
        foreach (var link in nextLinks)
        {
            if (link.PortName == "True" && conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
            else if (link.PortName == "False" && !conditionResult)
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
        }

        // Если подходящий выход не найден, завершаем диалог
        Debug.LogWarning($"Не найден подходящий выход для условия StringConditionNode {stringCondition.Guid}");
        currentNode = null;
    }

    /// <summary>
    /// Обрабатывает ModifyIntNodeData
    /// </summary>
    /// <param name="modifyNode">Данные модификатора числа</param>
    private void ProcessModifyIntNode(ModifyIntNodeData modifyNode)
    {
        // Проверяем наличие переменной
        if (!intVariables.ContainsKey(modifyNode.SelectedProperty))
        {
            Debug.LogError($"Переменная {modifyNode.SelectedProperty} не найдена в intVariables");
            currentNode = null;
            return;
        }

        // Применяем операцию
        switch (modifyNode.Operator)
        {
            case OperatorType.Set:
                intVariables[modifyNode.SelectedProperty] = modifyNode.Value;
                break;
            case OperatorType.Add:
                intVariables[modifyNode.SelectedProperty] += modifyNode.Value;
                break;
            case OperatorType.Subtract:
                intVariables[modifyNode.SelectedProperty] -= modifyNode.Value;
                break;
            case OperatorType.Multiply:
                intVariables[modifyNode.SelectedProperty] *= modifyNode.Value;
                break;
            case OperatorType.Divide:
                if (modifyNode.Value != 0)
                    intVariables[modifyNode.SelectedProperty] /= modifyNode.Value;
                else
                    Debug.LogWarning("Деление на ноль в ModifyIntNode");
                break;
            case OperatorType.Increment:
                intVariables[modifyNode.SelectedProperty]++;
                break;
            case OperatorType.Decrement:
                intVariables[modifyNode.SelectedProperty]--;
                break;
        }

        // Находим следующий узел
        var nextLink = currentDialogue.NodeLinks
            .FirstOrDefault(l => l.BaseNodeGuid == modifyNode.Guid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Обрабатывает EndNodeData
    /// </summary>
    /// <param name="endNode">Данные конечного узла</param>
    private void ProcessEndNode(EndNodeData endNode)
    {
        // Добавляем системное сообщение о завершении диалога
        var message = new Message
        {
            Type = SenderType.System,
            Text = "Диалог завершен"
        };

        chatPanel.AddMessage(message, MessageTypeDialogue.System);
        chatPanel.ForceScrollToBottom();

        // Если указан следующий диалог, запускаем его
        if (!string.IsNullOrEmpty(endNode.NextDialogueName))
        {
            DialogueContainer nextDialogue = Resources.Load<DialogueContainer>(endNode.NextDialogueName);
            if (nextDialogue != null)
            {
                StartDialogue(nextDialogue);
            }
            else
            {
                Debug.LogError($"Диалог {endNode.NextDialogueName} не найден в ресурсах");
            }
        }
        else
        {
            // Завершаем текущий диалог
            currentNode = null;
        }
    }

    /// <summary>
    /// Обработка выбора опции игроком с задержкой перед следующим сообщением
    /// </summary>
    public void HandleOptionSelection(string nextNodeGuid)
    {
        if (optionPanel != null)
            optionPanel.Hide();

        _timerDisplayController?.StopTimer();

        currentNode = GetNodeByGuid(nextNodeGuid);
        ProcessNextNode();
    }

    /// <summary>
    /// Получает узел по его GUID
    /// </summary>
    /// <param name="guid">GUID узла</param>
    /// <returns>BaseNodeData или null</returns>
    private object GetNodeByGuid(string guid)
    {
        if (string.IsNullOrEmpty(guid))
            return null;

        // Ищем в Speech
        var speechNode = currentDialogue.SpeechNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (speechNode != null) return speechNode;

        var speechImageNode = currentDialogue.SpeechNodeImageDatas.FirstOrDefault(n => n.Guid == guid);
        if (speechImageNode != null) return speechImageNode;

        var optionNode = currentDialogue.OptionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (optionNode != null) return optionNode;

        var optionImageNode = currentDialogue.OptionNodeImageDatas.FirstOrDefault(n => n.Guid == guid);
        if (optionImageNode != null) return optionImageNode;

        var intConditionNode = currentDialogue.IntConditionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (intConditionNode != null) return intConditionNode;

        var stringConditionNode = currentDialogue.StringConditionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (stringConditionNode != null) return stringConditionNode;

        var modifyIntNode = currentDialogue.ModifyIntNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (modifyIntNode != null) return modifyIntNode;

        var endNode = currentDialogue.EndNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (endNode != null) return endNode;

        var charIntConditionNode = currentDialogue.CharacterIntConditionNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (charIntConditionNode != null) return charIntConditionNode;

        var charModifyIntNode = currentDialogue.CharacterModifyIntNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (charModifyIntNode != null) return charModifyIntNode;

        var debugLogNode = currentDialogue.DebugLogNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (debugLogNode != null) return debugLogNode;

        var debugWarnNode = currentDialogue.DebugWarningNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (debugWarnNode != null) return debugWarnNode;

        var debugErrNode = currentDialogue.DebugErrorNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (debugErrNode != null) return debugErrNode;

        // Поддержка SpeechRandNodeData
        var speechRandNode = currentDialogue.SpeechRandNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (speechRandNode != null) return speechRandNode;

        var timerNode = currentDialogue.TimerNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (timerNode != null) return timerNode;

        var pauseNode = currentDialogue.PauseNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (pauseNode != null) return pauseNode;

        var wireNode = currentDialogue.WireNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (wireNode != null) return wireNode;

        var charButtonPressNode = currentDialogue.CharacterButtonPressNodeDatas.FirstOrDefault(n => n.Guid == guid);
        if (charButtonPressNode != null) return charButtonPressNode;

        // EntryNode ищем ОТДЕЛЬНО и ТОЛЬКО если guid совпадает
        if (currentDialogue.EntryNodeData?.Guid == guid)
            return currentDialogue.EntryNodeData;

        // Если ничего не найдено — возвращаем null
        return null;
    }

    private void GoToNextNode(string currentGuid)
    {
        var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == currentGuid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else
        {
            currentNode = null;
        }
    }

    /// <summary>
    /// Воспроизводит аудио с задержкой после отображения текста
    /// </summary>
    /// <param name="audioClip">Аудио клип для воспроизведения</param>
    /// <param name="delay">Задержка в секундах</param>
    /// <returns>Корутину для воспроизведения аудио</returns>
    private IEnumerator PlayAudioAfterDelay(AudioClip audioClip, float delay)
    {
        yield return new WaitForSeconds(delay);
        AudioSource.PlayClipAtPoint(audioClip, Camera.main.transform.position);
    }

    /// <summary>
    /// Сбрасывает текущий диалог
    /// </summary>
    public void ResetDialogue()
    {
        // Восстанавливаем исходные состояния персонажей
        RestoreOriginalCharacterStates();

        currentDialogue = null;
        currentNode = null;
        visitedNodes.Clear();
        ResetVariables();
    }

    private void RestoreOriginalCharacterStates()
    {
        foreach (var kvp in _originalButtonPressStates)
        {
            var character = CharacterManager.Instance.GetCharacter(kvp.Key);
            if (character != null)
            {
                character.RequireButtonPressForMessages = kvp.Value;
            }
        }

        // Очищаем кэш после восстановления
        _originalButtonPressStates.Clear();
    }

    /// <summary>
    /// Получает персонажа по имени из Resources/Characters
    /// </summary>
    private CharacterData GetCharacterByName(string characterName)
    {
        if (string.IsNullOrEmpty(characterName))
            return null;

        // Ищем в кэше CharacterManager
        var character = CharacterManager.Instance?.GetCharacter(characterName);
        if (character != null)
            return character;

        // Fallback: загрузка напрямую из Resources
        character = Resources.Load<CharacterData>($"Characters/{characterName}");
        if (character == null)
            Debug.LogError($"Character '{characterName}' not found in Resources/Characters");
        return character;
    }

    /// <summary>
    /// Вспомогательный класс для загрузки ассетов в runtime
    /// </summary>
    public static class AssetLoader
    {
        /// <summary>
        /// Загружает аудио клип по GUID (заглушка для runtime)
        /// </summary>
        /// <param name="guid">GUID аудио</param>
        /// <returns>AudioClip или null</returns>
        public static AudioClip LoadAudioClip(string guid)
        {
            // В runtime нет AssetDatabase, поэтому используем заглушку
            // В реальной системе нужно реализовать загрузку из Resources
            return null;
        }

        /// <summary>
        /// Загружает спрайт по GUID (заглушка для runtime)
        /// </summary>
        /// <param name="guid">GUID спрайта</param>
        /// <returns>Sprite или null</returns>
        public static Sprite LoadSprite(string guid)
        {
            // В runtime нет AssetDatabase, поэтому используем заглушку
            // В реальной системе нужно реализовать загрузку из Resources
            return null;
        }
    }

    private void ProcessCharacterIntCondition(CharacterIntConditionNodeData condition)
    {
        var character = CharacterManager.Instance.GetCharacter(condition.CharacterName);
        if (character == null)
        {
            Debug.LogError($"Character '{condition.CharacterName}' not found for condition node.");
            currentNode = null;
            return;
        }

        if (!character.TryGetVariable(condition.SelectedVariable, out var variable))
        {
            Debug.LogError($"Variable '{condition.SelectedVariable}' not found on character '{condition.CharacterName}'.");
            currentNode = null;
            return;
        }

        bool result = false;
        switch (condition.Comparison)
        {
            case ComparisonType.Equal: result = variable.Value == condition.CompareValue; break;
            case ComparisonType.NotEqual: result = variable.Value != condition.CompareValue; break;
            case ComparisonType.Greater: result = variable.Value > condition.CompareValue; break;
            case ComparisonType.Less: result = variable.Value < condition.CompareValue; break;
            case ComparisonType.GreaterOrEqual: result = variable.Value >= condition.CompareValue; break;
            case ComparisonType.LessOrEqual: result = variable.Value <= condition.CompareValue; break;
            default: result = false; break;
        }

        var nextLinks = currentDialogue.NodeLinks.Where(l => l.BaseNodeGuid == condition.Guid).ToList();
        foreach (var link in nextLinks)
        {
            if ((link.PortName == "True" && result) || (link.PortName == "False" && !result))
            {
                currentNode = GetNodeByGuid(link.TargetNodeGuid);
                ProcessNextNode();
                return;
            }
        }

        Debug.LogWarning($"No matching output port for CharacterIntConditionNode {condition.Guid}");
        currentNode = null;
    }

    private void ProcessCharacterModifyInt(CharacterModifyIntNodeData modify)
    {
        var character = CharacterManager.Instance.GetCharacter(modify.CharacterName);
        if (character == null)
        {
            Debug.LogError($"Character '{modify.CharacterName}' not found for modify node.");
            currentNode = null;
            return;
        }

        if (!character.TryGetVariable(modify.SelectedVariable, out var variable))
        {
            Debug.LogError($"Variable '{modify.SelectedVariable}' not found on character '{modify.CharacterName}'.");
            currentNode = null;
            return;
        }

        switch (modify.Operator)
        {
            case OperatorType.Set: variable.Value = modify.Value; break;
            case OperatorType.Add: variable.Value += modify.Value; break;
            case OperatorType.Subtract: variable.Value -= modify.Value; break;
            case OperatorType.Multiply: variable.Value *= modify.Value; break;
            case OperatorType.Divide:
                if (modify.Value != 0) variable.Value /= modify.Value;
                else Debug.LogWarning("Division by zero in CharacterModifyIntNode");
                break;
            case OperatorType.Increment: variable.Value++; break;
            case OperatorType.Decrement: variable.Value--; break;
        }

        var nextLink = currentDialogue.NodeLinks.FirstOrDefault(l => l.BaseNodeGuid == modify.Guid);
        if (nextLink != null)
        {
            currentNode = GetNodeByGuid(nextLink.TargetNodeGuid);
            ProcessNextNode();
        }
        else currentNode = null;
    }

    private void OnDestroy()
    {
        RestoreOriginalCharacterStates();
    }
}

//==== File 6 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Message.cs ====
using UnityEngine;

/// <summary>
/// ������ ������ ��� ��������� � ����
/// </summary>
[System.Serializable]
public class Message
{
    /// <summary>
    /// ��� ���������: NPC, ����� ��� ���������
    /// </summary>
    public SenderType Type;

    /// <summary>
    /// ����� ��������� (��� ��������� ���������)
    /// </summary>
    public string Text;

    /// <summary>
    /// ����������� ��� ��������� (������)
    /// </summary>
    public Sprite Image;

    /// <summary>
    /// ����� ��� ��������� ( AudioClip )
    /// </summary>
    public AudioClip Audio;

    /// <summary>
    /// ��������, ����������� ��������� (��� NPC)
    /// </summary>
    public CharacterData Sender;
}

/// <summary>
/// ���� ��������� � ����
/// </summary>
public enum SenderType
{
    NPC,      // ��������� �� NPC
    Player,   // ��������� �� ������
    System    // ��������� ��������� (��������, "������ ��������")
}

public enum MessageTypeDialogue
{
    System,
    Speech, SpeechText, SpeechImage, SpeechAudio,
    OptionText, OptionImage, OptionAudio,
    Event, Log
}



//==== File 7 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\MessageObject.cs ====
using UnityEngine;

public interface IMessageObject
{
    void InitializationContent(Message contentMessage);
    void SetCharacterAvatar(CharacterData characte);
    void SetCharacterName(CharacterData character);
}


//==== File 8 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Option.cs ====
using System;

/// <summary>
/// ������ �������� ������
/// </summary>
[Serializable]
public class Option
{
    public string Text; // ����� ��������
    public string NextNodeGuid; // GUID ���������� ����
}

//==== File 9 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\OptionPanel.cs ====
using System;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class OptionPanel : MonoBehaviour
{
    [SerializeField] private GameObject optionButtonPrefab;
    [SerializeField] private Transform contentContainer;

    public event Action<string> onOptionSelected;

    /// <summary>
    /// ���������� ������ � ���������� �������
    /// </summary>
    public void ShowOptions(List<Option> options)
    {
        if (optionButtonPrefab == null || contentContainer == null)
        {
            Debug.LogError("OptionPanel references not set!");
            return;
        }

        // ������� ���������� ������
        foreach (Transform child in contentContainer)
            Destroy(child.gameObject);

        // ������� ������ ��� ������� ��������
        foreach (var option in options)
        {
            var buttonGO = Instantiate(optionButtonPrefab, contentContainer);
            var button = buttonGO.GetComponent<Button>();
            var buttonText = buttonGO.GetComponentInChildren<TMP_Text>();

            if (buttonText != null)
                buttonText.text = option.Text;
            else
                Debug.LogError("Text component not found in option button prefab");

            if (button != null)
                button.onClick.AddListener(() => onOptionSelected?.Invoke(option.NextNodeGuid));
        }

        gameObject.SetActive(true);
    }

    /// <summary>
    /// �������� ������ ���������
    /// </summary>
    public void Hide()
    {
        while (contentContainer.transform.childCount > 0)
            GameObject.DestroyImmediate(contentContainer.transform.GetChild(0).gameObject);
    }
}

//==== File 10 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\OptionTextMessage.cs ====
using UnityEngine;
using TMPro;

public class OptionTextMessage : MonoBehaviour, IMessageObject
{
    [Header("Message Data")]
    [SerializeField] private TMP_Text textMessage;
    public void InitializationContent(Message contentMessage)
    {
        if (!string.IsNullOrEmpty(contentMessage.Text))
            textMessage.text = contentMessage.Text;
        else textMessage.text = "";

        SetCharacterAvatar(contentMessage.Sender);
        SetCharacterName(contentMessage.Sender);
    }

    public void SetCharacterAvatar(CharacterData characte)
    {
        
    }

    public void SetCharacterName(CharacterData character)
    {
        
    }
}


//==== File 11 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\SpeechAudioMessage.cs ====
// Assets/Scripts/SpeechAudioMessage.cs
using UnityEngine;
using UnityEngine.UI;
using TMPro;

/// <summary>
/// ������ ��������� � ����� �� ��������� (��� ������/�����������)
/// </summary>
public class SpeechAudioMessage : MonoBehaviour, IMessageObject
{
    [Header("Character Data")]
    [SerializeField] private Image characterAvatar;
    [SerializeField] private TMP_Text characterName;

    [Header("Message Data")]
    // ����� �� ������������ ���������, �� ����� �������������� ��� �������� ���������������
    // ���������� ������� ����� ���� ������ ��� ��������� ������ �������� � �.�.
    [SerializeField] private GameObject audioIndicator; // �����������

    public void InitializationContent(Message contentMessage)
    {
        // ����� �������������� � DialogueManager, ����� ������ ������
        if (audioIndicator != null)
        {
            audioIndicator.SetActive(contentMessage.Audio != null);
        }

        SetCharacterAvatar(contentMessage.Sender);
        SetCharacterName(contentMessage.Sender);
    }

    public void SetCharacterAvatar(CharacterData character)
    {
        if (characterAvatar != null && character != null && character.Icon != null)
            characterAvatar.sprite = character.Icon;
    }

    public void SetCharacterName(CharacterData character)
    {
        if (characterName != null && character != null)
        {
            characterName.text = character.FirstName;
            characterName.color = character.NameColor;
        }
    }
}


//==== File 12 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\SpeechImageMessage.cs ====
// Assets/Scripts/SpeechImageMessage.cs
using UnityEngine;
using UnityEngine.UI;
using TMPro;

/// <summary>
/// ��������� ��� ����������� ��������� � ���� ����������� �� ���������
/// ��������� ��������� IMessageObject ��� ���������� � ChatPanel
/// </summary>
public class SpeechImageMessage : MonoBehaviour, IMessageObject
{
    [Header("Character Data")]
    [SerializeField] private Image characterAvatar;
    [SerializeField] private TMP_Text characterName;

    [Header("Message Data")]
    [SerializeField] private Image messageImage;

    public void InitializationContent(Message contentMessage)
    {
        if (messageImage == null)
        {
            Debug.LogError("messageImage is not assigned!");
            return;
        }

        if (contentMessage.Image != null)
        {
            messageImage.sprite = contentMessage.Image;
            messageImage.enabled = true;
        }
        else
        {
            messageImage.enabled = false;
        }

        SetCharacterAvatar(contentMessage.Sender);
        SetCharacterName(contentMessage.Sender);
    }

    public void SetCharacterAvatar(CharacterData character)
    {
        if (characterAvatar != null && character != null && character.Icon != null)
            characterAvatar.sprite = character.Icon;
    }

    public void SetCharacterName(CharacterData character)
    {
        if (characterName != null && character != null)
        {
            characterName.text = character.FirstName;
            characterName.color = character.NameColor;
        }
    }
}

//==== File 13 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\SpeechTextMessage.cs ====
using UnityEngine.UI;
using UnityEngine;
using TMPro;

public class SpeechTextMessage : MonoBehaviour, IMessageObject
{
    [Header("Character Data")]
    [SerializeField] private Image characterAvatar;
    [SerializeField] private TMP_Text characterName;

    [Header("Message Data")]
    [SerializeField] private TMP_Text textMessage;

    private RectTransform _rectTransform;
    private ContentSizeFitter _contentSizeFitter;

    private void Awake()
    {
        _rectTransform = GetComponent<RectTransform>();
        _contentSizeFitter = GetComponent<ContentSizeFitter>();

        if (_contentSizeFitter == null)
            _contentSizeFitter = gameObject.AddComponent<ContentSizeFitter>();

        // �����: ��� ������ �� ������, ������ � ����������� ����� RectTransform
        _contentSizeFitter.horizontalFit = ContentSizeFitter.FitMode.Unconstrained;
        _contentSizeFitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

        // ��������� TMP
        if (textMessage != null)
        {
            textMessage.enableWordWrapping = true;
            textMessage.textWrappingMode = TextWrappingModes.Normal;
            textMessage.overflowMode = TextOverflowModes.Overflow; // �� ��������
        }
    }

    public void InitializationContent(Message contentMessage)
    {
        if (textMessage == null)
        {
            Debug.LogError("textMessage is not assigned!");
            return;
        }

        textMessage.text = !string.IsNullOrEmpty(contentMessage.Text) ? contentMessage.Text : "";

        // ������������� ������������ ������ = 80% ������
        float maxWidth = Screen.width * 0.8f;

        // ������������ ������ ����� RectTransform
        _rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, maxWidth);

        // ������������� ��������� �����, ����� ������� ��������
        textMessage.ForceMeshUpdate();

        SetCharacterAvatar(contentMessage.Sender);
        SetCharacterName(contentMessage.Sender);
    }

    public void SetCharacterAvatar(CharacterData character)
    {
        if (characterAvatar != null && character != null && character.Icon != null)
            characterAvatar.sprite = character.Icon;
    }

    public void SetCharacterName(CharacterData character)
    {
        if (characterName != null && character != null)
        {
            characterName.text = character.FirstName;
            characterName.color = character.NameColor;
        }
    }
}

//==== File 14 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\TimerDisplayController.cs ====
using UnityEngine;

using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System;

public class TimerDisplayController : MonoBehaviour
{
    [SerializeField] private TMP_Text _timerText;
    [SerializeField] private Image _fillImage;

    private float _duration;
    private float _elapsed;
    private bool _isRunning;
    private Action _onTimeout;

    private void Update()
    {
        if (!_isRunning || Time.timeScale == 0f) return;

        _elapsed += Time.unscaledDeltaTime;
        float remaining = Mathf.Max(0f, _duration - _elapsed);
        float fill = remaining / _duration;

        _timerText.text = $"{remaining:F2}";
        _fillImage.fillAmount = fill;

        if (remaining <= 0f)
        {
            StopTimer();
            _onTimeout?.Invoke();
        }
    }

    public void StartTimer(float duration, Action onTimeout)
    {
        _duration = duration;
        _elapsed = 0f;
        _onTimeout = onTimeout;
        _isRunning = true;
        _timerText.text = $"{_duration:F2}";
        _fillImage.fillAmount = 1f;
        gameObject.SetActive(true);
    }

    public void StopTimer()
    {
        _isRunning = false;
        gameObject.SetActive(false);
    }
}

//==== File 15 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\AutoSaveHandler.cs ====
using UnityEditor;
using UnityEngine;
using System.Linq;
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;

/// <summary>
/// ���������� ��������������� ���������� ���� �������� ���� Dialogue Graph ��� �������� Unity
/// </summary>
[InitializeOnLoad]
public static class AutoSaveHandler
{
    static AutoSaveHandler()
    {
        // ������������� �� ������� �������� ��������� Unity
        EditorApplication.quitting += OnUnityQuitting;
    }

    private static void OnUnityQuitting()
    {
        try
        {
            // AUTO-SAVE: ��������� ��������� ���������� �������
            DialogueSettingsData settings = LoadDialogueSettings();
            if (settings == null || !settings.General.AutoSaveOnUnityClose)
                return; // ���� ��������� ��������� - �������

            Debug.Log("Auto-saving all open Dialogue Graph windows...");

            // AUTO-SAVE: ������� ��� �������� ���� DialogueGraph
            var graphWindows = Resources.FindObjectsOfTypeAll<DialogueGraph>()
                .Where(window => window != null && window.graphView != null)
                .ToList();

            if (graphWindows.Count == 0)
                return; // ��� �������� ���� ��� ����������

            // AUTO-SAVE: ��������� ������ ����
            int savedCount = 0;
            foreach (var window in graphWindows)
            {
                if (window == null) continue;

                try
                {
                    // AUTO-SAVE: �������� ������� ����������� ��������� �� ����
                    var container = window.GetCurrentLoadedContainer();

                    // AUTO-SAVE: ���������� ���� ��� ������������ ����������
                    if (container == null)
                        continue;

                    // AUTO-SAVE: ���������� ������������ ����� ����������
                    var saveUtility = GraphSaveUtility.GetInstance(window.graphView);
                    saveUtility.SaveGraphToExistingContainer(container);

                    savedCount++;
                }
                catch (System.Exception e)
                {
                    Debug.LogError($"Error auto-saving dialogue graph: {e.Message}");
                }
            }

            // AUTO-SAVE: ��������� ��������� ������ � �������
            if (savedCount > 0)
            {
                AssetDatabase.SaveAssets();
                Debug.Log($"Auto-saved {savedCount} dialogue graph windows");
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Critical error in AutoSaveHandler: {e.Message}");
        }
    }

    /// <summary>
    /// ��������� ��������� ���������� �������
    /// </summary>
    private static DialogueSettingsData LoadDialogueSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length == 0)
            return null;

        // ����� ������ ��������� ���� ��������
        string path = AssetDatabase.GUIDToAssetPath(guids[0]);
        return AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
    }
}


//==== File 16 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph.cs ====
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

/// <summary>
/// Главное окно редактора диалоговых графов
/// Содержит тулбар и область для редактирования графа
/// </summary>
public class DialogueGraph : EditorWindow
{
    public DialogueGraphView graphView;
    private string fileName = "New Narrative";


    /// <summary>
    /// Открывает окно редактора диалоговых графов
    /// </summary>
    [MenuItem("Dialog System/Open Graph Editor")]
    public static void OpenDialogueGraphWindow()
    {
        var window = GetWindow<DialogueGraph>();
        window.titleContent = new GUIContent("Dialogue Graph");
    }

    /// <summary>
    /// Инициализация окна редактора
    /// </summary>
    private void OnEnable()
    {
        ConstructGraphView();
        GenerateToolbar();
        rootVisualElement.RegisterCallback<KeyDownEvent>(OnKeyDownEvent);

        if (graphView != null)
            graphView.UpdateGraphBackgroundInternal();
    }

    private void OnKeyDownEvent(KeyDownEvent evt)
    {
        // Проверяем комбинацию Ctrl + S (только Windows)
        if (!evt.ctrlKey || evt.keyCode != KeyCode.S)
            return;
        // Проверяем, что окно редактора активно
        if (EditorWindow.focusedWindow != this)
            return;
        evt.StopPropagation(); // Предотвращаем системное сохранение сцены
        var assetField = rootVisualElement.Q<ObjectField>("Dialogue File");
        var container = assetField?.value as DialogueContainer;
        // Случай: нет привязанного файла
        if (container == null)
        {
            // Проверяем, есть ли хоть какой-то контент помимо EntryNode
            bool hasContent = graphView?.nodes != null &&
                              graphView.nodes.OfType<BaseNode>().Any(n => !n.EntryPoint);
            if (!hasContent)
            {
                EditorUtility.DisplayDialog("No File", "No dialogue file is currently loaded. Please create or load one first.", "OK");
                return;
            }

            DialogueSettingsData settings = LoadDialogueSettings();
            string path = null;

            // Проверяем настройки автосохранения
            if (settings != null && settings.General.enableAutoSaveLocation &&
                !string.IsNullOrEmpty(settings.General.autoSaveFolderPath) &&
                settings.IsValidSavePath(settings.General.autoSaveFolderPath))
            {
                // Используем папку автосохранения
                string folderPath = settings.GetFullPath();
                string timestamp = System.DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string fileName = $"Dialogue_{timestamp}.asset";
                path = System.IO.Path.Combine(folderPath, fileName);
                path = path.Replace("\\", "/");
            }
            else
            {
                // ВСЕГДА показываем диалог при отключенном автосохранении
                path = EditorUtility.SaveFilePanelInProject(
                    "Save Dialogue As",
                    "NewDialogue",
                    "asset",
                    "Choose location and name for the dialogue file"
                );

                if (string.IsNullOrEmpty(path))
                    return;
            }

            // Создаём новый контейнер
            var newContainer = ScriptableObject.CreateInstance<DialogueContainer>();
            var saveUtility = GraphSaveUtility.GetInstance(graphView);
            saveUtility.SaveGraphToExistingContainer(newContainer);
            // Сохраняем в AssetDatabase
            AssetDatabase.CreateAsset(newContainer, path);
            AssetDatabase.SaveAssets();
            // Обновляем ObjectField
            assetField.SetValueWithoutNotify(newContainer);
            EditorUtility.DisplayDialog("Saved", "Dialogue saved successfully!", "OK");
            return;
        }
        // Случай: файл уже задан — просто сохраняем
        SaveCurrentDialogue();
    }


    /// <summary>
    /// Создает область для редактирования графа
    /// </summary>
    private void ConstructGraphView()
    {
        graphView = new DialogueGraphView(this)
        {
            name = "Dialogue Graph"
        };

        graphView.StretchToParentSize();
        rootVisualElement.Add(graphView);
    }

    /// <summary>
    /// Генерация тулбара с новыми элементами управления
    /// </summary>
    private void GenerateToolbar()
    {
        var toolbar = new Toolbar();
        // Поле выбора существующего файла диалога
        var dialogueAssetField = new ObjectField("Dialogue File")
        {
            objectType = typeof(DialogueContainer),
            value = null
        };
        dialogueAssetField.name = "Dialogue File"; // важно для поиска через Q
        dialogueAssetField.RegisterValueChangedCallback(evt =>
        {
            if (evt.newValue is DialogueContainer container)
            {
                LoadDialogueFromFile(container);
            }
        });
        toolbar.Add(dialogueAssetField);
        // Кнопка создания нового диалога
        toolbar.Add(new Button(CreateNewDialogue) { text = "Create New..." });
        // Кнопка сохранения
        toolbar.Add(new Button(SaveCurrentDialogue) { text = "Save" });
        // Base Character field (в конце)
        var baseCharacterField = new ObjectField("Base Character")
        {
            objectType = typeof(CharacterData),
            value = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(graphView.BaseCharacterGuid)
        };
        baseCharacterField.RegisterValueChangedCallback(evt =>
        {
            var character = evt.newValue as CharacterData;
            graphView.BaseCharacterGuid = AssetDatabaseHelper.GetAssetGuid(character);
            UpdateAllSpeechNodesSpeaker(character);
            graphView.MarkUnsavedChangeWithoutFile(); // ← добавлено
        });
        toolbar.Add(baseCharacterField);
        rootVisualElement.Add(toolbar);
    }

    /// <summary>
    /// Создаёт новый диалог и сохраняет его по пути в зависимости от настроек автосохранения
    /// </summary>
    private void CreateNewDialogue()
    {
        DialogueSettingsData settings = LoadDialogueSettings();
        string path = null;

        // Проверяем настройки автосохранения ПЕРЕД определением пути
        if (settings != null && settings.General.enableAutoSaveLocation &&
            !string.IsNullOrEmpty(settings.General.autoSaveFolderPath) &&
            settings.IsValidSavePath(settings.General.autoSaveFolderPath))
        {
            // Используем папку автосохранения
            string folderPath = settings.GetFullPath();
            string timestamp = System.DateTime.Now.ToString("yyyyMMdd_HHmmss");
            string fileName = $"Dialogue_{timestamp}.asset";
            path = System.IO.Path.Combine(folderPath, fileName);
            path = path.Replace("\\", "/");
        }
        else
        {
            // Показываем диалог выбора папки, если автосохранение отключено
            path = EditorUtility.SaveFilePanelInProject(
                "Save New Dialogue",
                "NewDialogue",
                "asset",
                "Choose location and name for the dialogue file"
            );

            if (string.IsNullOrEmpty(path))
                return;
        }

        // Создаём контейнер
        var newContainer = ScriptableObject.CreateInstance<DialogueContainer>();
        // Сохраняем текущее состояние графа в контейнер
        var saveUtility = GraphSaveUtility.GetInstance(graphView);
        saveUtility.SaveGraphToExistingContainer(newContainer);
        // Сохраняем файл
        AssetDatabase.CreateAsset(newContainer, path);
        AssetDatabase.SaveAssets();
        // Обновляем ObjectField
        var assetField = rootVisualElement.Q<ObjectField>("Dialogue File");
        if (assetField != null)
            assetField.SetValueWithoutNotify(newContainer);
        // Загружаем диалог (это сбросит флаги)
        LoadDialogueFromFile(newContainer);
        // Сбрасываем состояние "без файла"
        graphView._hasUnsavedChangesWithoutFile = false;
        graphView._unsavedChangesWarningShown = false;
        Debug.Log($"Создан новый диалог: {path}");
        EditorUtility.DisplayDialog("Success", $"Диалог создан и открыт: {fileName}", "OK");
    }

    private DialogueSettingsData LoadDialogueSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length > 0)
        {
            string path = AssetDatabase.GUIDToAssetPath(guids[0]);
            return AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
        }
        return null;
    }

    /// <summary>
    /// Загружает диалог из выбранного в ObjectField контейнера
    /// </summary>
    private void LoadDialogueFromFile(DialogueContainer container)
    {
        if (container == null) return;

        var saveUtility = GraphSaveUtility.GetInstance(graphView);
        saveUtility.LoadGraphFromContainer(container);

        // Обновляем GUID базового персонажа в графе
        graphView.BaseCharacterGuid = container.BaseCharacterGuid;

        // Обновляем отображение Base Character в тулбаре
        var baseCharField = rootVisualElement.Q<ObjectField>("Base Character");
        if (baseCharField != null)
        {
            baseCharField.SetValueWithoutNotify(
                AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(container.BaseCharacterGuid)
            );
        }
    }

    /// <summary>
    /// Открывает проводник для выбора существующего .asset файла диалога
    /// </summary>
    private void LoadDialogueFromFileBrowser()
    {
        string path = EditorUtility.OpenFilePanel(
            "Load Dialogue File",
            Application.dataPath,
            "asset"
        );
        if (string.IsNullOrEmpty(path)) return;
        // Преобразуем абсолютный путь в относительный от Assets
        if (!path.StartsWith(Application.dataPath))
        {
            EditorUtility.DisplayDialog("Invalid Path", "Please select a file inside the Assets folder.", "OK");
            return;
        }
        string relativePath = "Assets" + path.Substring(Application.dataPath.Length);
        var container = AssetDatabase.LoadAssetAtPath<DialogueContainer>(relativePath);
        if (container == null)
        {
            EditorUtility.DisplayDialog("Invalid File", "Selected file is not a valid DialogueContainer.", "OK");
            return;
        }
        // Обновляем ObjectField
        var assetField = rootVisualElement.Q<ObjectField>("Dialogue File");
        if (assetField != null)
            assetField.SetValueWithoutNotify(container);
        LoadDialogueFromFile(container);
        graphView._hasUnsavedChangesWithoutFile = false;
        graphView._unsavedChangesWarningShown = false;
    }

    /// <summary>
    /// Сохраняет текущий граф в уже загруженный/созданный файл
    /// </summary>
    public void SaveCurrentDialogue()
    {
        var container = GetCurrentLoadedContainer();
        if (container == null)
        {
            EditorUtility.DisplayDialog("No File", "No dialogue file is currently loaded...", "OK");
            return;
        }
        var saveUtility = GraphSaveUtility.GetInstance(graphView);
        saveUtility.SaveGraphToExistingContainer(container);
        // === НОВОЕ: обновляем фон после сохранения настроек ===
        DialogueGraphView.UpdateGraphBackgroundForAllInstances();
        EditorUtility.DisplayDialog("Saved", "Dialogue saved successfully!", "OK");
    }

    /// <summary>
    /// Вспомогательный метод: получает текущий загруженный контейнер по пути
    /// </summary> 
    public DialogueContainer GetCurrentLoadedContainer()
    {
        var assetField = rootVisualElement.Q<ObjectField>("Dialogue File");
        return assetField?.value as DialogueContainer;
    }

    /// <summary>
    /// Обрабатывает запрос на сохранение или загрузку данных
    /// </summary>
    private void RequestDataOperation(bool save)
    {
        if (string.IsNullOrEmpty(fileName))
        {
            EditorUtility.DisplayDialog("Invalid file name!", "Please enter a valid file name.", "OK");
            return;
        }

        var saveUtility = GraphSaveUtility.GetInstance(graphView);
        if (save)
            saveUtility.SaveGraph(fileName);
        else
            saveUtility.LoadGraph(fileName);
    }

    /// <summary>
    /// Очищает ресурсы при закрытии окна
    /// </summary>
    private void OnDisable()
    {
        rootVisualElement.Remove(graphView);
    }

    private void UpdateAllSpeechNodesSpeaker(CharacterData character)
    {
        if (character == null) return;

        foreach (var node in graphView.nodes.ToList())
        {
            switch (node)
            {
                case SpeechNode speechNode when speechNode.Speaker == null:
                    speechNode.SetSpeaker(character);
                    break;
                case SpeechNodeImage speechImageNode when speechImageNode.Speaker == null:
                    speechImageNode.SetSpeaker(character);
                    break;
                case SpeechNodeRandText speechRandNode when speechRandNode.Speaker == null:
                    speechRandNode.SetSpeaker(character);
                    break;
            }
        }
    }
}



//==== File 17 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueSettingsData.cs ====
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

[CreateAssetMenu(fileName = "DialogueSettings", menuName = "Dialogue System/Settings Data")]
public class DialogueSettingsData : ScriptableObject
{

    public bool EnableHotkeyUndoRedo = false; // ��������� �� ���������
    public GeneralSettings General = new GeneralSettings();
    public UISettings UI = new UISettings();
    [System.Serializable]
    public class GeneralSettings
    {
        public string DefaultMessageDelay = "0.5";
        public bool AutoScrollEnabled = true;
        public bool EnableQuickNodeCreationOnDragDrop = true;
        public bool EnableHotkeyUndoRedo = true;
        public bool AutoSaveOnUnityClose = true;
        public bool enableAutoSaveLocation = true;
        public string autoSaveFolderPath = "";
        public bool EnableEntryNodeMovement = false;
    }
    [System.Serializable]
    public class UISettings
    {
        public bool UseCustomBackgroundColor = false;
        public Color CustomBackgroundColor = new Color(0.15f, 0.15f, 0.15f, 1f);
    }
    [System.Serializable]
    public class AudioSettings
    {
        public float MasterVolume = 1f;
        public bool MuteOnPause = true;
        public string AudioMixerPath = "Audio/Mixer";
    }

    // New field for favorite node types
    [SerializeField] private List<string> _favoriteNodeTypes = new List<string>();
    public List<string> FavoriteNodeTypes
    {
        get
        {
            // Initialize with defaults if empty
            if (_favoriteNodeTypes == null || _favoriteNodeTypes.Count == 0)
            {
                _favoriteNodeTypes = new List<string> {
                    "SpeechNodeText",
                    "OptionNodeText",
                    "IntConditionNode",
                    "EndNode"
                };
            }
            return _favoriteNodeTypes;
        }
        set { _favoriteNodeTypes = value; }
    }

    private void OnEnable()
    {
        // Ensure default values are set when the object is enabled
        if (_favoriteNodeTypes == null)
        {
            _favoriteNodeTypes = new List<string>();
        }

        if (_favoriteNodeTypes.Count == 0)
        {
            _favoriteNodeTypes.AddRange(new List<string> {
                "SpeechNodeText",
                "OptionNodeText",
                "IntConditionNode",
                "EndNode"
            });
        }

        ValidateAutoSaveFolder();
    }

    /// <summary>
    /// ��������� ���� � ����� ��������������
    /// </summary>
    public void ValidateAutoSaveFolder()
    {
        if (General.enableAutoSaveLocation && !string.IsNullOrEmpty(General.autoSaveFolderPath))
        {
            if (!IsValidSavePath(General.autoSaveFolderPath))
            {
                General.enableAutoSaveLocation = false;
                Debug.LogWarning($"Auto-save folder is not accessible: {General.autoSaveFolderPath}");
                EditorUtility.SetDirty(this);
                AssetDatabase.SaveAssets();
            }
        }
    }

    /// <summary>
    /// ���������, ���������� �� ����� � ��������� �� ��� ������ Assets
    /// </summary>
    public bool IsValidSavePath(string relativePath)
    {
        if (string.IsNullOrEmpty(relativePath))
            return false;

        string fullPath = GetFullPath(relativePath);
        return !string.IsNullOrEmpty(fullPath) && System.IO.Directory.Exists(fullPath);
    }

    /// <summary>
    /// ���������� ������ ���� � ����� �� �������������� ����
    /// </summary>
    public string GetFullPath(string relativePath = null)
    {
        if (relativePath == null)
            relativePath = General.autoSaveFolderPath;

        if (string.IsNullOrEmpty(relativePath))
            return null;

        // ���������, ��� ���� ��������� ������ Assets
        if (relativePath.Contains("..") || relativePath.StartsWith("/") || relativePath.StartsWith("\\"))
            return null;

        return System.IO.Path.Combine(Application.dataPath, relativePath);
    }

    /// <summary>
    /// ������������� ���� � ����� �������������� � ����������
    /// </summary>
    public void SetAutoSaveFolderPath(string fullPath)
    {
        // ���������, ��� ���� ��������� ������ Assets
        if (!string.IsNullOrEmpty(fullPath) && fullPath.StartsWith(Application.dataPath))
        {
            // ����������� � ������������� ���� �� Assets
            string relativePath = fullPath.Substring(Application.dataPath.Length + 1);
            // ����������� ���� (�������� �������� �����)
            relativePath = relativePath.Replace("\\", "/");

            // ���������, ��� ����� ����������
            if (System.IO.Directory.Exists(fullPath))
            {
                General.autoSaveFolderPath = relativePath;
                General.enableAutoSaveLocation = true;
                return;
            }
        }

        // ���� ���� ��������������
        General.enableAutoSaveLocation = false;
        Debug.LogWarning("Invalid auto-save folder path. Must be inside Assets folder.");
    }
}

//==== File 18 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueSettingsWindow.cs ====
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
public class DialogueSettingsWindow : EditorWindow
{
    private DialogueSettingsData _settings;
    private VisualElement _root;
    private VisualElement _rightPanel;
    private string[] _categories = { "General", "UI", "File Management", "Audio" };
    private int _selectedCategoryIndex = 0;
    [MenuItem("Dialog System/Settings")]
    public static void ShowWindow()
    {
        var window = GetWindow<DialogueSettingsWindow>("Dialogue Settings");
        window.minSize = new Vector2(600, 400);
    }
    private void OnEnable()
    {
        LoadOrCreateSettings();
        CreateGUI();
    }
    private void LoadOrCreateSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length > 0)
        {
            string path = AssetDatabase.GUIDToAssetPath(guids[0]);
            _settings = AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
        }
        else
        {
            _settings = ScriptableObject.CreateInstance<DialogueSettingsData>();
            string path = "Assets/Resources/DialogueSettings.asset";
            AssetDatabase.CreateAsset(_settings, path);
            AssetDatabase.SaveAssets();
        }
    }
    private void CreateGUI()
    {
        _root = rootVisualElement;
        _root.Clear();
        // Toolbar with Save button
        var toolbar = new Toolbar();
        var saveButton = new Button(SaveSettings) { text = "Save" };
        toolbar.Add(saveButton);
        _root.Add(toolbar);
        // Two-panel layout
        var splitView = new TwoPaneSplitView(0, 200, TwoPaneSplitViewOrientation.Horizontal);
        _root.Add(splitView);
        // Left panel: category list
        var leftPanel = new ScrollView();
        for (int i = 0; i < _categories.Length; i++)
        {
            int index = i;
            var button = new Button(() => SelectCategory(index)) { text = _categories[i] };
            if (i == _selectedCategoryIndex) button.AddToClassList("selected");
            leftPanel.Add(button);
        }
        splitView.Add(leftPanel);
        // Right panel: settings editor
        _rightPanel = new VisualElement();
        splitView.Add(_rightPanel);
        RefreshRightPanel();
    }
    private void SelectCategory(int index)
    {
        _selectedCategoryIndex = index;
        CreateGUI(); // Rebuild to update selection highlight
    }
    private void RefreshRightPanel()
    {
        _rightPanel.Clear();
        switch (_selectedCategoryIndex)
        {
            case 0:
                DrawGeneralSettings();
                break;
            case 1:
                DrawUISettings();
                break;
            case 2:
                DrawFileManagementSettings();
                break;
        }
    }

    private void DrawFileManagementSettings()
    {
        _rightPanel.Add(new Label("File Management")
        {
            style = {
            fontSize = 14,
            unityFontStyleAndWeight = FontStyle.Bold
        }
        });

        // Контейнер для элементов с отступами
        var container = new VisualElement();
        container.style.marginTop = 10;
        container.style.marginBottom = 10;
        container.style.marginLeft = 5;
        container.style.marginRight = 5;

        // Bool-переключатель
        var enableToggle = new Toggle("Enable Auto-save Location")
        {
            value = _settings.General.enableAutoSaveLocation
        };
        enableToggle.RegisterValueChangedCallback(evt =>
        {
            _settings.General.enableAutoSaveLocation = evt.newValue;
            EditorUtility.SetDirty(_settings);
        });
        container.Add(enableToggle);

        // Контейнер для поля пути и кнопки
        var pathContainer = new VisualElement
        {
            style = {
            flexDirection = FlexDirection.Row,
            alignItems = Align.Center,
            marginTop = 5
        }
        };

        // Поле для отображения пути
        string displayPath = !string.IsNullOrEmpty(_settings.General.autoSaveFolderPath)
            ? _settings.General.autoSaveFolderPath
            : "Not set";

        var pathField = new TextField
        {
            value = displayPath,
            isReadOnly = true
        };
        pathField.style.flexGrow = 1;

        // Кнопка выбора папки с иконкой
        var browseButton = new Button(SelectAutoSaveFolder) { text = "📁" };
        browseButton.style.width = 30;
        browseButton.style.marginLeft = 5;

        pathContainer.Add(pathField);
        pathContainer.Add(browseButton);

        container.Add(pathContainer);

        // Отключаем элементы, если переключатель выключен
        pathContainer.SetEnabled(_settings.General.enableAutoSaveLocation);
        enableToggle.RegisterValueChangedCallback(evt =>
        {
            pathContainer.SetEnabled(evt.newValue);
            EditorUtility.SetDirty(_settings);
        });

        _rightPanel.Add(container);
    }

    private void SelectAutoSaveFolder()
    {
        string initialPath = Application.dataPath;

        // Если уже задан путь - используем его как начальный
        if (!string.IsNullOrEmpty(_settings.General.autoSaveFolderPath))
        {
            string fullPath = _settings.GetFullPath();
            if (!string.IsNullOrEmpty(fullPath) && System.IO.Directory.Exists(fullPath))
                initialPath = fullPath;
        }

        string selectedPath = EditorUtility.OpenFolderPanel(
            "Select Auto-save Folder",
            initialPath,
            ""
        );

        if (string.IsNullOrEmpty(selectedPath))
            return;

        // Проверяем, что путь находится внутри папки Assets
        if (selectedPath.StartsWith(Application.dataPath))
        {
            _settings.SetAutoSaveFolderPath(selectedPath);
            EditorUtility.SetDirty(_settings);
        }
        else
        {
            EditorUtility.DisplayDialog(
                "Invalid Path",
                "Please select a folder inside the Assets directory.",
                "OK"
            );
            _settings.General.enableAutoSaveLocation = false;
            EditorUtility.SetDirty(_settings);
        }
    }

    private void DrawGeneralSettings()
    {
        _rightPanel.Add(new Label("General Settings") { style = { fontSize = 14, unityFontStyleAndWeight = FontStyle.Bold } });
        var delayField = new TextField("Default Message Delay") { value = _settings.General.DefaultMessageDelay };
        delayField.RegisterValueChangedCallback(evt => _settings.General.DefaultMessageDelay = evt.newValue);
        _rightPanel.Add(delayField);
        var autoScrollToggle = new Toggle("Auto Scroll Enabled") { value = _settings.General.AutoScrollEnabled };
        autoScrollToggle.RegisterValueChangedCallback(evt => _settings.General.AutoScrollEnabled = evt.newValue);
        _rightPanel.Add(autoScrollToggle);
        var quickCreateToggle = new Toggle("Enable Quick Node Creation on Drag Drop") { value = _settings.General.EnableQuickNodeCreationOnDragDrop };
        quickCreateToggle.RegisterValueChangedCallback(evt => _settings.General.EnableQuickNodeCreationOnDragDrop = evt.newValue);
        _rightPanel.Add(quickCreateToggle);
        //    
        var hotkeyToggle = new Toggle("Enable Undo/Redo Hotkeys (Ctrl+Z/Y)") { value = _settings.General.EnableHotkeyUndoRedo };
        hotkeyToggle.RegisterValueChangedCallback(evt => _settings.General.EnableHotkeyUndoRedo = evt.newValue);
        _rightPanel.Add(hotkeyToggle);

        // AUTO-SAVE: Добавляем toggle для новой настройки
        var autoSaveToggle = new Toggle("Auto-save on Unity close") { value = _settings.General.AutoSaveOnUnityClose };
        autoSaveToggle.RegisterValueChangedCallback(evt => _settings.General.AutoSaveOnUnityClose = evt.newValue);
        _rightPanel.Add(autoSaveToggle);

        var entryNodeMovementToggle = new Toggle("Enable Entry Node Movement")
        {
            value = _settings.General.EnableEntryNodeMovement
        };
        entryNodeMovementToggle.RegisterValueChangedCallback(evt => _settings.General.EnableEntryNodeMovement = evt.newValue);
        _rightPanel.Add(entryNodeMovementToggle);
    }
    private void DrawUISettings()
    {
        _rightPanel.Add(new Label("UI Settings") { style = { fontSize = 14, unityFontStyleAndWeight = FontStyle.Bold } });
        var useCustomBgToggle = new Toggle("Use Custom Background Color") { value = _settings.UI.UseCustomBackgroundColor };
        useCustomBgToggle.RegisterValueChangedCallback(evt => _settings.UI.UseCustomBackgroundColor = evt.newValue);
        _rightPanel.Add(useCustomBgToggle);
        var customBgField = new ColorField("Custom Background Color") { value = _settings.UI.CustomBackgroundColor };
        customBgField.RegisterValueChangedCallback(evt => _settings.UI.CustomBackgroundColor = evt.newValue);
        customBgField.SetEnabled(_settings.UI.UseCustomBackgroundColor);
        useCustomBgToggle.RegisterValueChangedCallback(evt => customBgField.SetEnabled(evt.newValue));
        _rightPanel.Add(customBgField);
    }
    private void SaveSettings()
    {
        EditorUtility.SetDirty(_settings);
        AssetDatabase.SaveAssets();
        //      
        DialogueGraphView.UpdateGraphBackgroundForAllInstances();
    }
}

//==== File 19 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DuplicateNodesCommand.cs ====
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

[System.Serializable]
public class SerializedConnection
{
    public string sourceGuid;
    public string targetGuid;
    public string portName;
}

public class DuplicateNodesCommand : GraphCommand
{
    private List<BaseNode> duplicatedNodes = new List<BaseNode>();
    private List<Edge> createdEdges = new List<Edge>();
    private Vector2 pastePosition;
    private Dictionary<string, string> guidMap = new Dictionary<string, string>();
    private List<BaseNode> originalNodes = new List<BaseNode>();
    private List<SerializedConnection> internalConnections = new List<SerializedConnection>();

    public DuplicateNodesCommand(DialogueGraphView graphView, List<BaseNode> nodesToDuplicate, Vector2 pastePosition)
        : base(graphView)
    {
        this.pastePosition = pastePosition;
        this.originalNodes = nodesToDuplicate;

        // �������� ���������� ����� ����� ����������� ������
        foreach (var edge in graphView.edges.ToList())
        {
            var outputNode = edge.output?.node as BaseNode;
            var inputNode = edge.input?.node as BaseNode;

            if (outputNode != null && inputNode != null &&
                nodesToDuplicate.Contains(outputNode) && nodesToDuplicate.Contains(inputNode))
            {
                internalConnections.Add(new SerializedConnection
                {
                    sourceGuid = outputNode.GUID,
                    targetGuid = inputNode.GUID,
                    portName = edge.output.portName
                });
            }
        }
    }

    public override void Execute()
    {
        // ��������� ����� ��������� ��� ����������� ����������������
        Vector2 selectionCenter = Vector2.zero;
        if (originalNodes.Count > 0)
        {
            foreach (var node in originalNodes)
            {
                selectionCenter += node.GetPosition().position;
            }
            selectionCenter /= originalNodes.Count;
        }

        // ���������� ����� GUID ��� �����
        foreach (var node in originalNodes)
        {
            guidMap[node.GUID] = Guid.NewGuid().ToString();
        }

        // ������� ����� �����
        foreach (var originalNode in originalNodes)
        {
            // ���������� EntryPoint ���� (������������ ���������)
            if (originalNode.EntryPoint) continue;

            // ������� ����� ���� ���� �� ����
            Type nodeType = originalNode.GetType();
            Vector2 nodePosition = originalNode.GetPosition().position;
            Vector2 offset = nodePosition - selectionCenter;
            Vector2 newNodePosition = pastePosition + offset;

            var newNode = NodeFactory.CreateNode(nodeType, newNodePosition);
            if (newNode == null) continue;

            // ����������� ����� GUID
            newNode.GUID = guidMap[originalNode.GUID];

            // �������� ������ ���� ����� ������������/��������������
            string nodeData = originalNode.SerializeNodeData();
            if (!string.IsNullOrEmpty(nodeData))
            {
                newNode.DeserializeNodeData(nodeData);
            }

            // ���������� ���� EntryPoint, ���� �� ����������
            if (newNode.EntryPoint)
            {
                newNode.EntryPoint = false;
                // ��������������� ����������� ��� �������� � �����������
                newNode.capabilities |= Capabilities.Deletable;
                newNode.capabilities |= Capabilities.Movable;
            }

            graphView.AddElement(newNode);
            duplicatedNodes.Add(newNode);
        }

        // ������� ����� ����� �����������
        foreach (var connection in internalConnections)
        {
            if (guidMap.TryGetValue(connection.sourceGuid, out string newSourceGuid) &&
                guidMap.TryGetValue(connection.targetGuid, out string newTargetGuid))
            {
                var sourceNode = duplicatedNodes.FirstOrDefault(n => n.GUID == newSourceGuid);
                var targetNode = duplicatedNodes.FirstOrDefault(n => n.GUID == newTargetGuid);

                if (sourceNode != null && targetNode != null)
                {
                    Port outputPort = null;
                    Port inputPort = null;

                    // ���� output ���� �� �����
                    foreach (Port port in sourceNode.outputContainer.Children())
                    {
                        if (port is Port portElement && portElement.portName == connection.portName)
                        {
                            outputPort = portElement;
                            break;
                        }
                    }

                    // ���� input ����
                    if (targetNode.inputContainer.childCount > 0)
                    {
                        inputPort = targetNode.inputContainer[0] as Port;
                    }

                    if (outputPort != null && inputPort != null)
                    {
                        var edge = new Edge { output = outputPort, input = inputPort };
                        outputPort.Connect(edge);
                        inputPort.Connect(edge);
                        graphView.Add(edge);
                        createdEdges.Add(edge);
                    }
                }
            }
        }

        // �������� ����� ����
        graphView.ClearSelection();
        foreach (var node in duplicatedNodes)
        {
            graphView.AddToSelection(node);
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }

    public override void Undo()
    {
        // ������� ��������� �����
        foreach (var edge in createdEdges.ToList())
        {
            if (edge != null && edge.parent != null)
            {
                graphView.RemoveElement(edge);
            }
        }

        // ������� ������������� ����
        foreach (var node in duplicatedNodes.ToList())
        {
            if (node != null && node.parent != null)
            {
                // ������� ��� �����, ��������� � ���� �����
                var edgesToRemove = graphView.edges
                    .Where(e => e.input.node == node || e.output.node == node)
                    .ToList();

                foreach (var edge in edgesToRemove)
                {
                    graphView.RemoveElement(edge);
                }

                graphView.RemoveElement(node);
            }
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }
}

//==== File 20 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\EventNodeHelperSO.cs ====
using UnityEngine.Events;
using UnityEngine;

public class EventNodeHelperSO : ScriptableObject { public UnityEvent Event = new UnityEvent(); }


//==== File 21 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\MarkdownToTMP.cs ====
// Assets/Scripts/Editor/MarkdownToTMP.cs
using System.Text.RegularExpressions;
using System;

public static class MarkdownToTMP
{
    public static string Convert(string markdown)
    {
        if (string.IsNullOrEmpty(markdown))
            return markdown;

        string result = markdown;

        // --- �������������� �����
        result = Regex.Replace(result, @"^\s*---\s*$", "<sprite name=\"Divider\">", RegexOptions.Multiline);

        // --- ���������
        result = Regex.Replace(result, @"^######\s+(.*)$", "<size=90%><b>$1</b></size>", RegexOptions.Multiline);
        result = Regex.Replace(result, @"^#####\s+(.*)$", "<size=100%><b>$1</b></size>", RegexOptions.Multiline);
        result = Regex.Replace(result, @"^####\s+(.*)$", "<size=105%><b>$1</b></size>", RegexOptions.Multiline);
        result = Regex.Replace(result, @"^###\s+(.*)$", "<size=110%><b>$1</b></size>", RegexOptions.Multiline);
        result = Regex.Replace(result, @"^##\s+(.*)$", "<size=115%><b>$1</b></size>", RegexOptions.Multiline);
        result = Regex.Replace(result, @"^#\s+(.*)$", "<size=120%><b>$1</b></size>", RegexOptions.Multiline);

        // --- ������
        result = Regex.Replace(result, @"^\s*-\s+(.+)$", "� $1\n", RegexOptions.Multiline);
        result = Regex.Replace(result, @"^\s*\d+\.\s+(.+)$", "$0\n", RegexOptions.Multiline);

        // --- ������
        result = Regex.Replace(result, @"^\s*>\s+(.+)$", "<i><color=#888888>�$1�</color></i>", RegexOptions.Multiline);

        // --- ���� ����
        result = Regex.Replace(result, @"```([\s\S]*?)```", match =>
        {
            string code = match.Groups[1].Value;
            return $"<color=#ddd>{EscapeTMP(code)}</color>";
        }, RegexOptions.Multiline);

        // --- ������-���
        result = Regex.Replace(result, @"`([^`]+)`", "<color=#aaa>$1</color>");

        // --- ������
        result = Regex.Replace(result, @"\[([^\]]+)\]\(([^)]+)\)", "<link=\"$2\"><u>$1</u></link>");

        // --- �����������
        result = Regex.Replace(result, @"!\[([^\]]*)\]\(([^)]+)\)", "<sprite name=\"$1\">");

        // --- ����� � ������������ (3 �������)
        for (int i = 0; i < 3; i++)
        {
            result = Regex.Replace(result, @"\*\*([^*]+)\*\*", "<b>$1</b>");
            result = Regex.Replace(result, @"\*([^*]+)\*", "<i>$1</i>");
            result = Regex.Replace(result, @"~~([^~]+)~~", "<s>$1</s>");
            result = Regex.Replace(result, @"__([^_]+)__", "<u>$1</u>");
        }

        return result.TrimEnd('\n');
    }

    private static string EscapeTMP(string text)
    {
        return text?.Replace("<", "<").Replace(">", ">");
    }

}


//==== File 22 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\PasteNodesCommand.cs ====
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

[System.Serializable]
public class ClipboardData
{
    public List<SerializedNode> nodes = new List<SerializedNode>();
    public List<SerializedConnection> connections = new List<SerializedConnection>();
    public Vector2 center;
    public Vector2 size;
}

[System.Serializable]
public class SerializedNode
{
    public string type;
    public string guid;
    public Vector2 position;
    public string nodeData;
}

public class PasteNodesCommand : GraphCommand
{
    private List<BaseNode> pastedNodes = new List<BaseNode>();
    private List<Edge> createdEdges = new List<Edge>();
    private Vector2 pastePosition;
    private DialogueGraphView.ClipboardData clipboardData;
    private Dictionary<string, string> guidMap = new Dictionary<string, string>();

    public PasteNodesCommand(DialogueGraphView graphView, DialogueGraphView.ClipboardData clipboardData, Vector2 pastePosition)
        : base(graphView)
    {
        this.clipboardData = clipboardData;
        this.pastePosition = pastePosition;
    }

    public override void Execute()
    {
        // �������� �����
        foreach (var serializedNode in clipboardData.nodes)
        {
            // ��������� ������ GUID
            string newGuid = Guid.NewGuid().ToString();
            guidMap[serializedNode.guid] = newGuid;

            // ����� ���� ����
            Type nodeType = Type.GetType($"DialogueSystem.{serializedNode.type}");
            if (nodeType == null)
            {
                // ������� ��� namespace
                nodeType = Type.GetType(serializedNode.type);
                if (nodeType == null)
                {
                    Debug.LogWarning($"Unknown node type: {serializedNode.type}");
                    continue;
                }
            }

            // �������� ����
            Vector2 nodePosition = new Vector2(
                pastePosition.x + (serializedNode.position.x - clipboardData.center.x),
                pastePosition.y + (serializedNode.position.y - clipboardData.center.y)
            );

            var newNode = NodeFactory.CreateNode(nodeType, nodePosition);
            if (newNode == null) continue;

            newNode.GUID = newGuid;
            newNode.DeserializeNodeData(serializedNode.nodeData);

            graphView.AddElement(newNode);
            pastedNodes.Add(newNode);
        }

        // �������� ������
        foreach (var connection in clipboardData.connections)
        {
            if (guidMap.TryGetValue(connection.sourceGuid, out string newSourceGuid) &&
                guidMap.TryGetValue(connection.targetGuid, out string newTargetGuid))
            {
                var sourceNode = pastedNodes.FirstOrDefault(n => n.GUID == newSourceGuid);
                var targetNode = pastedNodes.FirstOrDefault(n => n.GUID == newTargetGuid);

                if (sourceNode != null && targetNode != null)
                {
                    Port outputPort = null;
                    Port inputPort = null;

                    // ����� output ����� �� �����
                    foreach (Port port in sourceNode.outputContainer.Children())
                    {
                        if (port is Port portElement && portElement.portName == connection.portName)
                        {
                            outputPort = portElement;
                            break;
                        }
                    }

                    // ����� ������� input �����
                    if (targetNode.inputContainer.childCount > 0)
                    {
                        inputPort = targetNode.inputContainer[0] as Port;
                    }

                    if (outputPort != null && inputPort != null)
                    {
                        var edge = new Edge { output = outputPort, input = inputPort };
                        outputPort.Connect(edge);
                        inputPort.Connect(edge);
                        graphView.Add(edge);
                        createdEdges.Add(edge);
                    }
                }
            }
        }

        // ��������� ����������� �����
        graphView.ClearSelection();
        foreach (var node in pastedNodes)
        {
            graphView.AddToSelection(node);
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }

    public override void Undo()
    {
        // �������� ������
        foreach (var edge in createdEdges.ToList())
        {
            if (edge != null && edge.parent != null)
            {
                graphView.RemoveElement(edge);
            }
        }

        // �������� �����
        foreach (var node in pastedNodes.ToList())
        {
            if (node != null && node.parent != null)
            {
                // �������� ���� ������, ��������� � ���� �����
                var edgesToRemove = graphView.edges
                    .Where(e => e.input.node == node || e.output.node == node)
                    .ToList();

                foreach (var edge in edgesToRemove)
                {
                    graphView.RemoveElement(edge);
                }

                graphView.RemoveElement(node);
            }
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }
}

//==== File 23 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\TextEditorModalWindow.cs ====
// Assets/Scripts/Editor/TextEditorModalWindow.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor;
using UnityEditor.UIElements;
using System;
using System.Collections.Generic;

public class TextEditorModalWindow : VisualElement
{
    private IMGUIContainer _imguiContainer;
    private string _text;
    private int _selectionStart;
    private int _selectionEnd;
    private Label _guidLabel;
    private string _nodeGuid;
    private Action<string> _onTextChanged;

    private DialogueGraphView _graphView;

    // === Undo/Redo система ===
    private readonly int _maxHistorySteps = 50;
    private readonly List<string> _undoStack = new List<string>();
    private readonly List<string> _redoStack = new List<string>();
    private bool _isUndoRedoOperation = false;

    public TextEditorModalWindow(DialogueGraphView graphView, string initialText, string nodeGuid, Action<string> onTextChanged)
    {
        _graphView = graphView;
        _text = initialText ?? "";
        _nodeGuid = nodeGuid;
        _onTextChanged = onTextChanged;

        _text = initialText ?? "";
        _nodeGuid = nodeGuid;
        _onTextChanged = onTextChanged;
        style.flexDirection = FlexDirection.Column;
        style.backgroundColor = new StyleColor(new Color(0.15f, 0.15f, 0.15f));
        style.borderTopWidth = style.borderBottomWidth = style.borderLeftWidth = style.borderRightWidth = 1;
        style.borderTopColor = style.borderBottomColor = style.borderLeftColor = style.borderRightColor = new StyleColor(new Color(0.3f, 0.3f, 0.3f));
        style.paddingTop = style.paddingBottom = 8;
        style.paddingLeft = style.paddingRight = 8;
        style.minWidth = 400;
        style.maxWidth = 700;
        style.minHeight = 300;
        style.maxHeight = 600;

        // Заголовок окна
        var header = new VisualElement { style = { flexDirection = FlexDirection.Row, justifyContent = Justify.SpaceBetween, alignItems = Align.Center, marginBottom = 5 } };
        var title = new Label("Edit Text") { style = { fontSize = 12, unityFontStyleAndWeight = FontStyle.Bold } };
        var closeButton = new Button(() => Close()) { text = "×" };
        closeButton.style.width = 24;
        closeButton.style.height = 20;
        closeButton.style.marginLeft = 10;
        header.Add(title);
        header.Add(closeButton);
        Add(header);

        // === Панель форматирования ===
        var formatHeader = new Label("Formatting Tools")
        {
            style =
            {
                fontSize = 10,
                color = Color.gray,
                alignSelf = Align.FlexStart,
                marginBottom = 4
            }
        };
        Add(formatHeader);

        var formattingGroup = new VisualElement
        {
            style =
            {
                paddingTop = 8,
                paddingBottom = 8,
                paddingLeft = 8,
                paddingRight = 8,
                marginBottom = 8,
                flexWrap = Wrap.Wrap,
                flexDirection = FlexDirection.Row,
                alignItems = Align.FlexStart,
                justifyContent = Justify.FlexStart,
                minHeight = 36
            }
        };
        formattingGroup.style.flexGrow = 0;

        AddButton(formattingGroup, "B", "<b>", "</b>", "жирный текст");
        AddButton(formattingGroup, "I", "<i>", "</i>", "курсив");
        AddButton(formattingGroup, "S", "<s>", "</s>", "зачёркнутый");
        AddButton(formattingGroup, "U", "<u>", "</u>", "подчёркнутый");

        var btnColor = new Button(OpenColorPicker) { text = "Цвет" };
        var btnSize = new Button(OpenSizePicker) { text = "Размер" };
        var btnSprite = new Button(OpenSpritePicker) { text = "Спрайт" };
        var btnLink = new Button(OpenLinkPicker) { text = "Ссылка" };
        var btnAlign = new Button(OpenAlignPicker) { text = "Выравн." };
        var btnGradient = new Button(() => WrapSelection("<gradient>", "</gradient>", "градиент")) { text = "Град." };
        var btnOutline = new Button(() => WrapSelection("<outline>", "</outline>", "обводка")) { text = "Outline" };
        var btnSoftShadow = new Button(() => WrapSelection("<soft-shadow>", "</soft-shadow>", "тень")) { text = "Shadow" };

        var advancedButtons = new[] { btnColor, btnSize, btnSprite, btnLink, btnAlign, btnGradient, btnOutline, btnSoftShadow };
        foreach (var btn in advancedButtons)
        {
            btn.style.marginRight = 4;
            btn.style.marginBottom = 4;
            btn.style.height = 24;
            formattingGroup.Add(btn);
        }
        Add(formattingGroup);

        // --- Кнопки конвертации (отдельно) ---
        var convertToolbar = new VisualElement { style = { flexDirection = FlexDirection.Row, justifyContent = Justify.FlexEnd } };
        var btnToTMP = new Button(ConvertToTMP) { text = "→ TMP" };
        btnToTMP.style.backgroundColor = new StyleColor(new Color(0.2f, 0.4f, 0.6f));
        btnToTMP.style.color = Color.white;
        btnToTMP.style.marginLeft = 4;
        var btnToMD = new Button(ConvertToMarkdown) { text = "← MD" };
        btnToMD.style.backgroundColor = new StyleColor(new Color(0.4f, 0.2f, 0.6f));
        btnToMD.style.color = Color.white;
        btnToMD.style.marginLeft = 4;
        convertToolbar.Add(btnToTMP);
        convertToolbar.Add(btnToMD);
        Add(convertToolbar);

        // IMGUI Container для текстового поля
        _imguiContainer = new IMGUIContainer(() =>
        {
            EditorGUI.BeginChangeCheck();
            var rect = GUILayoutUtility.GetRect(0, 1000, 200, 600);
            var newText = EditorGUI.TextArea(rect, _text);

            // Получаем текущие настройки
            var settings = LoadDialogueSettings();
            bool hotkeysEnabled = settings == null || settings.General.EnableHotkeyUndoRedo;

            // Обработка горячих клавиш только если они разрешены
            if (hotkeysEnabled && Event.current.type == EventType.KeyDown && Event.current.control)
            {
                if (Event.current.keyCode == KeyCode.Z && !_isUndoRedoOperation)
                {
                    PerformUndo();
                    Event.current.Use();
                    GUI.changed = true;
                    return;
                }
                else if (Event.current.keyCode == KeyCode.Y && !_isUndoRedoOperation)
                {
                    PerformRedo();
                    Event.current.Use();
                    GUI.changed = true;
                    return;
                }
            }

            if (Event.current.type == EventType.Repaint)
            {
                var editor = (TextEditor)GUIUtility.GetStateObject(typeof(TextEditor), GUIUtility.keyboardControl);
                _selectionStart = editor.cursorIndex;
                _selectionEnd = editor.selectIndex;
            }

            if (EditorGUI.EndChangeCheck() && !_isUndoRedoOperation)
            {
                PushToUndoStack(_text);
                _text = newText;
                _onTextChanged?.Invoke(_text);
                _redoStack.Clear();
            }
        });
        _imguiContainer.style.flexGrow = 1;
        Add(_imguiContainer);

        // Кнопки Copy / Paste / Clear + Undo / Redo
        var buttonRow = new VisualElement { style = { flexDirection = FlexDirection.Row, justifyContent = Justify.SpaceBetween } };

        var undoBtn = new Button(PerformUndo) { text = "Undo" };
        var redoBtn = new Button(PerformRedo) { text = "Redo" };

        // Обновление состояния кнопок
        _imguiContainer.RegisterCallback<GeometryChangedEvent>(_ =>
        {
            undoBtn.SetEnabled(_undoStack.Count > 0);
            redoBtn.SetEnabled(_redoStack.Count > 0);
        });

        buttonRow.Add(undoBtn);
        buttonRow.Add(redoBtn);

        var copyBtn = new Button(() => EditorGUIUtility.systemCopyBuffer = _text) { text = "Copy" };
        var pasteBtn = new Button(() =>
        {
            if (!string.IsNullOrEmpty(EditorGUIUtility.systemCopyBuffer))
            {
                _text = EditorGUIUtility.systemCopyBuffer;
                _onTextChanged?.Invoke(_text);
                PushToUndoStack(_text);
                _redoStack.Clear();
            }
        })
        { text = "Paste" };
        var clearBtn = new Button(() =>
        {
            _text = "";
            _onTextChanged?.Invoke("");
            PushToUndoStack("");
            _redoStack.Clear();
        })
        { text = "Clear" };

        buttonRow.Add(copyBtn);
        buttonRow.Add(pasteBtn);
        buttonRow.Add(clearBtn);
        Add(buttonRow);

        // GUID узла
        _guidLabel = new Label($"Node GUID: {_nodeGuid}") { style = { fontSize = 9, color = Color.gray, marginTop = 8 } };
        Add(_guidLabel);
    }

    private DialogueSettingsData LoadDialogueSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length == 0)
            return null;

        string path = AssetDatabase.GUIDToAssetPath(guids[0]);
        return AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
    }

    private void AddButton(VisualElement parent, string label, string openTag, string closeTag, string placeholder)
    {
        var btn = new Button(() => WrapSelection(openTag, closeTag, placeholder)) { text = label };
        btn.style.marginRight = 4;
        btn.style.width = 40;
        btn.style.height = 24;
        parent.Add(btn);
    }

    private void WrapSelection(string openTag, string closeTag, string placeholder)
    {
        string selected = _text.Substring(Math.Min(_selectionStart, _selectionEnd), Math.Abs(_selectionEnd - _selectionStart));
        bool hadSelection = !string.IsNullOrEmpty(selected);
        if (!hadSelection)
        {
            selected = placeholder;
            _selectionStart = _selectionEnd;
        }
        string newText = _text.Substring(0, Math.Min(_selectionStart, _selectionEnd)) + openTag + selected + closeTag + _text.Substring(Math.Max(_selectionStart, _selectionEnd));
        _text = newText;
        int newCursorPos = Math.Min(_selectionStart, _selectionEnd) + openTag.Length;
        _selectionStart = newCursorPos;
        _selectionEnd = newCursorPos + selected.Length;
        _onTextChanged?.Invoke(_text);
        _imguiContainer.MarkDirtyRepaint();
    }

    private void OpenColorPicker()
    {
        string selected = GetSelectedOrPlaceholder("цветной текст");
        var modal = CreateModalBase();
        var colorField = new ColorField("Цвет") { value = Color.white };
        var confirm = new Button(() =>
        {
            string hex = ColorUtility.ToHtmlStringRGB(colorField.value);
            WrapSelection($"<color=#{hex}>", "</color>", selected);
            modal.RemoveFromHierarchy();
            _imguiContainer.MarkDirtyRepaint();
        })
        { text = "OK" };
        AddModalButtons(modal, confirm, () => modal.RemoveFromHierarchy());
        modal.Add(new Label("Выберите цвет:"));
        modal.Add(colorField);
        this.parent?.Add(modal);
    }

    private void OpenSizePicker()
    {
        var modal = CreateModalBase();
        var intField = new IntegerField("Значение (%)") { value = 100 };
        var confirm = new Button(() =>
        {
            WrapSelection($"<size={intField.value}%>", "</size>", "текст");
            modal.RemoveFromHierarchy();
            _imguiContainer.MarkDirtyRepaint();
        })
        { text = "OK" };
        AddModalButtons(modal, confirm, () => modal.RemoveFromHierarchy());
        modal.Add(new Label("Введите размер (%):"));
        modal.Add(intField);
        this.parent?.Add(modal);
    }

    private void OpenSpritePicker()
    {
        var modal = CreateModalBase();
        var textField = new TextField("Имя спрайта") { value = "my_sprite" };
        var confirm = new Button(() =>
        {
            if (!string.IsNullOrWhiteSpace(textField.value))
            {
                string tag = $"<sprite name=\"{textField.value.Trim()}\">";
                string newText = _text.Substring(0, _selectionStart) + tag + _text.Substring(_selectionEnd);
                _text = newText;
                _selectionStart = _selectionEnd = _selectionStart + tag.Length;
                _onTextChanged?.Invoke(_text);
            }
            modal.RemoveFromHierarchy();
            _imguiContainer.MarkDirtyRepaint();
        })
        { text = "OK" };
        AddModalButtons(modal, confirm, () => modal.RemoveFromHierarchy());
        modal.Add(new Label("Введите имя спрайта:"));
        modal.Add(textField);
        this.parent?.Add(modal);
    }

    private void OpenLinkPicker()
    {
        var modal = CreateModalBase();
        var textField = new TextField("URL") { value = "https://example.com" };
        var confirm = new Button(() =>
        {
            if (!string.IsNullOrWhiteSpace(textField.value))
            {
                string url = textField.value.Trim();
                string openTag = $"<link=\"{url}\"><u>";
                string closeTag = "</u></link>";
                WrapSelection(openTag, closeTag, "ссылка");
            }
            modal.RemoveFromHierarchy();
            _imguiContainer.MarkDirtyRepaint();
        })
        { text = "OK" };
        AddModalButtons(modal, confirm, () => modal.RemoveFromHierarchy());
        modal.Add(new Label("Введите URL ссылки:"));
        modal.Add(textField);
        this.parent?.Add(modal);
    }

    private void OpenAlignPicker()
    {
        var modal = CreateModalBase();
        var choices = new List<string> { "left", "center", "right", "justified" };
        var dropdown = new DropdownField(choices, 0);
        var confirm = new Button(() =>
        {
            string align = choices[dropdown.index];
            WrapSelection($"<align={align}>", "</align>", "выровненный текст");
            modal.RemoveFromHierarchy();
            _imguiContainer.MarkDirtyRepaint();
        })
        { text = "OK" };
        var cancel = new Button(() => modal.RemoveFromHierarchy()) { text = "Отмена" };
        var btnRow = new VisualElement { style = { flexDirection = FlexDirection.Row, marginTop = 5 } };
        btnRow.Add(confirm);
        btnRow.Add(cancel);
        modal.Add(new Label("Выберите выравнивание:"));
        modal.Add(dropdown);
        modal.Add(btnRow);
        this.parent?.Add(modal);
    }

    private string GetSelectedOrPlaceholder(string placeholder)
    {
        string selected = _text.Substring(Math.Min(_selectionStart, _selectionEnd), Math.Abs(_selectionEnd - _selectionStart));
        if (string.IsNullOrEmpty(selected))
        {
            selected = placeholder;
            _selectionStart = _selectionEnd;
        }
        return selected;
    }

    private VisualElement CreateModalBase()
    {
        var modal = new VisualElement();
        modal.style.backgroundColor = new StyleColor(new Color(0.2f, 0.2f, 0.2f));
        modal.style.paddingTop = 10;
        modal.style.paddingBottom = 10;
        modal.style.paddingLeft = 10;
        modal.style.paddingRight = 10;
        modal.style.marginTop = 10;
        modal.style.marginBottom = 10;
        modal.style.borderTopLeftRadius = 4;
        modal.style.borderTopRightRadius = 4;
        modal.style.borderBottomLeftRadius = 4;
        modal.style.borderBottomRightRadius = 4;
        return modal;
    }

    private void AddModalButtons(VisualElement modal, Button confirm, Action onCancel)
    {
        var btnRow = new VisualElement { style = { flexDirection = FlexDirection.Row, marginTop = 5 } };
        btnRow.Add(confirm);
        btnRow.Add(new Button(() => { onCancel(); }) { text = "Отмена" });
        modal.Add(btnRow);
    }

    public void UpdateText(string newText)
    {
        _text = newText ?? "";
        _imguiContainer.MarkDirtyRepaint();
    }

    public void Close()
    {
        _graphView?.ClearNodeHighlight();
        _undoStack.Clear();
        _redoStack.Clear();
        this.RemoveFromHierarchy();

        if (_graphView != null)
            _graphView._activeTextEditorWindow = null;

        if (_graphView != null)
            _graphView.Focus();
    }
    private void ConvertToTMP()
    {
        if (string.IsNullOrEmpty(_text)) return;
        string tmpText = MarkdownToTMP.Convert(_text);
        _text = tmpText;
        _onTextChanged?.Invoke(_text);
        _imguiContainer.MarkDirtyRepaint();
    }

    private void ConvertToMarkdown()
    {
        if (string.IsNullOrEmpty(_text)) return;
        string markdown = TMPToMarkdown.Convert(_text);
        _text = markdown;
        _onTextChanged?.Invoke(_text);
        _imguiContainer.MarkDirtyRepaint();
    }

    // === Undo/Redo вспомогательные методы ===

    private void PushToUndoStack(string state)
    {
        _undoStack.Add(state);
        if (_undoStack.Count > _maxHistorySteps)
            _undoStack.RemoveAt(0);
    }

    private void PerformUndo()
    {
        if (_undoStack.Count == 0) return;
        _isUndoRedoOperation = true;
        _redoStack.Add(_text);
        _text = _undoStack[_undoStack.Count - 1];
        _undoStack.RemoveAt(_undoStack.Count - 1);
        _onTextChanged?.Invoke(_text);
        _isUndoRedoOperation = false; // Сбрасываем флаг

        _imguiContainer.MarkDirtyRepaint();
        GUI.changed = true;
    }

    private void PerformRedo()
    {
        if (_redoStack.Count == 0) return;
        _isUndoRedoOperation = true;
        _undoStack.Add(_text);
        _text = _redoStack[_redoStack.Count - 1];
        _redoStack.RemoveAt(_redoStack.Count - 1);
        _onTextChanged?.Invoke(_text);
        _isUndoRedoOperation = false; // Сбрасываем флаг

        _imguiContainer.MarkDirtyRepaint();
        GUI.changed = true;
    }
}

//==== File 24 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\TMPToMarkdown.cs ====
// Assets/Scripts/Editor/TMPToMarkdown.cs
using System.Text.RegularExpressions;

public static class TMPToMarkdown
{
    public static string Convert(string tmp)
    {
        if (string.IsNullOrEmpty(tmp))
            return tmp;

        string result = tmp;

        // �������� �������������� (������ ������� �����)
        result = Regex.Replace(result, @"<b>([^<]+)</b>", "**$1**", RegexOptions.IgnoreCase);
        result = Regex.Replace(result, @"<i>([^<]+)</i>", "*$1*", RegexOptions.IgnoreCase);
        result = Regex.Replace(result, @"<s>([^<]+)</s>", "~~$1~~", RegexOptions.IgnoreCase);
        result = Regex.Replace(result, @"<u>([^<]+)</u>", "__$1__", RegexOptions.IgnoreCase);

        return result;
    }
}

//==== File 25 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\DialogueGraphView.cs ====
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;
using UnityEngine.UIElements;
using UnityEditor.UIElements;
using UnityEngine;
using System.Linq;
using UnityEditor;
using System;
using DialogueSystem;

/// <summary>
/// Граф для редактирования диалогов с новой логикой соединений
/// </summary>
public class DialogueGraphView : GraphView
{
    public readonly Vector2 DefaultNodeSize = new Vector2(250, 300);
    public Blackboard Blackboard;
    public List<ExposedProperty> ExposedProperties = new List<ExposedProperty>();
    public List<IntExposedProperty> IntExposedProperties = new List<IntExposedProperty>();
    public List<StringExposedProperty> StringExposedProperties = new List<StringExposedProperty>();
    private VisualElement[] BlackboardSections;
    private EditorWindow editorWindow;
    private NodeSearchWindow searchWindow;
    public bool _hasUnsavedChangesWithoutFile = false;
    public bool _unsavedChangesWarningShown = false;
    private VisualElement _highlightedNode;
    private StyleColor _originalNodeBgColor;
    private string _baseCharacterGuid;
    private VisualElement _customBackground;
    private GridBackground _gridBackground;
    public TextEditorModalWindow _activeTextEditorWindow;
    private Port _draggedOutputPort;
    private Vector2 _dragReleasePosition;
    public DialogueContainer containerCache { get; set; }
    public UndoManager undoManager;
    private bool isUndoRedoOperation = false;
    public string BaseCharacterGuid
    {
        get => _baseCharacterGuid;
        set
        {
            if (_baseCharacterGuid != value)
            {
                _baseCharacterGuid = value;
                OnBaseCharacterChanged();
            }
        }
    }

    public DialogueGraphView(EditorWindow editorWindow)
    {
        this.editorWindow = editorWindow;
        styleSheets.Add(Resources.Load<StyleSheet>("DialogueGraph"));
        SetupZoom(ContentZoomer.DefaultMinScale, ContentZoomer.DefaultMaxScale);
        this.AddManipulator(new ContentDragger());
        this.AddManipulator(new SelectionDragger());
        this.AddManipulator(new RectangleSelector());
        undoManager = new UndoManager(this);

        // Инициализация фонов
        _gridBackground = new GridBackground();
        _customBackground = new VisualElement();
        _customBackground.StretchToParentSize();

        // Показываем сетку по умолчанию
        Insert(0, _gridBackground);
        _gridBackground.StretchToParentSize();

        AddElement(NodeFactory.CreateEntryNode(new Vector2(100, 200)));
        AddSearchWindow();
        this.RegisterCallback<PointerDownEvent>(OnPortPointerDown, TrickleDown.TrickleDown);
        GenerateBlackBoard();
        this.RegisterCallback<KeyDownEvent>(OnKeyDown);
        RegisterCallback<KeyDownEvent>(OnGlobalKeyDown);

        // Добавляем обработчик изменения графа
        this.graphViewChanged += OnGraphViewChanged;

        EnsureGridIsVisible();
    }

    public void EnsureGridIsVisible()
    {
        // Проверяем, есть ли у нас настройки
        var settings = LoadDialogueSettings();
        if (settings == null) return;

        // Если используется пользовательский фон, но мы хотим видеть сетку
        if (settings.UI.UseCustomBackgroundColor)
        {
            // Добавляем класс для отображения сетки поверх фона
            _gridBackground.AddToClassList("grid-visible");

            // Важно: сетка должна быть над кастомным фоном, но под нодами
            if (_gridBackground.parent == null)
            {
                Insert(1, _gridBackground); // Вставляем после кастомного фона
                _gridBackground.StretchToParentSize();
            }
        }
    }

    private GraphViewChange OnGraphViewChanged(GraphViewChange change)
    {
        // Обработка добавленных элементов
        if (change.edgesToCreate != null)
        {
            var edgesToRemove = new List<Edge>();
            var edgesToAdd = new List<Edge>();

            foreach (var edge in change.edgesToCreate.ToList())
            {
                if (edge.input == null || edge.output == null)
                    continue;

                // Определяем правильное направление соединения
                Port trueOutput = null;
                Port trueInput = null;

                // Если соединение уже идет в правильном направлении (output -> input)
                if (edge.output.direction == Direction.Output && edge.input.direction == Direction.Input)
                {
                    trueOutput = edge.output;
                    trueInput = edge.input;
                }
                // Если соединение идет в обратном направлении (input -> output)
                else if (edge.output.direction == Direction.Input && edge.input.direction == Direction.Output)
                {
                    trueOutput = edge.input;
                    trueInput = edge.output;
                }
                // Если оба порта одного типа - не создаем соединение
                else
                {
                    edgesToRemove.Add(edge);
                    continue;
                }

                // Если направление изменилось, создаем новое соединение с правильными портами
                if (trueOutput != edge.output || trueInput != edge.input)
                {
                    edgesToRemove.Add(edge);
                    // Проверка на возможность соединения
                    if (IsConnectionAllowed(trueOutput, trueInput))
                    {
                        var newEdge = new Edge
                        {
                            output = trueOutput,
                            input = trueInput
                        };
                        trueOutput.Connect(newEdge);
                        trueInput.Connect(newEdge);
                        edgesToAdd.Add(newEdge);
                    }
                }
                else
                {
                    // Проверка на возможность соединения для исходного соединения
                    if (!IsConnectionAllowed(trueOutput, trueInput))
                    {
                        edgesToRemove.Add(edge);
                    }
                }
            }

            // Удаляем некорректные соединения
            foreach (var edge in edgesToRemove)
            {
                change.edgesToCreate.Remove(edge);
            }

            // Добавляем исправленные соединения
            if (edgesToAdd.Count > 0)
            {
                if (change.edgesToCreate == null)
                    change.edgesToCreate = new List<Edge>();
                change.edgesToCreate.AddRange(edgesToAdd);
            }

            // Обрабатываем конфликты для всех новых соединений
            foreach (var edge in change.edgesToCreate.ToList())
            {
                if (edge.output != null && edge.input != null)
                {
                    var startNode = edge.output.node as BaseNode;
                    var targetNode = edge.input.node as BaseNode;
                    if (startNode != null && targetNode != null)
                    {
                        HandleConflictingConnections(edge, startNode);
                    }
                }
            }
        }

        // Обработка удаленных элементов
        if (change.elementsToRemove != null)
        {
            foreach (var element in change.elementsToRemove.ToList())
            {
                if (element is Edge edge)
                {
                    // Удаляем соединение и помечаем изменения
                    if (edge.output != null && edge.input != null)
                    {
                        edge.output.Disconnect(edge);
                        edge.input.Disconnect(edge);
                        MarkUnsavedChangeWithoutFile();
                    }
                }
                else if (element is BaseNode node)
                {
                    // Автоматически удаляем все соединения, связанные с удаляемым узлом
                    var edgesToRemove = edges.ToList()
                        .Where(e => e.output?.node == node || e.input?.node == node)
                        .ToList();

                    foreach (var edgeA in edgesToRemove)
                    {
                        if (edgeA.output != null)
                            edgeA.output.Disconnect(edgeA);
                        if (edgeA.input != null)
                            edgeA.input.Disconnect(edgeA);
                        RemoveElement(edgeA);
                    }

                    // Защита от удаления EntryNode
                    if (node.EntryPoint)
                    {
                        change.elementsToRemove.Remove(element);
                        EditorUtility.DisplayDialog("Cannot Delete", "The entry point node cannot be deleted.", "OK");
                    }
                    else
                    {
                        MarkUnsavedChangeWithoutFile();
                    }
                }
            }
        }

        // Обработка перемещенных элементов
        if (change.movedElements != null)
        {
            foreach (var element in change.movedElements)
            {
                if (element is BaseNode node)
                {
                    MarkUnsavedChangeWithoutFile();
                }
            }
        }

        return change;
    }

    private bool CanEditNodeWithDoubleClick(BaseNode node)
    {
        return node is SpeechNodeText ||
               node is OptionNodeText ||
               node is DebugLogNode ||
               node is DebugWarningNode ||
               node is DebugErrorNode;
    }

    /// <summary>
    /// Проверяет, является ли узел Speech Node
    /// </summary>
    private bool IsSpeechNode(BaseNode node)
    {
        return node is SpeechNode ||
               node is SpeechNodeText ||
               node is SpeechNodeAudio ||
               node is SpeechNodeImage ||
               node is SpeechNodeRandText;
    }

    /// <summary>
    /// Проверяет, является ли узел Option Node
    /// </summary>
    private bool IsOptionNode(BaseNode node)
    {
        return node is OptionNode ||
               node is OptionNodeText ||
               node is OptionNodeAudio ||
               node is OptionNodeImage;
    }

    /// <summary>
    /// Проверяет, является ли узел обычным узлом (не Option)
    /// </summary>
    private bool IsRegularNode(BaseNode node)
    {
        return !IsOptionNode(node);
    }

    private void OnGlobalKeyDown(KeyDownEvent evt)
    {
        // Игнорируем горячие клавиши, когда открыто окно текстового редактора
        if (_activeTextEditorWindow != null)
            return;

        var settings = LoadDialogueSettings();
        bool hotkeysEnabled = settings != null && settings.General.EnableHotkeyUndoRedo;
    }

    public void DuplicateSelectedNodes()
    {
        var selectedNodes = selection.OfType<BaseNode>()
            .Where(node => !node.EntryPoint)
            .ToList();

        if (selectedNodes.Count == 0)
            return;

        Vector2 pastePosition = GetMousePositionInGraphSpace();
        var command = new DuplicateNodesCommand(this, selectedNodes, pastePosition);
        undoManager.ExecuteCommand(command);
    }

    private Vector2 GetMousePositionInGraphSpace()
    {
        var mousePosition = GUIUtility.GUIToScreenPoint(Event.current.mousePosition);
        var worldMousePosition = contentViewContainer.WorldToLocal(new Vector2(mousePosition.x, mousePosition.y));
        return worldMousePosition;
    }

    public void UpdateGraphBackgroundInternal()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        DialogueSettingsData settings = null;
        if (guids.Length > 0)
        {
            string path = AssetDatabase.GUIDToAssetPath(guids[0]);
            settings = AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
        }
        if (settings == null)
            return;

        bool useCustom = settings.UI.UseCustomBackgroundColor;
        Color customColor = settings.UI.CustomBackgroundColor;

        // Убираем текущий фон
        if (_gridBackground.parent != null)
            _gridBackground.RemoveFromHierarchy();
        if (_customBackground.parent != null)
            _customBackground.RemoveFromHierarchy();

        // Вставляем нужный
        if (useCustom)
        {
            _customBackground.style.backgroundColor = new StyleColor(customColor);
            Insert(0, _customBackground);
        }
        else
        {
            Insert(0, _gridBackground);
            _gridBackground.StretchToParentSize();
        }
    }

    public static void UpdateGraphBackgroundForAllInstances()
    {
        var graphWindows = Resources.FindObjectsOfTypeAll<DialogueGraph>();
        foreach (var window in graphWindows)
        {
            if (window.graphView != null)
                window.graphView.UpdateGraphBackgroundInternal();
        }
    }

    private void AddSearchWindow()
    {
        searchWindow = ScriptableObject.CreateInstance<NodeSearchWindow>();
        searchWindow.Init(editorWindow, this);
        nodeCreationRequest = context =>
            SearchWindow.Open(new SearchWindowContext(context.screenMousePosition), searchWindow);
    }

    private void OnKeyDown(KeyDownEvent evt)
    {
        if (evt.keyCode == KeyCode.Delete)
        {
            // Проверяем, есть ли в выделении EntryNode
            if (selection.OfType<BaseNode>().Any(node => node.EntryPoint))
            {
                EditorUtility.DisplayDialog("Cannot Delete", "The entry point node cannot be deleted.", "OK");
                evt.StopPropagation();
                return;
            }
            DeleteSelection();
            evt.StopPropagation();
        }
    }

    /// <summary>
    /// Определяет поведение WireNode на основе подключенных узлов
    /// </summary>
    private bool IsWireNodeBehavingAsOptionNode(WireNode wireNode)
    {
        // Проверяем исходящие соединения
        foreach (var edge in wireNode.outputContainer[0].Query<Edge>().ToList())
        {
            var targetNode = edge.input?.node as BaseNode;
            if (targetNode != null && IsOptionNode(targetNode))
                return true;
        }

        // Проверяем входящие соединения
        foreach (var edge in wireNode.inputContainer[0].Query<Edge>().ToList())
        {
            var sourceNode = edge.output?.node as BaseNode;
            if (sourceNode != null && IsOptionNode(sourceNode))
                return true;
        }

        return false;
    }

    /// <summary>
    /// Определяет, является ли узел "обычным" с точки зрения соединений
    /// (включая WireNode с обычным поведением)
    /// </summary>
    private bool IsRegularConnectionType(BaseNode node)
    {
        if (node is WireNode wireNode)
            return !IsWireNodeBehavingAsOptionNode(wireNode);

        return IsRegularNode(node);
    }

    /// <summary>
    /// Определяет, является ли узел "опциональным" с точки зрения соединений
    /// (включая WireNode с опциональным поведением)
    /// </summary>
    private bool IsOptionConnectionType(BaseNode node)
    {
        if (node is WireNode wireNode)
            return IsWireNodeBehavingAsOptionNode(wireNode);

        return IsOptionNode(node);
    }

    /// <summary>
    /// Проверяет, разрешено ли соединение между портами
    /// </summary>
    private bool IsConnectionAllowed(Port startPort, Port targetPort)
    {
        var startNode = startPort.node as BaseNode;
        var targetNode = targetPort.node as BaseNode;
        if (startNode == null || targetNode == null)
            return false;

        // Проверяем направление портов
        if (startPort.direction != Direction.Output || targetPort.direction != Direction.Input)
            return false;

        // Правило 1: Нельзя соединять узел сам с собой
        if (startNode == targetNode)
            return false;

        // Все остальные соединения разрешены - конфликты будут обработаны в HandleConflictingConnections
        return true;
    }

    /// <summary>
    /// Определяет совместимые порты для соединения
    /// </summary>
    public override List<Port> GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter)
    {
        var compatiblePorts = new List<Port>();

        // Определяем тип стартового порта
        var startNode = startPort.node as BaseNode;
        if (startNode == null)
            return compatiblePorts;

        ports.ForEach(port =>
        {
            if (port == null || startPort == null)
                return;

            var targetNode = port.node as BaseNode;
            if (targetNode == null)
                return;

            // Пропускаем порт того же узла
            if (startPort.node == port.node)
                return;

            // Определяем правильное направление для проверки
            Port checkOutput;
            Port checkInput;

            // Если стартовый порт - output, ищем совместимые input порты
            if (startPort.direction == Direction.Output)
            {
                checkOutput = startPort;
                checkInput = port;
            }
            // Если стартовый порт - input, ищем совместимые output порты
            else if (startPort.direction == Direction.Input)
            {
                checkOutput = port;
                checkInput = startPort;
            }
            // Если оба порта одного типа - несовместимы
            else
            {
                return;
            }

            // Проверяем направление целевого порта
            if (checkOutput.direction != Direction.Output || checkInput.direction != Direction.Input)
                return;

            // Проверяем, не является ли один из узлов EntryPoint (EntryNode)
            if (startNode.EntryPoint && targetNode.EntryPoint)
                return;

            // Для входных портов Option Nodes разрешаем множественные соединения
            if (checkInput.direction == Direction.Input && IsOptionNode(targetNode))
            {
                compatiblePorts.Add(port);
                return;
            }

            // Проверка ёмкости целевого порта
            if (checkInput.direction == Direction.Input &&
                checkInput.capacity == Port.Capacity.Single &&
                checkInput.connections.Count() >= 1)
            {
                // Разрешаем замену существующих соединений для Option Nodes
                if (!IsOptionNode(targetNode))
                    return;
            }

            // Проверка ограничений на соединения узлов
            if (IsConnectionAllowed(checkOutput, checkInput))
            {
                compatiblePorts.Add(port);
            }
        });

        return compatiblePorts;
    }

    /// <summary>
    /// Обрабатывает конфликтующие соединения при создании нового соединения
    /// </summary>
    private void HandleConflictingConnections(Edge newEdge, BaseNode startNode)
    {
        var outputPort = newEdge.output;
        var targetNode = newEdge.input.node as BaseNode;
        if (outputPort == null || targetNode == null)
            return;

        // Определяем тип нового соединения
        bool isNewConnectionOptionNode = IsOptionNode(targetNode);
        bool isNewConnectionRegularNode = !isNewConnectionOptionNode; // Любая нода, не являющаяся option

        // Получаем все существующие соединения от этого порта (кроме нового)
        var existingConnections = outputPort.connections
            .Where(e => e != newEdge)
            .ToList();

        // Случай 1: Новое соединение - обычный узел (любой, не option)
        if (isNewConnectionRegularNode)
        {
            // Удаляем все существующие соединения (включая Option)
            foreach (var edge in existingConnections.ToList())
            {
                DeleteConnection(edge);
            }
        }

        // Случай 2: Новое соединение - Option Node
        else if (isNewConnectionOptionNode)
        {
            // Проверяем, есть ли среди существующих соединений соединения с обычными узлами (не Option)
            var regularNodeConnections = existingConnections
                .Where(e => e.input != null &&
                           e.input.node != null &&
                           !IsOptionNode(e.input.node as BaseNode))
                .ToList();

            // Если есть соединения с обычными узлами, удаляем их все
            foreach (var edge in regularNodeConnections)
            {
                DeleteConnection(edge);
            }
        }

        // Случай 3: Wire Node меняет свое поведение
        else if (startNode is WireNode wireNode)
        {
            bool behavesAsOption = IsWireNodeBehavingAsOptionNode(wireNode);

            // Если Wire Node должен вести себя как обычный узел (только одно соединение)
            if (!behavesAsOption)
            {
                // Удаляем все существующие соединения кроме нового
                foreach (var edge in existingConnections.ToList())
                {
                    DeleteConnection(edge);
                }
            }
        }
    }

    /// <summary>
    /// Удаляет соединение и помечает изменения
    /// </summary>
    private void DeleteConnection(Edge edge)
    {
        if (edge == null || edge.parent == null)
            return;

        // Удаляем соединение
        edge.input?.Disconnect(edge);
        edge.output?.Disconnect(edge);
        RemoveElement(edge);
        MarkUnsavedChangeWithoutFile();
    }
    private void GenerateBlackBoard()
    {
        Blackboard = new Blackboard(this);
        Blackboard.title = "Exposed Properties";
        Blackboard.style.minWidth = 300;
        Blackboard.style.maxWidth = 400;
        Blackboard.style.minHeight = 200;
        Blackboard.style.maxHeight = 500;

        var scrollView = new ScrollView();
        scrollView.style.flexGrow = 1;
        scrollView.verticalScrollerVisibility = ScrollerVisibility.Auto;
        scrollView.horizontalScrollerVisibility = ScrollerVisibility.Hidden;

        var intSection = new BlackboardSection { title = "Int Properties (0)" };
        var stringSection = new BlackboardSection { title = "String Properties (0)" };

        scrollView.Add(intSection);
        scrollView.Add(stringSection);

        Blackboard.Add(scrollView);

        IntSection = intSection;
        StringSection = stringSection;

        Blackboard.addItemRequested = blackboard =>
        {
            var menu = new GenericMenu();
            menu.AddItem(new GUIContent("Add Int Property"), false, () =>
            {
                var newProperty = new IntExposedProperty();
                IntExposedProperties.Add(newProperty);
                AddIntPropertyToBlackBoard(newProperty);
                UpdateSectionTitles();
            });
            menu.AddItem(new GUIContent("Add String Property"), false, () =>
            {
                var newProperty = new StringExposedProperty();
                StringExposedProperties.Add(newProperty);
                AddStringPropertyToBlackBoard(newProperty);
                UpdateSectionTitles();
            });
            menu.ShowAsContext();
        };

        Blackboard.editTextRequested = (blackboard, element, newValue) =>
        {
            var oldPropertyName = ((BlackboardField)element).text;
            if (IntExposedProperties.Any(x => x.PropertyName == newValue) ||
                StringExposedProperties.Any(x => x.PropertyName == newValue))
            {
                EditorUtility.DisplayDialog("Error", "This property name already exists, please choose another one.", "OK");
                return;
            }

            var intPropertyIndex = IntExposedProperties.FindIndex(x => x.PropertyName == oldPropertyName);
            if (intPropertyIndex >= 0)
            {
                IntExposedProperties[intPropertyIndex].PropertyName = newValue;
                ((BlackboardField)element).text = newValue;
                RefreshAllPropertyNodes();
                return;
            }

            var stringPropertyIndex = StringExposedProperties.FindIndex(x => x.PropertyName == oldPropertyName);
            if (stringPropertyIndex >= 0)
            {
                StringExposedProperties[stringPropertyIndex].PropertyName = newValue;
                ((BlackboardField)element).text = newValue;
                RefreshAllPropertyNodes();
            }
        };

        var clearButton = new Button(ClearAllProperties)
        {
            text = "Clear All Properties"
        };
        clearButton.style.marginTop = 5;
        clearButton.style.marginLeft = 5;
        clearButton.style.marginRight = 5;
        clearButton.style.marginBottom = 5;
        Blackboard.Add(clearButton);

        Add(Blackboard);
        UpdateSectionTitles();
    }

    private BlackboardSection IntSection;
    private BlackboardSection StringSection;

    public void AddIntPropertyToBlackBoard(IntExposedProperty intProperty)
    {
        var container = new VisualElement();
        container.style.marginBottom = 5;
        var blackboardField = new BlackboardField
        {
            text = intProperty.PropertyName,
            typeText = "Int"
        };

        var nameField = new TextField("Name:") { value = intProperty.PropertyName };
        var minField = new IntegerField("Min:") { value = intProperty.MinValue };
        var maxField = new IntegerField("Max:") { value = intProperty.MaxValue };
        var valueField = new IntegerField("Value:") { value = intProperty.IntValue };

        nameField.RegisterValueChangedCallback(evt =>
        {
            intProperty.PropertyName = evt.newValue;
            blackboardField.text = evt.newValue;
            UpdateSectionTitles();
            RefreshAllPropertyNodes();
            MarkUnsavedChangeWithoutFile();
        });
        minField.RegisterValueChangedCallback(evt =>
        {
            intProperty.MinValue = evt.newValue;
            if (intProperty.IntValue < evt.newValue)
                valueField.value = evt.newValue;
            MarkUnsavedChangeWithoutFile();
        });
        maxField.RegisterValueChangedCallback(evt =>
        {
            intProperty.MaxValue = evt.newValue;
            if (intProperty.IntValue > evt.newValue)
                valueField.value = evt.newValue;
            MarkUnsavedChangeWithoutFile();
        });
        valueField.RegisterValueChangedCallback(evt =>
        {
            intProperty.IntValue = Mathf.Clamp(evt.newValue, intProperty.MinValue, intProperty.MaxValue);
            valueField.value = intProperty.IntValue;
            MarkUnsavedChangeWithoutFile();
        });

        container.Add(blackboardField);
        container.Add(nameField);
        container.Add(minField);
        container.Add(maxField);
        container.Add(valueField);

        IntSection.Add(container);

        blackboardField.AddManipulator(new ContextualMenuManipulator(evt =>
        {
            evt.menu.AppendAction("Delete", action =>
            {
                int usageCount = 0;
                var conditionNodes = nodes.ToList().OfType<IntConditionNode>();
                var modifyNodes = nodes.ToList().OfType<ModifyIntNode>();
                foreach (var node in conditionNodes)
                    if (node.SelectedProperty == intProperty.PropertyName) usageCount++;
                foreach (var node in modifyNodes)
                    if (node.SelectedProperty == intProperty.PropertyName) usageCount++;

                if (EditorUtility.DisplayDialog("Confirm Delete",
                    $"Property '{intProperty.PropertyName}' is used in {usageCount} nodes.\nDelete anyway?",
                    "Delete", "Cancel"))
                {
                    RemoveIntProperty(intProperty, container);
                }
            });
        }));
    }

    public void AddStringPropertyToBlackBoard(StringExposedProperty stringProperty)
    {
        var container = new VisualElement();
        container.style.marginBottom = 5;
        var blackboardField = new BlackboardField
        {
            text = stringProperty.PropertyName,
            typeText = "String"
        };

        var nameField = new TextField("Name:") { value = stringProperty.PropertyName };
        var valueField = new TextField("Value:") { value = stringProperty.StringValue };

        nameField.RegisterValueChangedCallback(evt =>
        {
            stringProperty.PropertyName = evt.newValue;
            blackboardField.text = evt.newValue;
            UpdateSectionTitles();
            RefreshAllPropertyNodes();
            MarkUnsavedChangeWithoutFile();
        });
        valueField.RegisterValueChangedCallback(evt =>
        {
            stringProperty.StringValue = evt.newValue;
            MarkUnsavedChangeWithoutFile();
        });

        container.Add(blackboardField);
        container.Add(nameField);
        container.Add(valueField);

        StringSection.Add(container);

        blackboardField.AddManipulator(new ContextualMenuManipulator(evt =>
        {
            evt.menu.AppendAction("Delete", action =>
            {
                int usageCount = 0;
                var conditionNodes = nodes.ToList().OfType<StringConditionNode>();
                foreach (var node in conditionNodes)
                    if (node.SelectedProperty == stringProperty.PropertyName) usageCount++;

                if (EditorUtility.DisplayDialog("Confirm Delete",
                    $"Property '{stringProperty.PropertyName}' is used in {usageCount} condition nodes.\nDelete anyway?",
                    "Delete", "Cancel"))
                {
                    RemoveStringProperty(stringProperty, container);
                }
            });
        }));
    }

    private void RemoveIntProperty(IntExposedProperty property, VisualElement container)
    {
        IntExposedProperties.Remove(property);

        var conditionNodes = nodes.ToList().OfType<IntConditionNode>();
        var modifyNodes = nodes.ToList().OfType<ModifyIntNode>();
        foreach (var node in conditionNodes)
        {
            if (node.SelectedProperty == property.PropertyName)
            {
                node.SelectedProperty = "";
                Debug.LogWarning($"Variable {property.PropertyName} was removed but was used in IntConditionNode {node.GUID}");
            }
        }
        foreach (var node in modifyNodes)
        {
            if (node.SelectedProperty == property.PropertyName)
            {
                node.SelectedProperty = "";
                Debug.LogWarning($"Variable {property.PropertyName} was removed but was used in ModifyIntNode {node.GUID}");
            }
        }

        RefreshAllPropertyNodes();
        IntSection.Remove(container);
        UpdateSectionTitles();
        MarkUnsavedChangeWithoutFile();
    }

    private void RemoveStringProperty(StringExposedProperty property, VisualElement container)
    {
        StringExposedProperties.Remove(property);

        var conditionNodes = nodes.ToList().OfType<StringConditionNode>();
        foreach (var node in conditionNodes)
        {
            if (node.SelectedProperty == property.PropertyName)
            {
                node.SelectedProperty = "";
                Debug.LogWarning($"Variable {property.PropertyName} was removed but was used in StringConditionNode {node.GUID}");
            }
        }

        RefreshAllPropertyNodes();
        StringSection.Remove(container);
        UpdateSectionTitles();
        MarkUnsavedChangeWithoutFile();
    }

    private void UpdateSectionTitles()
    {
        if (IntSection != null)
        {
            IntSection.title = $"Int Properties ({IntExposedProperties.Count})";
        }
        if (StringSection != null)
        {
            StringSection.title = $"String Properties ({StringExposedProperties.Count})";
        }
    }

    private void RefreshAllPropertyNodes()
    {
        var allPropertyNodes = nodes.ToList().OfType<IPropertyNode>();
        foreach (var node in allPropertyNodes)
        {
            node.RefreshPropertyDropdown();
        }
    }

    private void ClearAllProperties()
    {
        bool hasProperties = IntExposedProperties.Count > 0 || StringExposedProperties.Count > 0;
        if (!hasProperties)
        {
            return;
        }

        if (!EditorUtility.DisplayDialog("Clear All Properties",
            "Are you sure you want to remove all exposed properties?", "Yes", "No"))
        {
            return;
        }

        IntExposedProperties.Clear();
        StringExposedProperties.Clear();
        IntSection?.Clear();
        StringSection?.Clear();
        RefreshAllPropertyNodes();
        UpdateSectionTitles();
        Debug.Log("All exposed properties cleared successfully");
        MarkUnsavedChangeWithoutFile();
    }

    public void ClearBlackBoardAndExposedProperties()
    {
        ClearAllProperties();
    }

    private void DeleteSelection()
    {
        var selectionCopy = selection.ToList();
        foreach (var selectedElement in selectionCopy)
        {
            var command = new DeleteElementCommand(this, selectedElement);
            undoManager.ExecuteCommand(command);
        }
    }

    public void ClearUndoRedoStacks()
    {
        undoManager.ClearStacks();
    }

    private void OnBaseCharacterChanged()
    {
        Debug.Log($"Base character changed to: {BaseCharacterGuid}");
    }

    private void ClearGraph()
    {
        var nodesToRemove = this.nodes.ToList().Where(node => !(node is EntryNode)).ToList();
        foreach (var node in nodesToRemove)
        {
            var edgesToRemove = this.edges
                .Where(e => e.input.node == node || e.output.node == node)
                .ToList();
            foreach (var edge in edgesToRemove)
                RemoveElement(edge);
            RemoveElement(node);
        }

        ClearBlackBoardAndExposedProperties();
        BaseCharacterGuid = string.Empty;
    }

    public void MarkUnsavedChangeWithoutFile()
    {
        var assetField = this.parent?.parent?.Q<ObjectField>("Dialogue File");
        if (assetField?.value == null)
        {
            _hasUnsavedChangesWithoutFile = true;
            if (!_unsavedChangesWarningShown)
            {
                _unsavedChangesWarningShown = true;
                Debug.LogWarning("Диалог не был выбран");
            }
        }
        else
        {
            _hasUnsavedChangesWithoutFile = false;
            _unsavedChangesWarningShown = false;
        }
    }

    public void OpenTextEditor(string initialText, string nodeGuid, Action<string> onTextChanged)
    {
        _activeTextEditorWindow?.Close();
        _activeTextEditorWindow = null;
        ClearNodeHighlight();

        var targetNode = nodes.ToList().FirstOrDefault(n => n is BaseNode node && node.GUID == nodeGuid) as VisualElement;
        if (targetNode != null)
        {
            _originalNodeBgColor = targetNode.style.backgroundColor;
            targetNode.style.backgroundColor = new StyleColor(new Color(0.3f, 0.6f, 1f, 0.2f));
            _highlightedNode = targetNode;
        }

        _activeTextEditorWindow = new TextEditorModalWindow(this, initialText, nodeGuid, onTextChanged);
        _activeTextEditorWindow.style.position = Position.Absolute;
        _activeTextEditorWindow.style.top = 30;
        _activeTextEditorWindow.style.right = 0;
        Add(_activeTextEditorWindow);
        ScrollToNode(nodeGuid);
    }

    public void ScrollToNode(string guid)
    {
        var targetNode = nodes.ToList().FirstOrDefault(n => n is BaseNode node && node.GUID == guid);
        if (targetNode == null) return;
        var nodeRect = targetNode.GetPosition();
        var center = nodeRect.center;

        float viewWidth = this.layout.width;
        float viewHeight = this.layout.height;

        Vector2 targetScroll = center - new Vector2(viewWidth * 0.5f - 50f, viewHeight * 0.5f - 50f);

        contentViewContainer.schedule.Execute(() =>
        {
            SetViewScroll(targetScroll);
        }).ExecuteLater(50);
    }

    private void SetViewScroll(Vector2 scrollPosition)
    {
        var viewType = typeof(GraphView);
        var field = viewType.GetField("_viewTransform", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
        if (field != null)
        {
            var matrix = Matrix4x4.Translate(new Vector3(-scrollPosition.x, -scrollPosition.y, 0));
            field.SetValue(this, matrix);
        }
    }

    public void ClearNodeSelection()
    {
        foreach (var element in selection.ToList())
        {
            if (element is VisualElement visualElement)
            {
                visualElement.RemoveFromClassList("selected");
            }
        }
        selection.Clear();
    }

    public void ClearNodeHighlight()
    {
        if (_highlightedNode != null && _highlightedNode.parent != null)
            _highlightedNode.style.backgroundColor = _originalNodeBgColor;
        _highlightedNode = null;
    }

    private void OnPortPointerDown(PointerDownEvent evt)
    {
        if (evt.target is Port port && port.direction == Direction.Output)
        {
            _draggedOutputPort = port;
            port.RegisterCallback<PointerUpEvent>(OnPortPointerUp, TrickleDown.TrickleDown);
        }
    }


    private void OnPortPointerUp(PointerUpEvent evt)
    {
        if (_draggedOutputPort == null)
        {
            return;
        }

        Vector2 worldPosition = evt.position;
        Vector2 localPosition = contentViewContainer.WorldToLocal(worldPosition);
        _dragReleasePosition = localPosition;

        _draggedOutputPort.UnregisterCallback<PointerUpEvent>(OnPortPointerUp);

        var settings = LoadDialogueSettings();
        if (settings == null || !settings.General.EnableQuickNodeCreationOnDragDrop)
        {
            _draggedOutputPort = null;
            return;
        }

        // Проверяем, был ли порт отпущен на другом порту
        bool releasedOnPort = false;
        foreach (var element in graphElements)
        {
            if (element is Port port && port.direction == Direction.Input && element.worldBound.Contains(worldPosition))
            {
                releasedOnPort = true;
                break;
            }
        }

        // Проверяем, находится ли точка отпускания на другом узле
        bool releasedOnNode = false;
        foreach (var element in graphElements)
        {
            if (element is Node node && node != _draggedOutputPort.node && element.worldBound.Contains(worldPosition))
            {
                releasedOnNode = true;
                break;
            }
        }

        // Если порт не был отпущен на другом порту и не на другом узле - показываем окно создания
        if (!releasedOnPort && !releasedOnNode)
        {
            ShowFilteredNodeSearchWindow();
        }

        _draggedOutputPort = null;
    }

    private void ShowFilteredNodeSearchWindow()
    {
        var draggedOutputPort = _draggedOutputPort;
        if (draggedOutputPort?.node is not BaseNode sourceNode)
        {
            _draggedOutputPort = null;
            return;
        }

        Vector2 screenPosition = _dragReleasePosition;
        if (editorWindow != null && editorWindow.rootVisualElement != null)
        {
            Vector2 worldPosition = contentViewContainer.LocalToWorld(_dragReleasePosition);
            Vector2 rootPosition = editorWindow.rootVisualElement.WorldToLocal(worldPosition);
            Rect windowRect = editorWindow.position;
            screenPosition = new Vector2(
                windowRect.x + rootPosition.x,
                windowRect.y + rootPosition.y
            );
        }
        screenPosition += new Vector2(10, 10);

        var searchWindow = ScriptableObject.CreateInstance<FilteredNodeSearchWindow>();
        searchWindow.Init(editorWindow, this, sourceNode, (nodeType) =>
        {
            if (nodeType != null && draggedOutputPort != null)
            {
                // Если у порта уже есть соединения и его capacity = Single, удаляем существующие соединения
                if (draggedOutputPort.capacity == Port.Capacity.Single)
                {
                    foreach (var edge in draggedOutputPort.connections.ToList())
                    {
                        draggedOutputPort.Disconnect(edge);
                        edge.input?.Disconnect(edge);
                        RemoveElement(edge);
                    }
                }

                // Создаем команду для создания узла и соединения
                var command = new CreateNodeAndConnectionCommand(
                    this,
                    nodeType,
                    _dragReleasePosition,
                    draggedOutputPort
                );
                undoManager.ExecuteCommand(command);
            }

            if (_draggedOutputPort == draggedOutputPort)
            {
                _draggedOutputPort = null;
            }
        });

        SearchWindow.Open(new SearchWindowContext(screenPosition), searchWindow);
    }

    private DialogueSettingsData LoadDialogueSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length == 0)
            return null;

        string path = AssetDatabase.GUIDToAssetPath(guids[0]);
        return AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
    }

    public void CopySelectedNodes()
    {
        var selectedNodes = selection.OfType<BaseNode>()
            .Where(node => !node.EntryPoint && !(node is WireNode))
            .ToList();

        if (selectedNodes.Count == 0) return;

        var clipboardData = new ClipboardData();

        foreach (var node in selectedNodes)
        {
            clipboardData.nodes.Add(new SerializedNode
            {
                type = node.GetType().Name,
                guid = node.GUID,
                position = node.GetPosition().position,
                nodeData = node.SerializeNodeData()
            });
        }

        var edges = this.edges.ToList();
        foreach (var edge in edges)
        {
            if (edge.output?.node is BaseNode outputNode &&
                edge.input?.node is BaseNode inputNode &&
                selectedNodes.Contains(outputNode) &&
                selectedNodes.Contains(inputNode))
            {
                clipboardData.connections.Add(new SerializedConnection
                {
                    sourceGuid = outputNode.GUID,
                    targetGuid = inputNode.GUID,
                    portName = edge.output.portName
                });
            }
        }

        Vector2 minPos = new Vector2(float.MaxValue, float.MaxValue);
        Vector2 maxPos = new Vector2(float.MinValue, float.MinValue);
        foreach (var node in selectedNodes)
        {
            var pos = node.GetPosition().position;
            minPos = new Vector2(Mathf.Min(minPos.x, pos.x), Mathf.Min(minPos.y, pos.y));
            maxPos = new Vector2(Mathf.Max(maxPos.x, pos.x), Mathf.Max(maxPos.y, pos.y));
        }

        clipboardData.center = (minPos + maxPos) / 2;
        clipboardData.size = maxPos - minPos;

        string json = JsonUtility.ToJson(clipboardData);
        GUIUtility.systemCopyBuffer = json;
        Debug.Log($"Copied {selectedNodes.Count} nodes to clipboard");
    }

    public void PasteNodesAtPosition(Vector2 position)
    {
        if (string.IsNullOrEmpty(GUIUtility.systemCopyBuffer)) return;

        try
        {
            var clipboardData = JsonUtility.FromJson<ClipboardData>(GUIUtility.systemCopyBuffer);
            if (clipboardData.nodes.Count == 0) return;

            var command = new PasteNodesCommand(this, clipboardData, position);
            undoManager.ExecuteCommand(command);
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to paste nodes: {e.Message}");
        }
    }

    public void CreateNode(Type nodeType, Vector2 position)
    {
        var command = new CreateNodeCommand(this, nodeType, position);
        undoManager.ExecuteCommand(command);
    }

    [System.Serializable]
    public class ClipboardData
    {
        public List<SerializedNode> nodes = new List<SerializedNode>();
        public List<SerializedConnection> connections = new List<SerializedConnection>();
        public Vector2 center;
        public Vector2 size;
    }

    [System.Serializable]
    public class SerializedNode
    {
        public string type;
        public string guid;
        public Vector2 position;
        public string nodeData;
    }

    [System.Serializable]
    public class SerializedConnection
    {
        public string sourceGuid;
        public string targetGuid;
        public string portName;
    }
}

//==== File 26 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\DialogueNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEngine;

public class DialogueNode : BaseNode
{
    public string DialogueText { get; set; }
    private TextField textField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Dialogue Node";
        DialogueText = "New Dialogue";

        // ��������� ������� ����
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // ��������� �������� ����
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        // ��������� ���� ��� �������
        textField = new TextField(string.Empty);
        textField.multiline = true;
        textField.RegisterValueChangedCallback(evt =>
        {
            DialogueText = evt.newValue;
            title = DialogueText.Length > 15 ? DialogueText.Substring(0, 15) + "..." : DialogueText;
        });
        textField.SetValueWithoutNotify(DialogueText);
        mainContainer.Add(textField);

        RefreshExpandedState();
        RefreshPorts();
    }
}


//==== File 27 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\FilteredNodeSearchWindow.cs ====
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

public class FilteredNodeSearchWindow : ScriptableObject, ISearchWindowProvider
{
    private EditorWindow _editorWindow;
    private DialogueGraphView _graphView;
    private BaseNode _sourceNode;
    private Action<Type> _onSelect;

    public void Init(EditorWindow editorWindow, DialogueGraphView graphView, BaseNode sourceNode, Action<Type> onSelect)
    {
        _editorWindow = editorWindow;
        _graphView = graphView;
        _sourceNode = sourceNode;
        _onSelect = onSelect;
    }

    public List<SearchTreeEntry> CreateSearchTree(SearchWindowContext context)
    {
        var allowedTypes = GetAllowedNodeTypes(_sourceNode);
        var entries = new List<SearchTreeEntry>
        {
            new SearchTreeGroupEntry(new GUIContent("Create Node"), 0)
        };

        // Вручную формируем группы и фильтруем по allowedTypes
        AddGroupIfHasEntries(entries, "Speech Nodes", 1, new[]
        {
            (typeof(SpeechNodeText), "Speech (Text)"),
            (typeof(SpeechNodeAudio), "Speech (Audio)"),
            (typeof(SpeechNodeImage), "Speech (Image)"),
            (typeof(SpeechNodeRandText), "Speech Rand (Text)")
        }, allowedTypes);

        AddGroupIfHasEntries(entries, "Option Nodes", 1, new[]
        {
            (typeof(OptionNodeText), "Option (Text)"),
            (typeof(OptionNodeAudio), "Option (Audio)"),
            (typeof(OptionNodeImage), "Option (Image)")
        }, allowedTypes);

        AddGroupIfHasEntries(entries, "Condition Nodes", 1, new[]
        {
            (typeof(IntConditionNode), "Condition (Int)"),
            (typeof(StringConditionNode), "Condition (String)"),
            (typeof(CharacterIntConditionNode), "Character Condition (Int)")
        }, allowedTypes);

        AddGroupIfHasEntries(entries, "Utility Nodes", 1, new[]
        {
            (typeof(EndNode), "End Node"),
            (typeof(NoteNode), "Note Node"),
            (typeof(TimerNode), "Timer"),
            (typeof(PauseNode), "Pause"),
            (typeof(RandomBranchNode), "Random Branch"),
            (typeof(WireNode), "Wire")
        }, allowedTypes);

        AddGroupIfHasEntries(entries, "Action Nodes", 1, new[]
        {
            (typeof(ModifyIntNode), "Modify Int"),
            (typeof(CharacterModifyIntNode), "Character Modify Int"),
            (typeof(EventNode), "Event")
        }, allowedTypes);

        AddGroupIfHasEntries(entries, "Debug Nodes", 1, new[]
        {
            (typeof(DebugLogNode), "Debug Log"),
            (typeof(DebugWarningNode), "Debug Warning"),
            (typeof(DebugErrorNode), "Debug Error")
        }, allowedTypes);

        return entries;
    }

    private void AddGroupIfHasEntries(
        List<SearchTreeEntry> entries,
        string groupName,
        int level,
        (Type type, string label)[] candidates,
        HashSet<Type> allowed)
    {
        var valid = candidates.Where(c => allowed.Contains(c.type)).ToArray();
        if (valid.Length == 0) return;

        entries.Add(new SearchTreeGroupEntry(new GUIContent(groupName), level));
        foreach (var (type, label) in valid)
        {
            entries.Add(new SearchTreeEntry(new GUIContent(label))
            {
                level = level + 1,
                userData = type
            });
        }
    }

    public bool OnSelectEntry(SearchTreeEntry entry, SearchWindowContext context)
    {
        if (entry.userData is Type nodeType)
        {
            _onSelect?.Invoke(nodeType);
            return true;
        }
        return false;
    }

    private HashSet<Type> GetAllowedNodeTypes(BaseNode source)
    {
        var allowed = new HashSet<Type>();

        // Определяем тип исходного узла
        Type sourceType = source.GetType();

        // Speech Node может соединяться со следующими типами
        if (sourceType == typeof(SpeechNodeText) ||
            sourceType == typeof(SpeechNodeAudio) ||
            sourceType == typeof(SpeechNodeImage) ||
            sourceType == typeof(SpeechNodeRandText))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Option Node может соединяться со следующими типами
        else if (sourceType == typeof(OptionNodeText) ||
                 sourceType == typeof(OptionNodeAudio) ||
                 sourceType == typeof(OptionNodeImage))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Condition Node может соединяться со следующими типами
        else if (sourceType == typeof(IntConditionNode) ||
                 sourceType == typeof(StringConditionNode) ||
                 sourceType == typeof(CharacterIntConditionNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Modify Node может соединяться со следующими типами
        else if (sourceType == typeof(ModifyIntNode) ||
                 sourceType == typeof(CharacterModifyIntNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Timer Node может соединяться со следующими типами
        else if (sourceType == typeof(TimerNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Pause Node может соединяться со следующими типами
        else if (sourceType == typeof(PauseNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // RandomBranch Node может соединяться со следующими типами
        else if (sourceType == typeof(RandomBranchNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(WireNode)
        });
        }
        // Wire Node может соединяться со следующими типами
        else if (sourceType == typeof(WireNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode)
        });
        }
        // Entry Node может соединяться только с Speech Node
        else if (sourceType == typeof(EntryNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText)
        });
        }
        // End Node не может соединяться ни с чем
        else if (sourceType == typeof(EndNode))
        {
            // Ничего не добавляем
        }
        // Event Node может соединяться со следующими типами
        else if (sourceType == typeof(EventNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Note Node может соединяться со всеми типами
        else if (sourceType == typeof(NoteNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        // Debug Nodes могут соединяться со всеми типами
        else if (sourceType == typeof(DebugLogNode) ||
                 sourceType == typeof(DebugWarningNode) ||
                 sourceType == typeof(DebugErrorNode))
        {
            allowed.UnionWith(new Type[] {
            typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
            typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
            typeof(IntConditionNode), typeof(StringConditionNode),
            typeof(CharacterIntConditionNode),
            typeof(EndNode), typeof(EventNode),
            typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
            typeof(TimerNode), typeof(PauseNode),
            typeof(RandomBranchNode), typeof(WireNode)
        });
        }
        else if (sourceType == typeof(CharacterButtonPressNode))
        {
            allowed.UnionWith(new Type[] {
        typeof(SpeechNodeText), typeof(SpeechNodeAudio), typeof(SpeechNodeImage), typeof(SpeechNodeRandText),
        typeof(OptionNodeText), typeof(OptionNodeAudio), typeof(OptionNodeImage),
        typeof(IntConditionNode), typeof(StringConditionNode),
        typeof(CharacterIntConditionNode),
        typeof(EndNode), typeof(EventNode),
        typeof(ModifyIntNode), typeof(CharacterModifyIntNode),
        typeof(TimerNode), typeof(PauseNode),
        typeof(RandomBranchNode), typeof(WireNode),
        typeof(CharacterButtonPressNode)
    });
        }

        return allowed;
    }
}

//==== File 28 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\NodeSearchWindow.cs ====
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;
using UnityEngine.UIElements;
using UnityEditor;
using UnityEngine;
using System;
using System.Linq;

/// <summary>
/// Window for searching and creating nodes in the dialogue graph
/// </summary>
public class NodeSearchWindow : ScriptableObject, ISearchWindowProvider
{
    private DialogueGraphView graphView;
    private EditorWindow editorWindow;
    private Texture2D indentationIcon;

    // Mapping for human-readable node type names
    private Dictionary<string, string> _nodeTypeDisplayNames = new Dictionary<string, string> {
        {"SpeechNodeText", "Speech (Text)"},
        {"SpeechNodeAudio", "Speech (Audio)"},
        {"SpeechNodeImage", "Speech (Image)"},
        {"SpeechNodeRandText", "Speech Rand (Text)"},
        {"OptionNodeText", "Option (Text)"},
        {"OptionNodeAudio", "Option (Audio)"},
        {"OptionNodeImage", "Option (Image)"},
        {"IntConditionNode", "Condition (Int)"},
        {"StringConditionNode", "Condition (String)"},
        {"CharacterIntConditionNode", "Character Condition (Int)"},
        {"EntryNode", "Entry Node"},
        {"EndNode", "End Node"},
        {"NoteNode", "Note Node"},
        {"TimerNode", "Timer"},
        {"PauseNode", "Pause"},
        {"RandomBranchNode", "Random Branch"},
        {"WireNode", "Wire"},
        {"ModifyIntNode", "Modify Int"},
        {"CharacterModifyIntNode", "Character Modify Int"},
        {"EventNode", "Event"},
        {"DebugLogNode", "Debug Log"},
        {"DebugWarningNode", "Debug Warning"},
        {"DebugErrorNode", "Debug Error"}
    };

    /// <summary>
    /// Initializes the search window
    /// </summary>
    public void Init(EditorWindow editorWindow, DialogueGraphView graphView)
    {
        this.graphView = graphView;
        this.editorWindow = editorWindow;
        // Create a transparent icon for indentation
        indentationIcon = new Texture2D(1, 1);
        indentationIcon.SetPixel(0, 0, new Color(0, 0, 0, 0));
        indentationIcon.Apply();
    }

    public List<SearchTreeEntry> CreateSearchTree(SearchWindowContext context)
    {
        // Get favorite node types from settings
        var settings = LoadDialogueSettings();
        List<string> favoriteNodeTypes = settings?.FavoriteNodeTypes ?? new List<string>();

        // Default favorite node types if settings are null or empty
        if (favoriteNodeTypes.Count == 0)
        {
            favoriteNodeTypes = new List<string> {
                "SpeechNodeText",
                "OptionNodeText",
                "IntConditionNode",
                "EndNode"
            };
        }

        var entries = new List<SearchTreeEntry>
        {
            new SearchTreeGroupEntry(new GUIContent("Create Node"), 0)
        };

        // Add favorite nodes section if there are favorites
        if (favoriteNodeTypes.Count > 0)
        {
            entries.Add(new SearchTreeGroupEntry(new GUIContent("Favorite Nodes"), 1));

            foreach (var nodeType in favoriteNodeTypes)
            {
                // Skip if node type not in our mapping
                if (!_nodeTypeDisplayNames.ContainsKey(nodeType)) continue;

                entries.Add(new SearchTreeEntry(new GUIContent(_nodeTypeDisplayNames[nodeType], indentationIcon))
                {
                    userData = Type.GetType($"DialogueSystem.{nodeType}") ?? Type.GetType(nodeType),
                    level = 2
                });
            }

            // Add separator between favorites and other nodes
            entries.Add(new SearchTreeEntry(new GUIContent("────────────────────")) { level = 1, userData = null });

        }

        // Group remaining nodes by category
        entries.Add(new SearchTreeGroupEntry(new GUIContent("Speech Nodes"), 1));
        AddNodeEntry(entries, "SpeechNodeText", 2);
        AddNodeEntry(entries, "SpeechNodeAudio", 2);
        AddNodeEntry(entries, "SpeechNodeImage", 2);
        AddNodeEntry(entries, "SpeechNodeRandText", 2);

        entries.Add(new SearchTreeGroupEntry(new GUIContent("Option Nodes"), 1));
        AddNodeEntry(entries, "OptionNodeText", 2);
        AddNodeEntry(entries, "OptionNodeAudio", 2);
        AddNodeEntry(entries, "OptionNodeImage", 2);

        entries.Add(new SearchTreeGroupEntry(new GUIContent("Condition Nodes"), 1));
        AddNodeEntry(entries, "IntConditionNode", 2);
        AddNodeEntry(entries, "StringConditionNode", 2);
        AddNodeEntry(entries, "CharacterIntConditionNode", 2);

        entries.Add(new SearchTreeGroupEntry(new GUIContent("Utility Nodes"), 1));
        AddNodeEntry(entries, "EntryNode", 2);
        AddNodeEntry(entries, "EndNode", 2);
        AddNodeEntry(entries, "NoteNode", 2);
        AddNodeEntry(entries, "TimerNode", 2);
        AddNodeEntry(entries, "PauseNode", 2);
        AddNodeEntry(entries, "RandomBranchNode", 2);
        AddNodeEntry(entries, "WireNode", 2);

        entries.Add(new SearchTreeGroupEntry(new GUIContent("Action Nodes"), 1));
        AddNodeEntry(entries, "ModifyIntNode", 2);
        AddNodeEntry(entries, "CharacterModifyIntNode", 2);
        AddNodeEntry(entries, "EventNode", 2);

        entries.Add(new SearchTreeGroupEntry(new GUIContent("Character Nodes"), 1));
        AddNodeEntry(entries, "CharacterButtonPressNode", 2);

        entries.Add(new SearchTreeGroupEntry(new GUIContent("Debug Nodes"), 1));
        AddNodeEntry(entries, "DebugLogNode", 2);
        AddNodeEntry(entries, "DebugWarningNode", 2);
        AddNodeEntry(entries, "DebugErrorNode", 2);


        return entries;
    }

    /// <summary>
    /// Helper method to add a node entry to the search tree if it's not a favorite
    /// </summary>
    private void AddNodeEntry(List<SearchTreeEntry> entries, string nodeType, int level)
    {
        var settings = LoadDialogueSettings();
        List<string> favoriteNodeTypes = settings?.FavoriteNodeTypes ?? new List<string>();

        // Skip if this node type is already in favorites
        if (favoriteNodeTypes.Contains(nodeType)) return;

        // Get the display name for this node type
        string displayName = _nodeTypeDisplayNames.TryGetValue(nodeType, out string name) ? name : nodeType;

        entries.Add(new SearchTreeEntry(new GUIContent(displayName, indentationIcon))
        {
            userData = Type.GetType($"DialogueSystem.{nodeType}") ?? Type.GetType(nodeType),
            level = level
        });
    }

    /// <summary>
    /// Handles selection of an entry in the search tree
    /// </summary>
    public bool OnSelectEntry(SearchTreeEntry searchTreeEntry, SearchWindowContext context)
    {
        // Get the mouse position in local coordinates
        var worldMousePosition = editorWindow.rootVisualElement.ChangeCoordinatesTo(
            editorWindow.rootVisualElement.parent,
            context.screenMousePosition - editorWindow.position.position
        );
        var localMousePosition = graphView.contentViewContainer.WorldToLocal(worldMousePosition);

        // Create the selected node type
        if (searchTreeEntry.userData is Type nodeType)
        {
            // Check for attempting to create a second EntryNode
            if (nodeType == typeof(EntryNode))
            {
                var existingEntryNodes = graphView.nodes.ToList().Where(node => node is EntryNode);
                if (existingEntryNodes.Any())
                {
                    EditorUtility.DisplayDialog("Cannot Create Start Node",
                        "Only one Start Node is allowed in the graph.", "OK");
                    return false;
                }
            }
            graphView.CreateNode(nodeType, localMousePosition);
            return true;
        }
        return false;
    }

    /// <summary>
    /// Loads the dialogue settings
    /// </summary>
    private DialogueSettingsData LoadDialogueSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length == 0)
            return null;

        // Take the first found settings file
        string path = AssetDatabase.GUIDToAssetPath(guids[0]);
        return AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
    }
}

//==== File 29 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\Characters\CharacterData.cs ====
// Assets/Scripts/Runtime/Characters/CharacterData.cs

using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewCharacter", menuName = "Dialogue System/Character Data")]
public class CharacterData : ScriptableObject
{
    [Header("Basic Info")]
    public string FirstName = "New";
    public string LastName = "Character";
    public Sprite Icon;
    [TextArea(3, 10)] public string Description = "";
    public Color NameColor = Color.white;

    [Header("Variables")]
    public List<CharacterVariable> Variables = new List<CharacterVariable>();

    [Header("Message Prefabs")]
    public GameObject SpeechTextMessagePrefab;
    public GameObject SpeechImageMessagePrefab;
    public GameObject SpeechAudioMessagePrefab;

    [Header("Message Sending Settings")]
    public bool RequireButtonPressForMessages = false; // false = time delay, true = button press

    public void AddVariable(string variableName = "NewVariable", int initialValue = 0)
    {
        Variables.Add(new CharacterVariable(variableName, initialValue));
    }

    public void RemoveVariable(int index)
    {
        if (index >= 0 && index < Variables.Count)
            Variables.RemoveAt(index);
    }

    public bool TryGetVariable(string variableName, out CharacterVariable variable)
    {
        variable = Variables.Find(v => v.VariableName == variableName);
        return variable != null;
    }
}

[System.Serializable]
public class CharacterVariable
{
    public string VariableName = "NewVariable";
    public int Value = 0;

    public CharacterVariable(string name, int value)
    {
        VariableName = name;
        Value = value;
    }
}

//==== File 30 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\NoteNodeData.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class NoteNodeData : BaseNodeData
{
    public string NoteText = "";
    public Color BackgroundColor = new Color(1f, 0.9152542f, 0f, 1f);
    public List<string> ConnectedNodeGuids = new List<string>(); // ��� ���������� ������
}

//==== File 31 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\RandomBranchNodeData.cs ====
// Assets/Scripts/Runtime/DialogueSystem/RandomBranchNodeData.cs
using System;
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class RandomBranchNodeData : BaseNodeData
{
    public List<RandomBranchVariant> Variants = new List<RandomBranchVariant>();
}

[System.Serializable]
public class RandomBranchVariant
{
    public string PortName = "Variant";
    public float WeightPercent = 10f;
}

//==== File 32 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Characters\CharacterEditorWindow.cs ====
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class CharacterEditorWindow : EditorWindow
{
    private List<CharacterData> characters = new List<CharacterData>();
    private CharacterData selectedCharacter;
    private Vector2 scrollPosition;
    private string searchString = "";
    // Добавляем переменные для прокрутки
    private Vector2 characterListScrollPosition;
    private Vector2 variablesScrollPosition;
    private int variableToRemove = -1;

    // === ДОБАВЛЕННЫЕ ПОЛЯ ДЛЯ АВТОСОХРАНЕНИЯ ===
    private float _lastChangeTime;
    private const float DEBOUNCE_DELAY = 0.5f;
    private CharacterData _lastSavedCharacterState; // Для отслеживания предыдущего состояния

    [MenuItem("Dialog System/Character Editor")]
    public static void ShowWindow()
    {
        GetWindow<CharacterEditorWindow>("Character Editor");
    }

    private void OnEnable()
    {
        RefreshCharacterList();
        // Инициализация времени последнего изменения
        _lastChangeTime = Time.realtimeSinceStartup;
    }

    // === МЕТОД UPDATE ДЛЯ ПРОВЕРКИ АВТОСОХРАНЕНИЯ ===
    private void Update()
    {
        // Только если окно в фокусе
        if (EditorWindow.focusedWindow == this)
        {
            AutoSaveCharacter();
        }
    }

    private void OnGUI()
    {
        DrawToolbar();
        EditorGUILayout.BeginHorizontal();
        DrawCharacterList();
        DrawCharacterDetails();
        EditorGUILayout.EndHorizontal();
        // Обрабатываем удаление переменных после отрисовки GUI
        if (variableToRemove != -1)
        {
            selectedCharacter.RemoveVariable(variableToRemove);
            _lastChangeTime = Time.realtimeSinceStartup; // Обновляем время изменения
            variableToRemove = -1;
            GUIUtility.ExitGUI(); // Выходим из текущего GUI цикла
        }
    }

    // === МЕТОД АВТОСОХРАНЕНИЯ ===
    private void AutoSaveCharacter()
    {
        if (selectedCharacter == null || _lastSavedCharacterState == null)
            return;

        // Проверяем, прошло ли достаточно времени с последнего изменения
        if (Time.realtimeSinceStartup - _lastChangeTime < DEBOUNCE_DELAY)
            return;

        // Проверяем, есть ли реальные изменения
        if (HasCharacterChanged(selectedCharacter))
        {
            EditorUtility.SetDirty(selectedCharacter);
            AssetDatabase.SaveAssets();

            // Создаем копию текущего состояния для последующего сравнения
            _lastSavedCharacterState = Instantiate(selectedCharacter);
            Debug.Log($"Character {selectedCharacter.name} auto-saved");
        }
    }

    // === ПРОВЕРКА ИЗМЕНЕНИЙ ===
    private bool HasCharacterChanged(CharacterData currentCharacter)
    {
        if (_lastSavedCharacterState == null)
            return true;

        // Сравниваем основные поля
        if (_lastSavedCharacterState.FirstName != currentCharacter.FirstName ||
            _lastSavedCharacterState.LastName != currentCharacter.LastName ||
            _lastSavedCharacterState.Icon != currentCharacter.Icon ||
            _lastSavedCharacterState.Description != currentCharacter.Description ||
            _lastSavedCharacterState.NameColor != currentCharacter.NameColor ||
            _lastSavedCharacterState.SpeechTextMessagePrefab != currentCharacter.SpeechTextMessagePrefab ||
            _lastSavedCharacterState.SpeechImageMessagePrefab != currentCharacter.SpeechImageMessagePrefab ||
            _lastSavedCharacterState.SpeechAudioMessagePrefab != currentCharacter.SpeechAudioMessagePrefab)
        {
            return true;
        }

        // Сравниваем переменные
        if (_lastSavedCharacterState.Variables.Count != currentCharacter.Variables.Count)
            return true;

        for (int i = 0; i < _lastSavedCharacterState.Variables.Count; i++)
        {
            if (_lastSavedCharacterState.Variables[i].VariableName != currentCharacter.Variables[i].VariableName ||
                _lastSavedCharacterState.Variables[i].Value != currentCharacter.Variables[i].Value)
            {
                return true;
            }
        }

        return false;
    }

    // === ОБНОВЛЕННЫЙ МЕТОД ПАНЕЛИ ИНСТРУМЕНТОВ ===
    private void DrawToolbar()
    {
        EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
        if (GUILayout.Button("Create New", EditorStyles.toolbarButton))
        {
            // Сбрасываем фокус перед созданием нового персонажа
            EditorGUI.FocusTextInControl(null);
            EditorGUIUtility.editingTextField = false;
            CreateNewCharacter();
        }
        if (GUILayout.Button("Save", EditorStyles.toolbarButton) && selectedCharacter != null)
        {
            SaveCharacter(); // Ручное сохранение по-прежнему работает
        }
        if (GUILayout.Button("Delete", EditorStyles.toolbarButton) && selectedCharacter != null)
        {
            // Сбрасываем фокус перед удалением персонажа
            EditorGUI.FocusTextInControl(null);
            EditorGUIUtility.editingTextField = false;
            DeleteCharacter();
        }
        GUILayout.FlexibleSpace();

        string newSearchString = EditorGUILayout.TextField(searchString, EditorStyles.toolbarSearchField, GUILayout.Width(200));
        // Если строка поиска изменилась, сбрасываем фокус и обновляем выделение
        if (newSearchString != searchString)
        {
            EditorGUI.FocusTextInControl(null);
            EditorGUIUtility.editingTextField = false;
            searchString = newSearchString;

            // Если строка поиска очищена или изменена, сбрасываем выделение
            if (string.IsNullOrEmpty(searchString) || selectedCharacter != null)
            {
                var filteredCharacters = string.IsNullOrEmpty(searchString)
                    ? characters
                    : characters.Where(c => c.name.ToLower().Contains(searchString.ToLower())).ToList();

                // Если текущий выбранный персонаж не входит в отфильтрованный список, сбрасываем выделение
                if (selectedCharacter != null && !filteredCharacters.Contains(selectedCharacter))
                {
                    selectedCharacter = null;
                }
            }
        }
        EditorGUILayout.EndHorizontal();
    }

    private void DrawCharacterList()
    {
        EditorGUILayout.BeginVertical(GUILayout.Width(250));
        EditorGUILayout.LabelField("Characters", EditorStyles.boldLabel);

        // Сбрасываем выделение, если список персонажей изменяется
        if (characters.Count == 0 || (searchString != "" && !characters.Any(c => c.name.ToLower().Contains(searchString.ToLower()))))
        {
            // Сбрасываем выделение, если нет персонажей или нет совпадений с фильтром
            if (selectedCharacter != null)
            {
                selectedCharacter = null;
                // Явно сбрасываем фокус со всех текстовых полей
                EditorGUIUtility.editingTextField = false;
            }
        }

        // Добавляем прокрутку для списка персонажей
        characterListScrollPosition = EditorGUILayout.BeginScrollView(characterListScrollPosition, GUILayout.ExpandHeight(true));
        var filteredCharacters = string.IsNullOrEmpty(searchString)
            ? characters
            : characters.Where(c => c.name.ToLower().Contains(searchString.ToLower())).ToList();

        foreach (var character in filteredCharacters)
        {
            var isSelected = selectedCharacter == character;
            // При клике на персонажа сбрасываем фокус с текстовых полей перед сменой выделения
            if (GUILayout.Toggle(isSelected, character.name, EditorStyles.toolbarButton) && !isSelected)
            {
                // Явно сбрасываем фокус со всех текстовых полей
                EditorGUI.FocusTextInControl(null);
                EditorGUIUtility.editingTextField = false;

                selectedCharacter = character;
                // Создаем копию текущего состояния для последующего сравнения
                if (selectedCharacter != null)
                {
                    _lastSavedCharacterState = Instantiate(selectedCharacter);
                }
                _lastChangeTime = Time.realtimeSinceStartup; // Сбрасываем таймер при смене персонажа
            }
        }
        EditorGUILayout.EndScrollView();
        EditorGUILayout.EndVertical();
    }

    private void DrawCharacterDetails()
    {
        EditorGUILayout.BeginVertical(GUILayout.ExpandWidth(true));
        if (selectedCharacter == null)
        {
            EditorGUILayout.HelpBox("Select a character or create a new one", UnityEditor.MessageType.Info);
            EditorGUILayout.EndVertical();
            return;
        }

        EditorGUI.BeginChangeCheck();

        // Basic Info
        EditorGUILayout.LabelField("Basic Information", EditorStyles.boldLabel);
        // Явно указываем ID контролов для возможности сброса фокуса
        string firstNameControlId = "FirstName_" + selectedCharacter.GetInstanceID();
        string lastNameControlId = "LastName_" + selectedCharacter.GetInstanceID();
        string descriptionControlId = "Description_" + selectedCharacter.GetInstanceID();

        EditorGUI.BeginChangeCheck();
        selectedCharacter.FirstName = EditorGUILayout.TextField("First Name", selectedCharacter.FirstName);
        if (EditorGUI.EndChangeCheck())
        {
            _lastChangeTime = Time.realtimeSinceStartup;
        }

        EditorGUI.BeginChangeCheck();
        selectedCharacter.LastName = EditorGUILayout.TextField("Last Name", selectedCharacter.LastName);
        if (EditorGUI.EndChangeCheck())
        {
            _lastChangeTime = Time.realtimeSinceStartup;
        }

        selectedCharacter.Icon = (Sprite)EditorGUILayout.ObjectField("Icon", selectedCharacter.Icon, typeof(Sprite), false);

        EditorGUI.BeginChangeCheck();
        selectedCharacter.Description = EditorGUILayout.TextArea(selectedCharacter.Description, GUILayout.Height(60));
        if (EditorGUI.EndChangeCheck())
        {
            _lastChangeTime = Time.realtimeSinceStartup;
        }

        selectedCharacter.NameColor = EditorGUILayout.ColorField("Name Color", selectedCharacter.NameColor);
        EditorGUILayout.Space();

        EditorGUILayout.Space();
        EditorGUILayout.LabelField("Message Sending", EditorStyles.boldLabel);
        selectedCharacter.RequireButtonPressForMessages = EditorGUILayout.Toggle(
            "Require Button Press",
            selectedCharacter.RequireButtonPressForMessages
        );
        EditorGUILayout.HelpBox(
            selectedCharacter.RequireButtonPressForMessages ?
            "Messages will require player button press to continue." :
            "Messages will auto-continue after delay.",
            MessageType.Info
        );
        EditorGUILayout.Space();

        // Message Prefabs
        EditorGUILayout.LabelField("Message Prefabs", EditorStyles.boldLabel);
        DrawPrefabFieldWithValidation(
            "Speech Text Message",
            ref selectedCharacter.SpeechTextMessagePrefab,
            typeof(SpeechTextMessage)
        );
        DrawPrefabFieldWithValidation(
            "Speech Image Message",
            ref selectedCharacter.SpeechImageMessagePrefab,
            typeof(SpeechImageMessage)
        );
        DrawPrefabFieldWithValidation(
            "Speech Audio Message",
            ref selectedCharacter.SpeechAudioMessagePrefab,
            typeof(SpeechAudioMessage)
        );
        EditorGUILayout.Space();

        // Variables
        EditorGUILayout.LabelField("Variables", EditorStyles.boldLabel);
        variablesScrollPosition = EditorGUILayout.BeginScrollView(variablesScrollPosition, GUILayout.Height(200));
        for (int i = 0; i < selectedCharacter.Variables.Count; i++)
        {
            EditorGUILayout.BeginHorizontal();
            selectedCharacter.Variables[i].VariableName = EditorGUILayout.TextField(
                GUIContent.none,
                selectedCharacter.Variables[i].VariableName);
            selectedCharacter.Variables[i].Value = EditorGUILayout.IntField(
                GUIContent.none,
                selectedCharacter.Variables[i].Value);
            if (GUILayout.Button("X", GUILayout.Width(20)))
            {
                variableToRemove = i;
                _lastChangeTime = Time.realtimeSinceStartup; // Обновляем время при удалении переменной
            }
            EditorGUILayout.EndHorizontal();
            // Обновляем время после изменения любой переменной
            if (GUI.changed)
                _lastChangeTime = Time.realtimeSinceStartup;
        }
        EditorGUILayout.EndScrollView();

        if (GUILayout.Button("Add Variable"))
        {
            selectedCharacter.AddVariable();
            _lastChangeTime = Time.realtimeSinceStartup; // Обновляем время при добавлении переменной
        }

        // Обработка изменений в любом поле
        if (EditorGUI.EndChangeCheck())
        {
            _lastChangeTime = Time.realtimeSinceStartup;
        }
        EditorGUILayout.EndVertical();
    }

    private void DrawPrefabFieldWithValidation(string label, ref GameObject prefab, System.Type expectedComponentType)
    {
        prefab = (GameObject)EditorGUILayout.ObjectField(label, prefab, typeof(GameObject), false);
        if (prefab == null)
        {
            EditorGUILayout.HelpBox("⚠️ Not assigned", MessageType.Warning);
        }
        else
        {
            // Проверяем, есть ли нужный компонент, реализующий IMessageObject
            var component = prefab.GetComponent(expectedComponentType);
            if (component != null && component is IMessageObject)
            {
                EditorGUILayout.HelpBox("✅ Valid: implements IMessageObject", MessageType.Info);
            }
            else
            {
                EditorGUILayout.HelpBox("❌ Invalid: missing required component or it doesn't implement IMessageObject", MessageType.Error);
            }
        }
        // Обновляем время после изменения префаба
        if (GUI.changed)
            _lastChangeTime = Time.realtimeSinceStartup;
    }

    private void CreateNewCharacter()
    {
        var newCharacter = CreateInstance<CharacterData>();
        newCharacter.name = "NewCharacter";
        var path = EditorUtility.SaveFilePanelInProject(
            "Create Character",
            "NewCharacter",
            "asset",
            "Please enter a file name to save the character");
        if (!string.IsNullOrEmpty(path))
        {
            AssetDatabase.CreateAsset(newCharacter, path);
            AssetDatabase.SaveAssets();
            RefreshCharacterList();
            selectedCharacter = newCharacter;
            // Инициализируем состояние для автосохранения
            _lastSavedCharacterState = Instantiate(selectedCharacter);
            _lastChangeTime = Time.realtimeSinceStartup;
        }
    }

    private void SaveCharacter()
    {
        if (selectedCharacter == null) return;

        EditorUtility.SetDirty(selectedCharacter);
        AssetDatabase.SaveAssets();

        // Обновляем состояние последнего сохраненного персонажа
        _lastSavedCharacterState = Instantiate(selectedCharacter);
        Debug.Log($"Character {selectedCharacter.name} saved successfully");
    }

    private void DeleteCharacter()
    {
        if (EditorUtility.DisplayDialog(
            "Delete Character",
            $"Are you sure you want to delete {selectedCharacter.name}?",
            "Delete",
            "Cancel"))
        {
            var path = AssetDatabase.GetAssetPath(selectedCharacter);
            AssetDatabase.DeleteAsset(path);
            RefreshCharacterList();
            selectedCharacter = null;
            _lastSavedCharacterState = null; // Очищаем состояние
        }
    }

    private void RefreshCharacterList()
    {
        characters.Clear();
        var guids = AssetDatabase.FindAssets("t:CharacterData");
        foreach (var guid in guids)
        {
            var path = AssetDatabase.GUIDToAssetPath(guid);
            var character = AssetDatabase.LoadAssetAtPath<CharacterData>(path);
            if (character != null)
                characters.Add(character);
        }
    }
}

//==== File 33 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\CharacterButtonPressNode.cs ====
// File: Assets/Scripts/Editor/DialogueGraph/Nodes/CharacterButtonPressNode.cs
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEngine;
using System;
using UnityEditor.UIElements;

public class CharacterButtonPressNode : BaseNode
{
    public CharacterData CharacterAsset;
    public bool RequireButtonPress = false;

    public ObjectField characterField;
    public Toggle buttonPressToggle;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Character Button Press";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Output port
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Output";
        outputContainer.Add(outputPort);

        // Character field
        characterField = new ObjectField("Character")
        {
            objectType = typeof(CharacterData)
        };
        characterField.RegisterValueChangedCallback(evt =>
        {
            CharacterAsset = evt.newValue as CharacterData;
        });
        mainContainer.Add(characterField);

        // Toggle for RequireButtonPress
        buttonPressToggle = new Toggle("Require Button Press")
        {
            value = RequireButtonPress
        };
        buttonPressToggle.RegisterValueChangedCallback(evt =>
        {
            RequireButtonPress = evt.newValue;
        });
        mainContainer.Add(buttonPressToggle);

        RefreshExpandedState();
        RefreshPorts();
        capabilities |= Capabilities.Deletable;
    }

    [System.Serializable]
    private class CharacterButtonPressNodeSerializedData
    {
        public string CharacterAssetGuid;
        public bool RequireButtonPress;
    }

    public override string SerializeNodeData()
    {
        string characterGuid = string.Empty;
        if (CharacterAsset != null)
        {
            characterGuid = AssetDatabaseHelper.GetAssetGuid(CharacterAsset);
        }

        var data = new CharacterButtonPressNodeSerializedData
        {
            CharacterAssetGuid = characterGuid,
            RequireButtonPress = RequireButtonPress
        };

        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<CharacterButtonPressNodeSerializedData>(jsonData);

        // Load character from GUID
        if (!string.IsNullOrEmpty(data.CharacterAssetGuid))
        {
            CharacterAsset = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(data.CharacterAssetGuid);
        }

        RequireButtonPress = data.RequireButtonPress;

        // Update UI
        if (characterField != null)
        {
            characterField.SetValueWithoutNotify(CharacterAsset);
        }

        if (buttonPressToggle != null)
        {
            buttonPressToggle.SetValueWithoutNotify(RequireButtonPress);
        }
    }
}

//==== File 34 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\CharacterIntConditionNode.cs ====
using System.Collections.Generic;
using UnityEngine.UIElements;
using System.Linq;
using UnityEngine;
using DialogueSystem;
using UnityEditor;
using System;

public class CharacterIntConditionNode : BaseConditionNode
{
    public string CharacterName = "";
    public string SelectedVariable = "";
    public ComparisonType Comparison;
    public int CompareValue;

    private TextField characterNameField;
    private DropdownField variableDropdown;
    private DropdownField comparisonDropdown;
    private IntegerField valueField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Character Condition (Int)";

        characterNameField = new TextField("Character Name");
        characterNameField.RegisterValueChangedCallback(evt =>
        {
            CharacterName = evt.newValue;
            RefreshVariableDropdown();
        });
        mainContainer.Add(characterNameField);

        variableDropdown = new DropdownField("Variable") { choices = new List<string>() };
        variableDropdown.RegisterValueChangedCallback(evt => SelectedVariable = evt.newValue);
        mainContainer.Add(variableDropdown);

        var choices = System.Enum.GetNames(typeof(ComparisonType));
        comparisonDropdown = new DropdownField(choices.ToList(), choices[0]); // "Equal"
        comparisonDropdown.label = "Comparison";

        comparisonDropdown.RegisterValueChangedCallback(evt =>
            Comparison = (ComparisonType)System.Enum.Parse(typeof(ComparisonType), evt.newValue));
        mainContainer.Add(comparisonDropdown);

        valueField = new IntegerField("Value");
        valueField.RegisterValueChangedCallback(evt => CompareValue = evt.newValue);
        mainContainer.Add(valueField);

        RefreshExpandedState();
        RefreshPorts();
    }

    public void SetInitialData(string characterName, string variable, ComparisonType comp, int value)
    {
        CharacterName = characterName;
        SelectedVariable = variable;
        Comparison = comp;
        CompareValue = value;
    }

    public void UpdateUIFromData()
    {
        characterNameField?.SetValueWithoutNotify(CharacterName);
        RefreshVariableDropdown();
        variableDropdown?.SetValueWithoutNotify(SelectedVariable);
        comparisonDropdown?.SetValueWithoutNotify(Comparison.ToString());
        valueField.value = CompareValue;
    }

    private void RefreshVariableDropdown()
    {
        var choices = new List<string>();
        if (!string.IsNullOrEmpty(CharacterName))
        {
#if UNITY_EDITOR
            string[] guids = UnityEditor.AssetDatabase.FindAssets($"t:CharacterData {CharacterName}");
            if (guids.Length > 0)
            {
                string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guids[0]);
                var charData = UnityEditor.AssetDatabase.LoadAssetAtPath<CharacterData>(path);
                if (charData != null)
                    choices = charData.Variables.Select(v => v.VariableName).ToList();
            }
#endif
        }
        variableDropdown.choices = choices;
        if (!string.IsNullOrEmpty(SelectedVariable) && choices.Contains(SelectedVariable))
            variableDropdown.value = SelectedVariable;
        else if (choices.Count > 0)
            variableDropdown.value = choices[0];
    }

    [System.Serializable]
    private class CharacterIntConditionNodeSerializedData
    {
        public string CharacterName;
        public string SelectedVariable;
        public string Comparison;
        public int CompareValue;
    }

    public override string SerializeNodeData()
    {
        var data = new CharacterIntConditionNodeSerializedData
        {
            CharacterName = CharacterName,
            SelectedVariable = SelectedVariable,
            Comparison = Comparison.ToString(),
            CompareValue = CompareValue
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<CharacterIntConditionNodeSerializedData>(jsonData);
        CharacterName = data.CharacterName;
        SelectedVariable = data.SelectedVariable;
        Comparison = (ComparisonType)Enum.Parse(typeof(ComparisonType), data.Comparison);
        CompareValue = data.CompareValue;

        // �������������� UI
        RefreshVariableDropdown();
        UpdateUIFromData();
    }
}

//==== File 35 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\CharacterModifyIntNode.cs ====
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;
using UnityEngine.UIElements;
using UnityEditor.Search;
using DialogueSystem;
using System.Linq;
using UnityEngine;
using UnityEditor;
using System;

public class CharacterModifyIntNode : BaseNode
{
    public CharacterData CharacterAsset;
    public string SelectedVariable = "";
    public OperatorType Operator;
    public int Value;

    private ObjectField characterField;
    private DropdownField variableDropdown;
    private DropdownField operatorDropdown;
    private IntegerField valueField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Character Modify Int";

        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Output";
        outputContainer.Add(outputPort);

        characterField = new ObjectField("Character")
        {
            objectType = typeof(CharacterData)
        };
        characterField.RegisterValueChangedCallback(evt =>
        {
            CharacterAsset = evt.newValue as CharacterData;
            RefreshVariableDropdown();
        });
        mainContainer.Add(characterField);

        variableDropdown = new DropdownField("Variable") { choices = new List<string>() };
        variableDropdown.RegisterValueChangedCallback(evt => SelectedVariable = evt.newValue);
        mainContainer.Add(variableDropdown);

        var choices = System.Enum.GetNames(typeof(OperatorType));
        operatorDropdown = new DropdownField(choices.ToList(), choices[0]);
        operatorDropdown.label = "Operator";
        operatorDropdown.RegisterValueChangedCallback(evt =>
        {
            Operator = (OperatorType)System.Enum.Parse(typeof(OperatorType), evt.newValue);
            UpdateValueFieldVisibility();
        });
        mainContainer.Add(operatorDropdown);

        valueField = new IntegerField("Value");
        valueField.RegisterValueChangedCallback(evt => Value = evt.newValue);
        mainContainer.Add(valueField);

        UpdateValueFieldVisibility();
        RefreshExpandedState();
        RefreshPorts();
    }

    private void UpdateValueFieldVisibility()
    {
        valueField.style.display = (Operator == OperatorType.Increment || Operator == OperatorType.Decrement)
            ? DisplayStyle.None : DisplayStyle.Flex;
    }

    public void UpdateUIFromData()
    {
        characterField?.SetValueWithoutNotify(CharacterAsset);
        RefreshVariableDropdown();
        variableDropdown?.SetValueWithoutNotify(SelectedVariable);
        operatorDropdown?.SetValueWithoutNotify(Operator.ToString());
        valueField.value = Value;
    }

    private void RefreshVariableDropdown()
    {
        var choices = new List<string>();
        if (CharacterAsset != null)
        {
            choices = CharacterAsset.Variables.Select(v => v.VariableName).ToList();
        }
        variableDropdown.choices = choices;
        if (!string.IsNullOrEmpty(SelectedVariable) && choices.Contains(SelectedVariable))
            variableDropdown.value = SelectedVariable;
        else if (choices.Count > 0)
            variableDropdown.value = choices[0];
    }

    [System.Serializable]
    private class CharacterModifyIntNodeSerializedData
    {
        public string CharacterAssetGuid;
        public string SelectedVariable;
        public string Operator;
        public int Value;
    }

    public override string SerializeNodeData()
    {
        string characterGuid = string.Empty;
        if (CharacterAsset != null)
        {
            characterGuid = AssetDatabaseHelper.GetAssetGuid(CharacterAsset);
        }

        var data = new CharacterModifyIntNodeSerializedData
        {
            CharacterAssetGuid = characterGuid,
            SelectedVariable = SelectedVariable,
            Operator = Operator.ToString(),
            Value = Value
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<CharacterModifyIntNodeSerializedData>(jsonData);

        // �������� ��������� �� GUID
        if (!string.IsNullOrEmpty(data.CharacterAssetGuid))
        {
            CharacterAsset = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(data.CharacterAssetGuid);
        }

        SelectedVariable = data.SelectedVariable;
        Operator = (OperatorType)Enum.Parse(typeof(OperatorType), data.Operator);
        Value = data.Value;

        // �������������� UI
        UpdateUIFromData();
    }
}

//==== File 36 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\DebugErrorNode.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;

public class DebugErrorNode : BaseNode
{
    public Label _previewLabel;
    private Button _editButton;
    public string MessageText { get; set; } = "";

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Debug Error";

        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        this.RegisterCallback<AttachToPanelEvent>(OnAttachedToPanel);

        RefreshExpandedState();
        RefreshPorts();
    }

    private void OnAttachedToPanel(AttachToPanelEvent evt)
    {
        _previewLabel = new Label(MessageText)
        {
            style =
        {
            whiteSpace = WhiteSpace.Normal,
            overflow = Overflow.Visible,
            flexGrow = 0,
            flexShrink = 0,
            alignSelf = Align.Stretch,
            maxWidth = 230f
        }
        };
        _previewLabel.AddToClassList("debug-error-preview");
        mainContainer.Add(_previewLabel);
        mainContainer.AddToClassList("main-container"); // ← важно для обводки

        _editButton = new Button(OpenTextEditor) { text = "✎" };
        _editButton.style.position = Position.Absolute;
        _editButton.style.top = 2;
        _editButton.style.right = 2;
        _editButton.style.width = 24;
        _editButton.style.height = 20;
        _editButton.style.fontSize = 10;
        titleContainer.Add(_editButton);

        var styleSheet = Resources.Load<StyleSheet>("DebugErrorNode");
        if (styleSheet != null)
            styleSheets.Add(styleSheet);

        _previewLabel.RegisterCallback<GeometryChangedEvent>(OnPreviewLabelResized);
    }

    private void OnPreviewLabelResized(GeometryChangedEvent evt)
    {
        var contentHeight = _previewLabel.layout.height;
        var minHeight = 80f;
        var newHeight = Mathf.Max(minHeight, contentHeight + 60f);
        var rect = GetPosition();
        rect.height = newHeight;
        rect.width = 250f;
        SetPosition(rect);
    }

    private void OpenTextEditor()
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null) return;

        graphView.OpenTextEditor(MessageText, GUID, newText =>
        {
            MessageText = newText;
            _previewLabel.text = MessageText;
        });
    }

    public override string SerializeNodeData()
    {
        return null;
    }

    public override void DeserializeNodeData(string jsonData)
    {
        // десериализация данных из JSON в узел
    }
}

//==== File 37 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\DebugLogNode.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using System.Linq;

public class DebugLogNode : BaseNode
{
    public Label _previewLabel;
    private Button _editButton;
    public string MessageText { get; set; } = "";

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Debug Log";

        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        this.RegisterCallback<AttachToPanelEvent>(OnAttachedToPanel);

        RefreshExpandedState();
        RefreshPorts();

        SetupDoubleClickHandler();
    }

    private void SetupDoubleClickHandler()
    {
        this.RegisterCallback<PointerDownEvent>(OnPointerDown, TrickleDown.TrickleDown);
        this.RegisterCallback<MouseMoveEvent>(OnMouseMove, TrickleDown.TrickleDown);

        // Помечаем интерактивные элементы, которые не должны реагировать на двойной клик
        if (_editButton != null)
            _editButton.AddToClassList("no-double-click");

        // Помечаем порты подключения
        MarkPortsAsNonClickable();
    }

    private void MarkPortsAsNonClickable()
    {
        foreach (var port in inputContainer.Children().OfType<Port>())
            port.AddToClassList("no-double-click");

        foreach (var port in outputContainer.Children().OfType<Port>())
            port.AddToClassList("no-double-click");
    }

    private void OnPointerDown(PointerDownEvent evt)
    {
        if (evt.clickCount != 2) return;

        var target = evt.target as VisualElement;
        while (target != null)
        {
            if (target.ClassListContains("no-double-click"))
                return;
            target = target.parent;
        }

        OpenTextEditor();
        evt.StopPropagation();
    }

    private void OnMouseMove(MouseMoveEvent evt)
    {
        var target = evt.target as VisualElement;
        while (target != null)
        {
            if (target.ClassListContains("no-double-click"))
            {
                this.style.cursor = StyleKeyword.Auto;
                return;
            }
            target = target.parent;
        }
    }

    private void OnAttachedToPanel(AttachToPanelEvent evt)
    {
        _previewLabel = new Label(MessageText)
        {
            style =
        {
            whiteSpace = WhiteSpace.Normal,
            overflow = Overflow.Visible,
            flexGrow = 0,
            flexShrink = 0,
            alignSelf = Align.Stretch,
            maxWidth = 230f
        }
        };
        _previewLabel.AddToClassList("debug-log-preview");
        mainContainer.Add(_previewLabel);
        mainContainer.AddToClassList("main-container"); // ← важно для обводки

        _editButton = new Button(OpenTextEditor) { text = "✎" };
        _editButton.style.position = Position.Absolute;
        _editButton.style.top = 2;
        _editButton.style.right = 2;
        _editButton.style.width = 24;
        _editButton.style.height = 20;
        _editButton.style.fontSize = 10;
        titleContainer.Add(_editButton);

        var styleSheet = Resources.Load<StyleSheet>("DebugLogNode");
        if (styleSheet != null)
            styleSheets.Add(styleSheet);

        _previewLabel.RegisterCallback<GeometryChangedEvent>(OnPreviewLabelResized);
    }

    private void OnPreviewLabelResized(GeometryChangedEvent evt)
    {
        var contentHeight = _previewLabel.layout.height;
        var minHeight = 80f;
        var newHeight = Mathf.Max(minHeight, contentHeight + 60f);
        var rect = GetPosition();
        rect.height = newHeight;
        rect.width = 250f;
        SetPosition(rect);
    }

    private void OpenTextEditor()
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null) return;

        graphView.OpenTextEditor(MessageText, GUID, newText =>
        {
            MessageText = newText;
            _previewLabel.text = MessageText;
        });
    }

    [System.Serializable]
    private class DebugLogNodeSerializedData
    {
        public string MessageText;
    }

    public override string SerializeNodeData()
    {
        var data = new DebugLogNodeSerializedData
        {
            MessageText = MessageText
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<DebugLogNodeSerializedData>(jsonData);
        MessageText = data.MessageText;

        // Обновление UI
        if (_previewLabel != null)
        {
            _previewLabel.text = MessageText;
        }
    }
}

//==== File 38 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\DebugWarningNode.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;

public class DebugWarningNode : BaseNode
{
    public Label _previewLabel;
    private Button _editButton;
    public string MessageText { get; set; } = "";

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Debug Warning";

        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        this.RegisterCallback<AttachToPanelEvent>(OnAttachedToPanel);

        RefreshExpandedState();
        RefreshPorts();
    }

    private void OnAttachedToPanel(AttachToPanelEvent evt)
    {
        _previewLabel = new Label(MessageText)
        {
            style =
        {
            whiteSpace = WhiteSpace.Normal,
            overflow = Overflow.Visible,
            flexGrow = 0,
            flexShrink = 0,
            alignSelf = Align.Stretch,
            maxWidth = 230f
        }
        };
        _previewLabel.AddToClassList("debug-warning-preview");
        mainContainer.Add(_previewLabel);
        mainContainer.AddToClassList("main-container"); // ← важно для обводки

        _editButton = new Button(OpenTextEditor) { text = "✎" };
        _editButton.style.position = Position.Absolute;
        _editButton.style.top = 2;
        _editButton.style.right = 2;
        _editButton.style.width = 24;
        _editButton.style.height = 20;
        _editButton.style.fontSize = 10;
        titleContainer.Add(_editButton);

        var styleSheet = Resources.Load<StyleSheet>("DebugWarningNode");
        if (styleSheet != null)
            styleSheets.Add(styleSheet);

        _previewLabel.RegisterCallback<GeometryChangedEvent>(OnPreviewLabelResized);
    }

    private void OnPreviewLabelResized(GeometryChangedEvent evt)
    {
        var contentHeight = _previewLabel.layout.height;
        var minHeight = 80f;
        var newHeight = Mathf.Max(minHeight, contentHeight + 60f);
        var rect = GetPosition();
        rect.height = newHeight;
        rect.width = 250f;
        SetPosition(rect);
    }

    private void OpenTextEditor()
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null) return;

        graphView.OpenTextEditor(MessageText, GUID, newText =>
        {
            MessageText = newText;
            _previewLabel.text = MessageText;
        });
    }

    public override string SerializeNodeData()
    {
        return null;
    }

    public override void DeserializeNodeData(string jsonData)
    {
        // десериализация данных из JSON в узел
    }
}

//==== File 39 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\EndNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEditor;
using UnityEngine;
using UnityEditor.Search;

public class EndNode : BaseNode
{
    // ������ �� ��������� ������ ��� drag-and-drop
    public DialogueContainer NextDialogueAsset { get; set; }
    private ObjectField nextDialogueField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "End Node";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // ObjectField ��� drag-and-drop ���������� �������
        nextDialogueField = new ObjectField("Next Dialogue")
        {
            objectType = typeof(DialogueContainer)
        };
        nextDialogueField.RegisterValueChangedCallback(evt =>
        {
            NextDialogueAsset = evt.newValue as DialogueContainer;
        });
        mainContainer.Add(nextDialogueField);

        RefreshExpandedState();
        RefreshPorts();
        styleSheets.Add(Resources.Load<StyleSheet>("EndNode"));
    }

    /// <summary>
    /// �������� ���� � ���������� ������� � Resources (��� .asset), ��� ���������� ������ ������, ���� ���� �� � Resources.
    /// </summary>
    public string GetNextDialoguePath()
    {
        if (NextDialogueAsset == null)
            return string.Empty;

        string assetPath = AssetDatabase.GetAssetPath(NextDialogueAsset);
        if (string.IsNullOrEmpty(assetPath))
            return string.Empty;

        // ���������, ��� ���� ��������� � ����� Assets/Resources/
        if (!assetPath.StartsWith("Assets/Resources/"))
        {
            Debug.LogWarning($"Dialogue asset '{NextDialogueAsset.name}' is not in Resources folder. It will not be loadable at runtime via Resources.Load.", NextDialogueAsset);
            return string.Empty;
        }

        // ������� "Assets/Resources/" � ���������� ".asset"
        string relativePath = assetPath.Substring("Assets/Resources/".Length);
        if (relativePath.EndsWith(".asset"))
            relativePath = relativePath.Substring(0, relativePath.Length - 6);

        return relativePath;
    }

    /// <summary>
    /// ������������� ��������� ������ �� ���� (��������������� ������ ��� ��������)
    /// </summary>
    public void SetNextDialogueFromPath(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            NextDialogueAsset = null;
            nextDialogueField?.SetValueWithoutNotify(null);
            return;
        }

        // �������� ��������� �� Resources
        var asset = Resources.Load<DialogueContainer>(path);
        if (asset != null)
        {
            NextDialogueAsset = asset;
            nextDialogueField?.SetValueWithoutNotify(asset);
            return;
        }

        // �������� ��������� ����� AssetDatabase (��� ���������)
        string fullPath = $"Assets/Resources/{path}.asset";
        var assetAtPath = AssetDatabase.LoadAssetAtPath<DialogueContainer>(fullPath);
        if (assetAtPath != null)
        {
            NextDialogueAsset = assetAtPath;
            nextDialogueField?.SetValueWithoutNotify(assetAtPath);
        }
        else
        {
            NextDialogueAsset = null;
            nextDialogueField?.SetValueWithoutNotify(null);
            Debug.LogWarning($"Could not restore DialogueContainer for path: {path}");
        }
    }
}

//==== File 40 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\EntryNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

/// <summary>
/// ��������� ���� - ����� ����� � ���������� ����
/// �� ����� ���� ������ ��� ���������
/// </summary>
public class EntryNode : BaseNode
{
    /// <summary>
    /// ������������� ���������� ����
    /// </summary>
    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "START";
        EntryPoint = true;

        // ������� �������� ����
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        // �������� ���������
        DialogueSettingsData settings = null;
        string[] guids = UnityEditor.AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length > 0)
        {
            string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guids[0]);
            settings = UnityEditor.AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
        }

        bool canMove = settings != null && settings.General.EnableEntryNodeMovement;

        // �����: ��������� ��� ������� capabilities ��� ���������� ������ � ������
        capabilities = Capabilities.Selectable | Capabilities.Collapsible | Capabilities.Movable;

        // ������������ � ����������� �� ��������� �����������
        if (!canMove)
        {
            capabilities &= ~Capabilities.Movable;
        }

        capabilities &= ~Capabilities.Deletable; // ��������� �������� ������

        // ��������� ��������� ����
        RefreshExpandedState();
        RefreshPorts();

        // ��������� �����
        styleSheets.Add(Resources.Load<StyleSheet>("DefNode"));
    }

    public override string SerializeNodeData()
    {
        return null;
    }

    public override void DeserializeNodeData(string jsonData)
    {
        // �������������� ������ �� JSON � ����
    }
}

//==== File 41 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\EventNode.cs ====
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UIElements;

public class EventNode : BaseNode
{
    public UnityEvent RuntimeEvent = new UnityEvent();
    private VisualElement _eventContainer;
    private EventNodeHelperSO _helperSO;

    public EventNode()
    {
        this.RegisterCallback<DetachFromPanelEvent>(OnDetachedFromPanel);
    }

    private void OnDetachedFromPanel(DetachFromPanelEvent evt)
    {
        if (_helperSO != null)
        {
            UnityEngine.Object.DestroyImmediate(_helperSO);
            _helperSO = null;
        }
    }

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Event Node";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Output port
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        // Создаем временный ScriptableObject для редактирования события
        _helperSO = ScriptableObject.CreateInstance<EventNodeHelperSO>();
        _helperSO.Event = RuntimeEvent;

        _eventContainer = new IMGUIContainer(() =>
        {
            var so = new SerializedObject(_helperSO);
            var prop = so.FindProperty("Event");
            EditorGUILayout.PropertyField(prop, true);
            so.ApplyModifiedProperties();
            // Синхронизируем обратно в RuntimeEvent
            RuntimeEvent = _helperSO.Event;
        });

        mainContainer.Add(_eventContainer);
        RefreshExpandedState();
        RefreshPorts();
    }
}

//==== File 42 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\IntConditionNode.cs ====
using System.Collections.Generic;
using UnityEngine.UIElements;
using System.Linq;
using UnityEngine;
using DialogueSystem;
using System;

public class IntConditionNode : BaseConditionNode, IPropertyNode
{
    public string SelectedProperty;
    public ComparisonType Comparison;
    public int CompareValue;

    private DropdownField propertyDropdown;
    private DropdownField comparisonDropdown;
    private IntegerField valueField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Condition (Int)";

        // Property dropdown
        propertyDropdown = new DropdownField("Property");
        propertyDropdown.choices = new List<string>();
        propertyDropdown.RegisterValueChangedCallback(evt =>
        {
            SelectedProperty = evt.newValue;
        });
        mainContainer.Add(propertyDropdown);

        // Comparison dropdown
        comparisonDropdown = new DropdownField("Comparison");
        comparisonDropdown.choices = System.Enum.GetNames(typeof(ComparisonType)).ToList();
        comparisonDropdown.RegisterValueChangedCallback(evt =>
        {
            Comparison = (ComparisonType)System.Enum.Parse(typeof(ComparisonType), evt.newValue);
        });
        mainContainer.Add(comparisonDropdown);

        // Value field
        valueField = new IntegerField("Value");
        valueField.RegisterValueChangedCallback(evt => CompareValue = evt.newValue);
        mainContainer.Add(valueField);

        // �������� ������� ��� ���������� � ������
        this.RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
    }

    private void OnAttachToPanel(AttachToPanelEvent evt)
    {
        // ������ ���� �������� � ���� � ����� �������� ������ � DialogueGraphView
        RefreshPropertyDropdown();
        this.UnregisterCallback<AttachToPanelEvent>(OnAttachToPanel);
    }
    public void SetInitialData(string property, ComparisonType comparison, int value)
    {
        SelectedProperty = property;
        Comparison = comparison;
        CompareValue = value;
    }
    public void RefreshPropertyDropdown()
    {
        // �������� �������� �� �����
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView != null && propertyDropdown != null)
        {
            propertyDropdown.choices = graphView.IntExposedProperties
                .Where(p => p != null)
                .Select(p => p.PropertyName)
                .ToList();

            // ���� ���� ��������, �������� ������ �� ���������
            if (propertyDropdown.choices.Count > 0 && string.IsNullOrEmpty(SelectedProperty))
            {
                propertyDropdown.value = propertyDropdown.choices[0];
                SelectedProperty = propertyDropdown.choices[0];
            }
            else if (!string.IsNullOrEmpty(SelectedProperty))
            {
                propertyDropdown.value = SelectedProperty;
            }
        }
    }

    /// <summary>
    /// ��������� UI-�������� �� ������ ������� �������� �����.
    /// �������� ����� �������� ������ � ���������� ���� � ����.
    /// </summary>
    public void UpdateUIFromData()
    {
        if (propertyDropdown != null && comparisonDropdown != null && valueField != null)
        {
            propertyDropdown.value = SelectedProperty;
            comparisonDropdown.value = Comparison.ToString();
            valueField.value = CompareValue;
        }
    }
    [System.Serializable]
    private class IntConditionNodeSerializedData
    {
        public string SelectedProperty;
        public string Comparison;
        public int CompareValue;
    }

    public override string SerializeNodeData()
    {
        var data = new IntConditionNodeSerializedData
        {
            SelectedProperty = SelectedProperty,
            Comparison = Comparison.ToString(),
            CompareValue = CompareValue
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<IntConditionNodeSerializedData>(jsonData);
        SelectedProperty = data.SelectedProperty;
        Comparison = (ComparisonType)Enum.Parse(typeof(ComparisonType), data.Comparison);
        CompareValue = data.CompareValue;

        // �������������� UI
        RefreshPropertyDropdown();
        UpdateUIFromData();
    }
}

//==== File 43 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\ModifyIntNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using DialogueSystem;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;

public class ModifyIntNode : BaseNode, IPropertyNode
{
    public string SelectedProperty;
    public OperatorType Operator;
    public int Value;

    private DropdownField propertyDropdown;
    private DropdownField operatorDropdown;
    private IntegerField valueField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Modify Int";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Output port
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Output";
        outputContainer.Add(outputPort);

        // Property dropdown
        propertyDropdown = new DropdownField("Property");
        propertyDropdown.choices = new List<string>();
        propertyDropdown.RegisterValueChangedCallback(evt =>
        {
            SelectedProperty = evt.newValue;
        });
        mainContainer.Add(propertyDropdown);

        // Operator dropdown
        operatorDropdown = new DropdownField("Operator");
        operatorDropdown.choices = System.Enum.GetNames(typeof(OperatorType)).ToList();
        operatorDropdown.RegisterValueChangedCallback(evt =>
        {
            Operator = (OperatorType)System.Enum.Parse(typeof(OperatorType), evt.newValue);
            UpdateValueFieldVisibility();
        });
        mainContainer.Add(operatorDropdown);

        // Value field
        valueField = new IntegerField("Value");
        valueField.RegisterValueChangedCallback(evt => Value = evt.newValue);
        mainContainer.Add(valueField);

        UpdateValueFieldVisibility();

        // ����������� ���������� ������ ������� �� �������, ����� ���� ����� �������� � ����
        this.RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);

        RefreshExpandedState();
        RefreshPorts();
    }

    private void OnAttachToPanel(AttachToPanelEvent evt)
    {
        // ������ ���� �������� � ���� � ����� �������� ������ � DialogueGraphView
        RefreshPropertyDropdown();
        this.UnregisterCallback<AttachToPanelEvent>(OnAttachToPanel);
    }

    private void UpdateValueFieldVisibility()
    {
        valueField.style.display = (Operator == OperatorType.Increment ||
                                  Operator == OperatorType.Decrement) ?
                                  DisplayStyle.None : DisplayStyle.Flex;
    }

    /// <summary>
    /// ��������� UI-�������� �� ������ ������� �������� �����.
    /// ���������� ��� �������� ���� �� DialogueContainer.
    /// </summary>
    public void UpdateUIFromData()
    {
        if (propertyDropdown != null && operatorDropdown != null && valueField != null)
        {
            propertyDropdown.value = SelectedProperty;
            operatorDropdown.value = Operator.ToString();
            valueField.value = Value;
            UpdateValueFieldVisibility();
        }
    }

    public void RefreshPropertyDropdown()
    {
        // �������� �������� �� �����
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView != null && propertyDropdown != null)
        {
            propertyDropdown.choices = graphView.IntExposedProperties
                .Where(p => p != null)
                .Select(p => p.PropertyName)
                .ToList();

            // ���� ���� ��������, �������� ������ �� ���������
            if (propertyDropdown.choices.Count > 0 && string.IsNullOrEmpty(SelectedProperty))
            {
                propertyDropdown.value = propertyDropdown.choices[0];
                SelectedProperty = propertyDropdown.choices[0];
            }
            else if (!string.IsNullOrEmpty(SelectedProperty) &&
                     propertyDropdown.choices.Contains(SelectedProperty))
            {
                propertyDropdown.value = SelectedProperty;
            }
            else if (!string.IsNullOrEmpty(SelectedProperty))
            {
                // ���� �������� ���� �������, ���������� �����
                propertyDropdown.value = "";
                SelectedProperty = "";
            }
        }
    }

    [System.Serializable]
    private class ModifyIntNodeSerializedData
    {
        public string SelectedProperty;
        public string Operator;
        public int Value;
    }

    public override string SerializeNodeData()
    {
        var data = new ModifyIntNodeSerializedData
        {
            SelectedProperty = SelectedProperty,
            Operator = Operator.ToString(),
            Value = Value
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<ModifyIntNodeSerializedData>(jsonData);
        SelectedProperty = data.SelectedProperty;
        Operator = (OperatorType)Enum.Parse(typeof(OperatorType), data.Operator);
        Value = data.Value;

        // �������������� UI
        RefreshPropertyDropdown();
        UpdateUIFromData();
    }
}

//==== File 44 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\NoteNode.cs ====
/// Assets/Scripts/Editor/DialogueGraph/Nodes/NoteNode.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using UnityEditor;
using System.Collections.Generic;
using UnityEditor.UIElements;

public class NoteNode : BaseNode
{
    public string NoteText { get; set; } = "";
    public Color BackgroundColor { get; set; } = new Color(1f, 0.98f, 0.77f, 1f);
    public List<string> ConnectedNodeGuids { get; set; } = new List<string>();

    private Label _previewLabel;
    private Button _editButton;
    private ColorField _colorField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Note";

        // Убираем стандартные порты (но оставляем возможность удаления)
        inputContainer.Clear();
        outputContainer.Clear();

        // УБИРАЕМ эту строку - оставляем возможность удаления
        // capabilities &= ~Capabilities.Deletable;

        // Оставляем возможность сворачивания для удобства
        capabilities |= Capabilities.Collapsible;

        this.RegisterCallback<AttachToPanelEvent>(OnAttachedToPanel);

        RefreshExpandedState();
        RefreshPorts();
    }

    private void OnAttachedToPanel(AttachToPanelEvent evt)
    {
        // Создаем превью текста
        _previewLabel = new Label(NoteText)
        {
            style =
            {
                whiteSpace = WhiteSpace.Normal,
                overflow = Overflow.Visible,
                flexGrow = 1,
                flexShrink = 0,
                alignSelf = Align.Stretch,
                fontSize = 11,
                unityTextAlign = TextAnchor.UpperLeft,
                marginTop = 5,
                marginBottom = 5,
                color = new Color(0.17f, 0.24f, 0.31f), // Темно-синий для лучшей читаемости
                unityFontStyleAndWeight = FontStyle.Normal
            }
        };
        _previewLabel.AddToClassList("note-preview");
        mainContainer.Add(_previewLabel);

        // Кнопка редактирования
        _editButton = new Button(OpenTextEditor) { text = "✎" };
        _editButton.style.position = Position.Absolute;
        _editButton.style.top = 2;
        _editButton.style.right = 2;
        _editButton.style.width = 24;
        _editButton.style.height = 20;
        _editButton.style.fontSize = 10;
        titleContainer.Add(_editButton);

        // Поле выбора цвета
        _colorField = new ColorField("Background Color");
        _colorField.value = BackgroundColor;
        _colorField.showAlpha = true;
        _colorField.RegisterValueChangedCallback(evt =>
        {
            BackgroundColor = evt.newValue;
            UpdateBackgroundColor();
        });
        mainContainer.Add(_colorField);

        // Загружаем стили
        var styleSheet = Resources.Load<StyleSheet>("NoteNode");
        if (styleSheet != null)
            styleSheets.Add(styleSheet);

        UpdateBackgroundColor();

        // Подписываемся на изменение размера текста
        _previewLabel.RegisterCallback<GeometryChangedEvent>(OnPreviewLabelResized);
    }

    private void OnPreviewLabelResized(GeometryChangedEvent evt)
    {
        // Автоматически подстраиваем высоту узла под содержимое
        var contentHeight = _previewLabel.layout.height;
        var minHeight = 120f;
        var newHeight = Mathf.Max(minHeight, contentHeight + 100f); // + отступы для цветового поля и заголовка

        var rect = GetPosition();
        rect.height = newHeight;
        rect.width = Mathf.Max(250f, rect.width); // Минимальная ширина
        SetPosition(rect);
    }

    private void OpenTextEditor()
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null) return;

        graphView.OpenTextEditor(NoteText, GUID, newText =>
        {
            NoteText = newText;
            _previewLabel.text = NoteText;
        });
    }

    private void UpdateBackgroundColor()
    {
        // Применяем цвет фона ко всему узлу
        style.backgroundColor = new StyleColor(BackgroundColor);

        // Автоматически настраиваем цвет текста для контрастности
        UpdateTextContrast();
    }

    private void UpdateTextContrast()
    {
        if (_previewLabel == null) return;

        // Вычисляем яркость фона для определения контрастного цвета текста
        float brightness = BackgroundColor.r * 0.299f + BackgroundColor.g * 0.587f + BackgroundColor.b * 0.114f;

        // Если фон светлый - темный текст, если темный - светлый текст
        if (brightness > 0.6f)
        {
            _previewLabel.style.color = new Color(0.17f, 0.24f, 0.31f); // Темно-синий
        }
        else
        {
            _previewLabel.style.color = new Color(0.95f, 0.95f, 0.95f); // Светлый
        }
    }

    public void SetNoteText(string text)
    {
        NoteText = text ?? "";
        if (_previewLabel != null)
            _previewLabel.text = NoteText;
    }

    public void SetBackgroundColor(Color color)
    {
        BackgroundColor = color;
        if (_colorField != null)
            _colorField.value = color;
        UpdateBackgroundColor();
    }

    // Методы для управления визуальными связями
    public void AddVisualConnection(string targetNodeGuid)
    {
        if (!ConnectedNodeGuids.Contains(targetNodeGuid))
            ConnectedNodeGuids.Add(targetNodeGuid);
    }

    public void RemoveVisualConnection(string targetNodeGuid)
    {
        ConnectedNodeGuids.Remove(targetNodeGuid);
    }

    public void ClearVisualConnections()
    {
        ConnectedNodeGuids.Clear();
    }

    [System.Serializable]
    private class NoteNodeSerializedData
    {
        public string NoteText;
        public Color BackgroundColor;
    }

    public override string SerializeNodeData()
    {
        var data = new NoteNodeSerializedData
        {
            NoteText = NoteText,
            BackgroundColor = BackgroundColor
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<NoteNodeSerializedData>(jsonData);
        NoteText = data.NoteText;
        BackgroundColor = data.BackgroundColor;

        // Обновление UI
        if (_previewLabel != null)
        {
            _previewLabel.text = NoteText;
        }
        if (_colorField != null)
        {
            _colorField.SetValueWithoutNotify(BackgroundColor);
        }
        UpdateBackgroundColor();
    }
}

//==== File 45 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\OptionNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEngine;
using UnityEditor.Search;

/// <summary>
/// ���� �������� ������ ������ - �������� ����� ������ � �������
/// ����� ���� ��������� ������ � SpeechNode
/// </summary>
public class OptionNode : BaseNode
{
    public string ResponseText { get; set; } // ����� ������
    public AudioClip AudioClip { get; set; } // ��������� �������

    protected TextField responseTextField;
    protected ObjectField audioField;

    /// <summary>
    /// ������������� ���� �������� ������ ������
    /// </summary>
    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Option Node";
        ResponseText = "New Response";

        // ������� ������� ���� (������ ���� �����������)
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // ������� �������� ���� (������ ���� �����������)
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        // ���� ��� ������ ������
        responseTextField = new TextField("Response Text:");
        responseTextField.multiline = true;
        responseTextField.RegisterValueChangedCallback(evt =>
        {
            ResponseText = evt.newValue;
            //title = ResponseText.Length > 15 ? ResponseText.Substring(0, 15) + "..." : ResponseText;
        });
        responseTextField.SetValueWithoutNotify(ResponseText);
        mainContainer.Add(responseTextField);

        // ���� ��� ������ ����������
        audioField = new ObjectField("Audio Clip");
        audioField.objectType = typeof(AudioClip);
        audioField.RegisterValueChangedCallback(evt =>
        {
            AudioClip = evt.newValue as AudioClip;
        });
        mainContainer.Add(audioField);

        // ��������� ���������� ��������� ����
        RefreshExpandedState();
        RefreshPorts();

        // ��������� ����������� ����� ��� OptionNode
        styleSheets.Add(Resources.Load<StyleSheet>("DefNode"));
    }

    public virtual void SetResponseText(string text)
    {
        ResponseText = text;
        if (responseTextField != null)
            responseTextField.SetValueWithoutNotify(text);
    }

    public override string SerializeNodeData()
    {
        return null;
    }

    public override void DeserializeNodeData(string jsonData)
    {
        // �������������� ������ �� JSON � ����
    }
}

//==== File 46 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\OptionNodeAudio.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;

public class OptionNodeAudio : OptionNode
{
    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Option (Audio)";

        // ������� ��������� ����
        if (responseTextField != null)
        {
            mainContainer.Remove(responseTextField);
            responseTextField = null;
            ResponseText = string.Empty;
        }

        // ������������� ����
        styleSheets.Add(Resources.Load<StyleSheet>("OptionNodeAudio"));
    }
}

//==== File 47 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\OptionNodeImage.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using UnityEditor.Search;

public class OptionNodeImage : OptionNode
{
    public Sprite ImageSprite { get; set; }
    private ObjectField imageField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Option (Image)";

        // ������� �������� ����
        if (responseTextField != null)
        {
            mainContainer.Remove(responseTextField);
            responseTextField = null;
            ResponseText = string.Empty;
        }

        if (audioField != null)
        {
            mainContainer.Remove(audioField);
            audioField = null;
            AudioClip = null;
        }

        // ��������� ���� ��� �����������
        imageField = new ObjectField("Image Sprite");
        imageField.objectType = typeof(Sprite);
        imageField.RegisterValueChangedCallback(evt =>
        {
            ImageSprite = evt.newValue as Sprite;
        });
        mainContainer.Add(imageField);

        // ������������� ����
        styleSheets.Add(Resources.Load<StyleSheet>("OptionNodeImage"));
    }
}


//==== File 48 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\OptionNodeText.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using System.Linq;

public class OptionNodeText : OptionNode
{
    private Label _previewLabel;
    private Button _editButton;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Option (Text)";

        if (responseTextField != null)
        {
            mainContainer.Remove(responseTextField);
            responseTextField = null;
        }

        _previewLabel = new Label(ResponseText)
        {
            style =
            {
                whiteSpace = WhiteSpace.Normal,
                overflow = Overflow.Visible,
                flexGrow = 1,
                flexShrink = 0,
                alignSelf = Align.Stretch
            }
        };
        _previewLabel.AddToClassList("option-text-preview");

        _editButton = new Button(OpenTextEditor) { text = "✎" };
        _editButton.style.position = Position.Absolute;
        _editButton.style.top = 2;
        _editButton.style.right = 2;
        _editButton.style.width = 24;
        _editButton.style.height = 20;
        _editButton.style.fontSize = 10;

        mainContainer.Add(_previewLabel);
        titleContainer.Add(_editButton);

        if (audioField != null)
        {
            mainContainer.Remove(audioField);
            audioField = null;
            AudioClip = null;
        }

        styleSheets.Add(Resources.Load<StyleSheet>("OptionNodeText"));

        _previewLabel.RegisterCallback<GeometryChangedEvent>(OnPreviewLabelResized);

        SetupDoubleClickHandler();
    }


    private void SetupDoubleClickHandler()
    {
        this.RegisterCallback<PointerDownEvent>(OnPointerDown, TrickleDown.TrickleDown);
        this.RegisterCallback<MouseMoveEvent>(OnMouseMove, TrickleDown.TrickleDown);

        // Помечаем интерактивные элементы, которые не должны реагировать на двойной клик
        if (_editButton != null)
            _editButton.AddToClassList("no-double-click");

        // Помечаем порты подключения
        MarkPortsAsNonClickable();
    }

    private void MarkPortsAsNonClickable()
    {
        foreach (var port in inputContainer.Children().OfType<Port>())
            port.AddToClassList("no-double-click");

        foreach (var port in outputContainer.Children().OfType<Port>())
            port.AddToClassList("no-double-click");
    }

    private void OnPointerDown(PointerDownEvent evt)
    {
        if (evt.clickCount != 2) return;

        var target = evt.target as VisualElement;
        while (target != null)
        {
            if (target.ClassListContains("no-double-click"))
                return;
            target = target.parent;
        }

        OpenTextEditor();
        evt.StopPropagation();
    }

    private void OnMouseMove(MouseMoveEvent evt)
    {
        var target = evt.target as VisualElement;
        while (target != null)
        {
            if (target.ClassListContains("no-double-click"))
            {
                this.style.cursor = StyleKeyword.Auto;
                return;
            }
            target = target.parent;
        }
    }

    private void OnPreviewLabelResized(GeometryChangedEvent evt)
    {
        var contentHeight = _previewLabel.layout.height;
        var minHeight = 80f;
        var newHeight = Mathf.Max(minHeight, contentHeight + 60);

        var rect = GetPosition();
        rect.height = newHeight;
        SetPosition(rect);
    }

    private void OpenTextEditor()
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null) return;

        graphView.OpenTextEditor(ResponseText, GUID, newText =>
        {
            ResponseText = newText;
            _previewLabel.text = ResponseText;
        });
    }

    public override void SetResponseText(string text)
    {
        ResponseText = text ?? "";
        if (_previewLabel != null)
            _previewLabel.text = ResponseText;
    }

    [System.Serializable]
    private class OptionNodeTextSerializedData
    {
        public string ResponseText;
    }

    public override string SerializeNodeData()
    {
        var data = new OptionNodeTextSerializedData
        {
            ResponseText = ResponseText
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<OptionNodeTextSerializedData>(jsonData);
        ResponseText = data.ResponseText;

        // Обновление UI
        if (_previewLabel != null)
        {
            _previewLabel.text = ResponseText;
        }
    }
}

//==== File 49 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\PauseNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEngine;

public class PauseNode : BaseNode
{
    public float DurationSeconds = 1.0f;
    private Slider _durationSlider;
    private Label _valueLabel;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Pause";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Output port
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        // Slider with input field
        _durationSlider = new Slider(0.1f, 60.0f)
        {
            value = DurationSeconds,
            showInputField = true
        };
        _durationSlider.RegisterValueChangedCallback(evt =>
        {
            DurationSeconds = evt.newValue;
            UpdateLabel();
        });

        _valueLabel = new Label();
        UpdateLabel();

        mainContainer.Add(_durationSlider);
        mainContainer.Add(_valueLabel);

        RefreshExpandedState();
        RefreshPorts();
    }

    private void UpdateLabel()
    {
        _valueLabel.text = $"{DurationSeconds:F2} sec";
    }

    public void SetDuration(float duration)
    {
        DurationSeconds = Mathf.Clamp(duration, 0.1f, 60.0f);
        _durationSlider.value = DurationSeconds;
        UpdateLabel();
    }

    [System.Serializable]
    private class PauseNodeSerializedData
    {
        public float DurationSeconds;
    }

    public override string SerializeNodeData()
    {
        var data = new PauseNodeSerializedData
        {
            DurationSeconds = DurationSeconds
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<PauseNodeSerializedData>(jsonData);
        SetDuration(data.DurationSeconds);
    }
}


//==== File 50 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\RandomBranchNode.cs ====
// Assets/Scripts/Editor/DialogueGraph/Nodes/RandomBranchNode.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;
using UnityEditor;

public class RandomBranchNode : BaseNode
{
    private VisualElement variantsContainer;
    public List<BranchVariantElement> variantElements = new List<BranchVariantElement>();
    private Label totalWeightLabel;

    public class BranchVariantElement
    {
        public RandomBranchVariant Data;
        public VisualElement Container;
        public Port Port;
        public FloatField WeightField;
        public Slider WeightSlider;
        public Button RemoveButton;
        public TextField NameField;
    }

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Random Branch";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Header for variants section
        var variantsHeader = new VisualElement();
        variantsHeader.style.flexDirection = FlexDirection.Row;
        variantsHeader.style.justifyContent = Justify.SpaceBetween;
        variantsHeader.style.marginBottom = 10;

        var variantsTitle = new Label("Branch Variants");
        variantsTitle.style.unityFontStyleAndWeight = FontStyle.Bold;

        totalWeightLabel = new Label("Total: 0%");
        totalWeightLabel.style.color = new StyleColor(Color.gray);

        variantsHeader.Add(variantsTitle);
        variantsHeader.Add(totalWeightLabel);
        mainContainer.Add(variantsHeader);

        variantsContainer = new VisualElement();
        mainContainer.Add(variantsContainer);

        var addButton = new Button(AddVariant) { text = "Add Variant" };
        addButton.style.marginTop = 5;
        mainContainer.Add(addButton);

        RefreshExpandedState();
        RefreshPorts();

        UpdateTotalWeight();

        // Set fixed width for the node
        SetPosition(new Rect(position, new Vector2(300, 200)));

        // Add initial variant
        AddVariant();
    }

    private void AddVariant()
    {
        var variant = new RandomBranchVariant
        {
            PortName = $"Variant {variantElements.Count + 1}",
            WeightPercent = 10f
        };
        CreateVariantUI(variant);
        UpdateTotalWeight();
    }

    private void CreateVariantUI(RandomBranchVariant variant)
    {
        var container = new VisualElement();
        container.style.flexDirection = FlexDirection.Column;
        container.style.marginBottom = 12;
        container.style.paddingTop = 8;
        container.style.paddingBottom = 8;
        container.style.paddingLeft = 8;
        container.style.paddingRight = 8;
        container.style.backgroundColor = new StyleColor(new Color(0.1f, 0.1f, 0.1f, 0.2f));
        container.style.borderTopLeftRadius = 4;
        container.style.borderTopRightRadius = 4;
        container.style.borderBottomLeftRadius = 4;
        container.style.borderBottomRightRadius = 4;

        // Top row: Port name and remove button
        var topRow = new VisualElement();
        topRow.style.flexDirection = FlexDirection.Row;
        topRow.style.justifyContent = Justify.SpaceBetween;
        topRow.style.alignItems = Align.Center;
        topRow.style.marginBottom = 8;

        var nameField = new TextField("Name") { value = variant.PortName };
        nameField.style.flexGrow = 1;
        nameField.style.marginRight = 10;
        nameField.RegisterValueChangedCallback(evt =>
        {
            variant.PortName = evt.newValue;
            UpdatePortName(variant);
        });

        var removeButton = new Button(() =>
        {
            // Don't remove if it's the last variant
            if (variantElements.Count <= 1)
            {
                EditorUtility.DisplayDialog("Cannot Remove", "At least one variant must remain.", "OK");
                return;
            }

            RemoveVariant(variant);
        })
        {
            text = "×",
            style = {
                width = 20,
                height = 20,
                fontSize = 12
            }
        };

        topRow.Add(nameField);
        topRow.Add(removeButton);

        // Bottom row: Weight controls
        var bottomRow = new VisualElement();
        bottomRow.style.flexDirection = FlexDirection.Row;
        bottomRow.style.alignItems = Align.Center;
        bottomRow.style.justifyContent = Justify.FlexStart;

        var weightLabel = new Label("Weight:");
        weightLabel.style.marginRight = 5;
        weightLabel.style.minWidth = 50;
        weightLabel.style.unityTextAlign = TextAnchor.MiddleLeft;

        var weightSlider = new Slider(0, 100);
        weightSlider.style.flexGrow = 1;
        weightSlider.style.marginRight = 10;
        weightSlider.value = variant.WeightPercent;

        var weightField = new FloatField() { value = variant.WeightPercent };
        weightField.style.width = 60;

        weightSlider.RegisterValueChangedCallback(evt =>
        {
            var newValue = Mathf.Clamp(evt.newValue, 0, 100);
            variant.WeightPercent = newValue;
            weightField.value = newValue;
            UpdateTotalWeight();
        });

        weightField.RegisterValueChangedCallback(evt =>
        {
            var newValue = Mathf.Clamp(evt.newValue, 0, 100);
            variant.WeightPercent = newValue;
            weightSlider.value = newValue;
            weightField.value = newValue;
            UpdateTotalWeight();
        });

        bottomRow.Add(weightLabel);
        bottomRow.Add(weightSlider);
        bottomRow.Add(weightField);

        container.Add(topRow);
        container.Add(bottomRow);
        variantsContainer.Add(container);

        // Create output port for this variant
        var port = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        port.portName = variant.PortName;
        outputContainer.Add(port);

        variantElements.Add(new BranchVariantElement
        {
            Data = variant,
            Container = container,
            Port = port,
            WeightField = weightField,
            WeightSlider = weightSlider,
            RemoveButton = removeButton,
            NameField = nameField
        });

        RefreshPorts();
        RefreshExpandedState();
    }

    private void UpdatePortName(RandomBranchVariant variant)
    {
        var element = variantElements.Find(v => v.Data == variant);
        if (element != null && element.Port != null)
        {
            element.Port.portName = variant.PortName;
            RefreshPorts();
        }
    }

    private void RemoveVariant(RandomBranchVariant variant)
    {
        var element = variantElements.Find(v => v.Data == variant);
        if (element != null)
        {
            // Remove port
            if (element.Port != null)
            {
                // Remove connections from this port
                var edgesToRemove = new List<Edge>();
                foreach (var edge in element.Port.connections)
                {
                    edgesToRemove.Add(edge);
                }

                var graphView = GetFirstAncestorOfType<DialogueGraphView>();
                foreach (var edge in edgesToRemove)
                {
                    graphView.RemoveElement(edge);
                }

                outputContainer.Remove(element.Port);
            }

            // Remove UI container
            variantsContainer.Remove(element.Container);
            variantElements.Remove(element);

            RefreshPorts();
            RefreshExpandedState();
            UpdateTotalWeight();
        }
    }

    private void UpdateTotalWeight()
    {
        float total = 0f;
        foreach (var element in variantElements)
        {
            total += element.Data.WeightPercent;
        }

        totalWeightLabel.text = $"Total: {total:F1}%";

        if (Mathf.Approximately(total, 100f))
        {
            totalWeightLabel.style.color = new StyleColor(Color.green);
        }
        else if (total > 100f)
        {
            totalWeightLabel.style.color = new StyleColor(Color.red);
        }
        else
        {
            totalWeightLabel.style.color = new StyleColor(Color.yellow);
        }
    }

    public List<RandomBranchVariant> GetVariants()
    {
        return variantElements.ConvertAll(v => v.Data);
    }

    public void LoadVariants(List<RandomBranchVariant> variants)
    {
        // Clear before loading
        foreach (var element in variantElements.ToArray())
        {
            RemoveVariant(element.Data);
        }

        foreach (var v in variants)
        {
            var variant = new RandomBranchVariant { PortName = v.PortName, WeightPercent = v.WeightPercent };
            CreateVariantUI(variant);
        }
        UpdateTotalWeight();
    }

    [System.Serializable]
    private class RandomBranchNodeSerializedData
    {
        public List<BranchVariantSerialized> Variants = new List<BranchVariantSerialized>();
    }

    [System.Serializable]
    private class BranchVariantSerialized
    {
        public string PortName;
        public float WeightPercent;
    }

    public override string SerializeNodeData()
    {
        var data = new RandomBranchNodeSerializedData();

        foreach (var element in variantElements)
        {
            data.Variants.Add(new BranchVariantSerialized
            {
                PortName = element.Data.PortName,
                WeightPercent = element.Data.WeightPercent
            });
        }

        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<RandomBranchNodeSerializedData>(jsonData);

        // Преобразуем сериализованные данные в варианты
        var variants = new List<RandomBranchVariant>();
        foreach (var variantData in data.Variants)
        {
            variants.Add(new RandomBranchVariant
            {
                PortName = variantData.PortName,
                WeightPercent = variantData.WeightPercent
            });
        }

        LoadVariants(variants);
    }
}

//==== File 51 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\SpeechNode.cs ====
// Assets/Scripts/Editor/DialogueGraph/Nodes/SpeechNode.cs
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEditor.UIElements;

/// <summary>
/// Базовый узел речи NPC — позволяет выбирать спикера из выпадающего списка персонажей из Resources/Characters
/// </summary>
public class SpeechNode : BaseNode
{
    public string DialogueText { get; set; }
    public AudioClip AudioClip { get; set; }
    public CharacterData Speaker;

    protected TextField dialogueTextField;
    protected ObjectField audioField;
    public ObjectField speakerField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Speech Node";
        DialogueText = "New Dialogue";
        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);
        // Output port - ИЗМЕНЕНО: capacity с Single на Multi
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Multi, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);
        // Dialogue text
        dialogueTextField = new TextField("Dialogue Text:");
        dialogueTextField.multiline = true;
        dialogueTextField.RegisterValueChangedCallback(evt => DialogueText = evt.newValue);
        dialogueTextField.SetValueWithoutNotify(DialogueText);
        mainContainer.Add(dialogueTextField);
        // Audio clip
        audioField = new ObjectField("Audio Clip") { objectType = typeof(AudioClip) };
        audioField.RegisterValueChangedCallback(evt => AudioClip = evt.newValue as AudioClip);
        mainContainer.Add(audioField);
        // Speaker drag-and-drop field
        speakerField = new ObjectField("Speaker") { objectType = typeof(CharacterData) };
        speakerField.RegisterValueChangedCallback(evt =>
        {
            Speaker = evt.newValue as CharacterData;
        });
        mainContainer.Add(speakerField);
        RefreshExpandedState();
        RefreshPorts();
        styleSheets.Add(Resources.Load<StyleSheet>("DefNode"));
    }

    public void SetSpeaker(CharacterData speaker)
    {
        Speaker = speaker;
        if (speakerField != null)
            speakerField.SetValueWithoutNotify(speaker);
    }

    public virtual void SetDialogueText(string text)
    {
        DialogueText = text;
        if (dialogueTextField != null)
            dialogueTextField.SetValueWithoutNotify(text);
    }

    public override string SerializeNodeData()
    {
        return null;
    }

    public override void DeserializeNodeData(string jsonData)
    {
        // десериализация данных из JSON в узел
    }
}

//==== File 52 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\SpeechNodeAudio.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;

public class SpeechNodeAudio : SpeechNode
{
    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Speech (Audio)";

        // ������� ��������� ����
        if (dialogueTextField != null)
        {
            mainContainer.Remove(dialogueTextField);
            dialogueTextField = null;
            DialogueText = string.Empty;
        }

        // ������������� ����
        styleSheets.Add(Resources.Load<StyleSheet>("SpeechNodeAudio"));
    }
}

//==== File 53 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\SpeechNodeImage.cs ====
// Assets/Scripts/Editor/DialogueGraph/Nodes/SpeechNodeImage.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;

public class SpeechNodeImage : SpeechNode
{
    public Sprite ImageSprite { get; set; }
    public ObjectField imageField;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Speech (Image)";

        if (dialogueTextField != null)
        {
            mainContainer.Remove(dialogueTextField);
            dialogueTextField = null;
            DialogueText = string.Empty;
        }
        if (audioField != null)
        {
            mainContainer.Remove(audioField);
            audioField = null;
            AudioClip = null;
        }

        // Инициализируем поле класса
        imageField = new ObjectField("Image Sprite");
        imageField.objectType = typeof(Sprite);
        imageField.RegisterValueChangedCallback(evt =>
        {
            ImageSprite = evt.newValue as Sprite;
        });
        mainContainer.Add(imageField);

        styleSheets.Add(Resources.Load<StyleSheet>("SpeechNodeImage"));
    }
}

//==== File 54 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\SpeechNodeRandText.cs ====
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.UIElements;

public class SpeechNodeRandText : BaseNode
{
    public CharacterData Speaker;
    private ObjectField speakerField;
    private VisualElement variantsContainer;
    public List<SpeechVariantElement> variantElements = new List<SpeechVariantElement>();

    private Label totalWeightLabel;

    public class SpeechVariantElement
    {
        public SpeechVariant Data;
        public VisualElement Container;
        public Label PreviewLabel;
        public FloatField WeightField;
        public Button RemoveButton;
        public Slider WeightSlider;
        public VisualElement controlsContainer;
    }

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Speech Rand (Text)";

        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Multi, typeof(float));
        outputPort.portName = "Next";
        outputContainer.Add(outputPort);

        speakerField = new ObjectField("Speaker") { objectType = typeof(CharacterData) };
        speakerField.RegisterValueChangedCallback(evt => Speaker = evt.newValue as CharacterData);
        mainContainer.Add(speakerField);

        // Заголовок для секции вариантов
        var variantsHeader = new VisualElement();
        variantsHeader.style.flexDirection = FlexDirection.Row;
        variantsHeader.style.justifyContent = Justify.SpaceBetween;
        variantsHeader.style.marginBottom = 10;

        var variantsTitle = new Label("Variants (Weighted Random)");
        variantsTitle.style.unityFontStyleAndWeight = FontStyle.Bold;

        totalWeightLabel = new Label("Total: 0%");
        totalWeightLabel.style.color = new StyleColor(Color.gray);

        variantsHeader.Add(variantsTitle);
        variantsHeader.Add(totalWeightLabel);
        mainContainer.Add(variantsHeader);

        variantsContainer = new VisualElement();
        mainContainer.Add(variantsContainer);

        var addButton = new Button(AddVariant) { text = "Add Variant" };
        addButton.style.marginTop = 5;
        mainContainer.Add(addButton);

        RefreshExpandedState();
        RefreshPorts();

        UpdateTotalWeight();

        // Устанавливаем фиксированную ширину узла
        SetPosition(new Rect(position, new Vector2(300, 200)));
    }

    private void AddVariant()
    {
        var variant = new SpeechVariant { Text = "", WeightPercent = 10f };
        CreateVariantUI(variant);
        UpdateTotalWeight();
    }

    private void CreateVariantUI(SpeechVariant variant)
    {
        var container = new VisualElement();
        container.style.flexDirection = FlexDirection.Column;
        container.style.marginBottom = 12;

        container.style.paddingTop = 8;
        container.style.paddingBottom = 8;
        container.style.paddingLeft = 8;
        container.style.paddingRight = 8;

        container.style.backgroundColor = new StyleColor(new Color(0.1f, 0.1f, 0.1f, 0.2f));

        container.style.borderTopLeftRadius = 4;
        container.style.borderTopRightRadius = 4;
        container.style.borderBottomLeftRadius = 4;
        container.style.borderBottomRightRadius = 4;

        // Верхняя строка: превью текста и кнопки
        var topRow = new VisualElement();
        topRow.style.flexDirection = FlexDirection.Row;
        topRow.style.justifyContent = Justify.SpaceBetween;
        topRow.style.alignItems = Align.FlexStart;
        topRow.style.marginBottom = 8;

        // Превью текста (занимает всё доступное пространство)
        var previewContainer = new VisualElement();
        previewContainer.style.flexGrow = 1;
        previewContainer.style.marginRight = 10;
        previewContainer.style.maxWidth = 200; // Ограничиваем ширину текста

        var previewLabel = new Label(string.IsNullOrEmpty(variant.Text) ? "(empty)" : variant.Text)
        {
            style = {
                whiteSpace = WhiteSpace.Normal,
                fontSize = 11,
                unityTextAlign = TextAnchor.UpperLeft,
                overflow = Overflow.Visible
            }
        };

        previewContainer.Add(previewLabel);

        // Контейнер для кнопок (редактировать и удалить)
        var buttonsContainer = new VisualElement();
        buttonsContainer.style.flexDirection = FlexDirection.Row;
        buttonsContainer.style.alignItems = Align.Center;

        // Кнопка редактирования текста
        var editButton = new Button(() => OpenTextEditor(variant, previewLabel))
        {
            text = "✎",
            style = {
                width = 24,
                height = 20,
                fontSize = 10,
                marginRight = 5
            }
        };

        // Кнопка удаления
        var removeButton = new Button(() =>
        {
            variantsContainer.Remove(container);
            variantElements.RemoveAll(v => v.Container == container);
            UpdateTotalWeight();
        })
        {
            text = "×",
            style = {
                width = 20,
                height = 20,
                fontSize = 12
            }
        };

        buttonsContainer.Add(editButton);
        buttonsContainer.Add(removeButton);

        topRow.Add(previewContainer);
        topRow.Add(buttonsContainer);

        // Нижняя строка: управление весом
        var bottomRow = new VisualElement();
        bottomRow.style.flexDirection = FlexDirection.Row;
        bottomRow.style.alignItems = Align.Center;
        bottomRow.style.justifyContent = Justify.FlexStart;

        var weightLabel = new Label("Weight:");
        weightLabel.style.marginRight = 5;
        weightLabel.style.minWidth = 50;
        weightLabel.style.unityTextAlign = TextAnchor.MiddleLeft;

        // Слайдер для веса
        var weightSlider = new Slider(0, 100);
        weightSlider.style.flexGrow = 1;
        weightSlider.style.marginRight = 10;
        weightSlider.value = variant.WeightPercent;

        // Поле для точного ввода веса
        var weightField = new FloatField() { value = variant.WeightPercent };
        weightField.style.width = 60;

        weightSlider.RegisterValueChangedCallback(evt =>
        {
            var newValue = Mathf.Clamp(evt.newValue, 0, 100);
            variant.WeightPercent = newValue;
            weightField.value = newValue;
            UpdateTotalWeight();
        });

        weightField.RegisterValueChangedCallback(evt =>
        {
            var newValue = Mathf.Clamp(evt.newValue, 0, 100);
            variant.WeightPercent = newValue;
            weightSlider.value = newValue;
            weightField.value = newValue;
            UpdateTotalWeight();
        });

        bottomRow.Add(weightLabel);
        bottomRow.Add(weightSlider);
        bottomRow.Add(weightField);

        container.Add(topRow);
        container.Add(bottomRow);

        variantsContainer.Add(container);

        variantElements.Add(new SpeechVariantElement
        {
            Data = variant,
            Container = container,
            PreviewLabel = previewLabel,
            WeightField = weightField,
            WeightSlider = weightSlider,
            RemoveButton = removeButton,
            controlsContainer = bottomRow
        });
    }

    private void OpenTextEditor(SpeechVariant variant, Label previewLabel)
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null) return;

        graphView.OpenTextEditor(variant.Text, GUID, newText =>
        {
            variant.Text = newText;
            previewLabel.text = string.IsNullOrEmpty(newText) ? "(empty)" : newText;
        });
    }

    private void UpdateTotalWeight()
    {
        float total = 0f;
        foreach (var element in variantElements)
        {
            total += element.Data.WeightPercent;
        }

        totalWeightLabel.text = $"Total: {total:F1}%";

        if (Mathf.Approximately(total, 100f))
        {
            totalWeightLabel.style.color = new StyleColor(Color.green);
        }
        else if (total > 100f)
        {
            totalWeightLabel.style.color = new StyleColor(Color.red);
        }
        else
        {
            totalWeightLabel.style.color = new StyleColor(Color.yellow);
        }
    }

    public List<SpeechVariant> GetVariants()
    {
        return variantElements.ConvertAll(v => v.Data);
    }

    public void SetSpeaker(CharacterData speaker)
    {
        Speaker = speaker;
        if (speakerField != null)
            speakerField.SetValueWithoutNotify(speaker);
    }

    public void LoadVariants(List<SpeechVariant> variants)
    {
        // Очистка перед загрузкой
        variantsContainer.Clear();
        variantElements.Clear();

        foreach (var v in variants)
        {
            var variant = new SpeechVariant { Text = v.Text, WeightPercent = v.WeightPercent };
            CreateVariantUI(variant);
        }
        UpdateTotalWeight();
    }

    [System.Serializable]
    private class SpeechNodeRandTextSerializedData
    {
        public string SpeakerGuid;
        public List<SpeechVariantSerialized> Variants = new List<SpeechVariantSerialized>();
    }

    [System.Serializable]
    private class SpeechVariantSerialized
    {
        public string Text;
        public float WeightPercent;
    }

    public override string SerializeNodeData()
    {
        string speakerGuid = string.Empty;
        if (Speaker != null)
        {
            speakerGuid = AssetDatabaseHelper.GetAssetGuid(Speaker);
        }

        var data = new SpeechNodeRandTextSerializedData
        {
            SpeakerGuid = speakerGuid
        };

        // Сериализация вариантов
        foreach (var element in variantElements)
        {
            data.Variants.Add(new SpeechVariantSerialized
            {
                Text = element.Data.Text,
                WeightPercent = element.Data.WeightPercent
            });
        }

        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<SpeechNodeRandTextSerializedData>(jsonData);

        // Загрузка спикера
        if (!string.IsNullOrEmpty(data.SpeakerGuid))
        {
            Speaker = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(data.SpeakerGuid);
            if (speakerField != null)
            {
                speakerField.SetValueWithoutNotify(Speaker);
            }
        }

        // Загрузка вариантов
        var variants = new List<SpeechVariant>();
        foreach (var variantData in data.Variants)
        {
            variants.Add(new SpeechVariant
            {
                Text = variantData.Text,
                WeightPercent = variantData.WeightPercent
            });
        }

        LoadVariants(variants);
    }
}

//==== File 55 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\SpeechNodeText.cs ====
// Assets/Scripts/Editor/DialogueGraph/Nodes/SpeechNodeText.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEditor.Experimental.GraphView;

public class SpeechNodeText : SpeechNode
{
    private Label _previewLabel;
    private Button _editButton;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Speech (Text)";

        // Удаляем стандартное текстовое поле
        if (dialogueTextField != null)
        {
            mainContainer.Remove(dialogueTextField);
            dialogueTextField = null;
        }

        // Создаём превью-лейбл с поддержкой роста по высоте
        _previewLabel = new Label(DialogueText)
        {
            style =
            {
                whiteSpace = WhiteSpace.Normal,
                overflow = Overflow.Visible, // ← Важно: не Hidden!
                flexGrow = 1,
                flexShrink = 0,
                alignSelf = Align.Stretch
            }
        };
        _previewLabel.AddToClassList("speech-text-preview");

        // Кнопка редактирования
        _editButton = new Button(OpenTextEditor) { text = "✎" };
        _editButton.style.position = Position.Absolute;
        _editButton.style.top = 2;
        _editButton.style.right = 2;
        _editButton.style.width = 24;
        _editButton.style.height = 20;
        _editButton.style.fontSize = 10;

        mainContainer.Add(_previewLabel);
        titleContainer.Add(_editButton);

        // Убираем аудио-поле
        if (audioField != null)
        {
            mainContainer.Remove(audioField);
            audioField = null;
            AudioClip = null;
        }

        styleSheets.Add(Resources.Load<StyleSheet>("SpeechNodeText"));

        // Подписываемся на изменение геометрии, чтобы обновлять высоту узла
        _previewLabel.RegisterCallback<GeometryChangedEvent>(OnPreviewLabelResized);

        SetupDoubleClickHandler();
    }


    private void SetupDoubleClickHandler()
    {
        this.RegisterCallback<PointerDownEvent>(OnPointerDown, TrickleDown.TrickleDown);
        this.RegisterCallback<MouseMoveEvent>(OnMouseMove, TrickleDown.TrickleDown);

        // Помечаем интерактивные элементы, которые не должны реагировать на двойной клик
        if (_editButton != null)
            _editButton.AddToClassList("no-double-click");
    }

    private void OnPointerDown(PointerDownEvent evt)
    {
        // Проверяем, что это двойной клик
        if (evt.clickCount != 2) return;

        // Проверяем, что клик не попал на интерактивные элементы
        var target = evt.target as VisualElement;
        while (target != null)
        {
            if (target.ClassListContains("no-double-click"))
                return;
            target = target.parent;
        }

        // Открываем редактор текста
        OpenTextEditor();

        // Предотвращаем распространение события
        evt.StopPropagation();
    }

    private void OnMouseMove(MouseMoveEvent evt)
    {
        var target = evt.target as VisualElement;
        while (target != null)
        {
            if (target.ClassListContains("no-double-click"))
            {
                this.style.cursor = StyleKeyword.Auto;
                return;
            }
            target = target.parent;
        }
    }
    private void OnPreviewLabelResized(GeometryChangedEvent evt)
    {
        // Обновляем высоту узла на основе содержимого
        var contentHeight = _previewLabel.layout.height;
        var minHeight = 80f; // минимум для заголовка + отступов
        var newHeight = Mathf.Max(minHeight, contentHeight + 60); // + отступы и кнопка

        var rect = GetPosition();
        rect.height = newHeight;
        SetPosition(rect);
    }

    private void OpenTextEditor()
    {
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView == null)
        {
            Debug.LogWarning("SpeechNodeText: DialogueGraphView not found. Cannot open text editor.");
            return;
        }

        graphView.OpenTextEditor(DialogueText, GUID, newText =>
        {
            DialogueText = newText;
            _previewLabel.text = DialogueText;
        });
    }

    public override void SetDialogueText(string text)
    {
        DialogueText = text ?? "";
        if (_previewLabel != null)
            _previewLabel.text = DialogueText;
    }

    [System.Serializable]
    private class SpeechNodeTextData
    {
        public string DialogueText;
        public string SpeakerGuid;
        // Другие необходимые поля
    }

    [System.Serializable]
    private class SpeechNodeTextSerializedData
    {
        public string DialogueText;
        public string SpeakerGuid;
    }

    public override string SerializeNodeData()
    {
        string speakerGuid = string.Empty;
        if (Speaker != null)
        {
            speakerGuid = AssetDatabaseHelper.GetAssetGuid(Speaker);
        }

        var data = new SpeechNodeTextSerializedData
        {
            DialogueText = DialogueText,
            SpeakerGuid = speakerGuid
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<SpeechNodeTextSerializedData>(jsonData);
        DialogueText = data.DialogueText;

        // Загрузка спикера по GUID
        if (!string.IsNullOrEmpty(data.SpeakerGuid))
        {
            Speaker = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(data.SpeakerGuid);
        }

        // Обновление UI
        _previewLabel.text = DialogueText;
        if (speakerField != null)
        {
            speakerField.SetValueWithoutNotify(Speaker);
        }
    }
}

//==== File 56 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\StringConditionNode.cs ====
using System.Collections.Generic;
using UnityEngine.UIElements;
using System.Linq;
using UnityEngine;
using DialogueSystem;
using System;

public class StringConditionNode : BaseConditionNode, IPropertyNode
{
    public string SelectedProperty;
    public StringComparisonType Comparison;
    public string CompareValue;

    private DropdownField propertyDropdown;
    private DropdownField comparisonDropdown;
    private TextField valueField;

    public enum StringComparisonType
    {
        Equal,
        NotEqual,
        IsNullOrEmpty
    }

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Condition (String)";

        // Property dropdown
        propertyDropdown = new DropdownField("Property");
        propertyDropdown.choices = new List<string>();
        propertyDropdown.RegisterValueChangedCallback(evt =>
        {
            SelectedProperty = evt.newValue;
        });
        mainContainer.Add(propertyDropdown);

        // Comparison dropdown
        comparisonDropdown = new DropdownField("Comparison");
        comparisonDropdown.choices = System.Enum.GetNames(typeof(StringComparisonType)).ToList();
        comparisonDropdown.RegisterValueChangedCallback(evt =>
        {
            Comparison = (StringComparisonType)System.Enum.Parse(typeof(StringComparisonType), evt.newValue);
            valueField.SetEnabled(Comparison != StringComparisonType.IsNullOrEmpty);
        });
        mainContainer.Add(comparisonDropdown);

        // Value field
        valueField = new TextField("Value");
        valueField.RegisterValueChangedCallback(evt => CompareValue = evt.newValue);
        mainContainer.Add(valueField);

        // ���������� ����������� ������ ������� ��� ���������� ���� � ������
        this.RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
    }

    private void OnAttachToPanel(AttachToPanelEvent evt)
    {
        // ������ ���� �������� � ���� � ����� �������� ������ � DialogueGraphView
        RefreshPropertyDropdown();
        this.UnregisterCallback<AttachToPanelEvent>(OnAttachToPanel);
    }

    /// <summary>
    /// ������������� ��������� ������ ���� �� ������������� UI.
    /// ������������ ��� �������� ����������� �������.
    /// </summary>
    public void SetInitialData(string property, StringComparisonType comparison, string value)
    {
        SelectedProperty = property;
        Comparison = comparison;
        CompareValue = value;
    }

    public void RefreshPropertyDropdown()
    {
        propertyDropdown.RegisterValueChangedCallback(evt =>
        {
            SelectedProperty = evt.newValue;
        });

        // �������� �������� �� �����
        var graphView = GetFirstAncestorOfType<DialogueGraphView>();
        if (graphView != null && propertyDropdown != null)
        {
            propertyDropdown.choices = graphView.StringExposedProperties
                .Where(p => p != null)
                .Select(p => p.PropertyName)
                .ToList();

            // ���� ���� ��������, �������� ������ �� ���������
            if (propertyDropdown.choices.Count > 0 && string.IsNullOrEmpty(SelectedProperty))
            {
                propertyDropdown.value = propertyDropdown.choices[0];
                SelectedProperty = propertyDropdown.choices[0];
            }
            else if (!string.IsNullOrEmpty(SelectedProperty))
            {
                propertyDropdown.value = SelectedProperty;
            }
        }
    }

    /// <summary>
    /// ��������� UI-�������� �� ������ ������� �������� �����.
    /// �������� ����� �������� ������ � ���������� ���� � ����.
    /// </summary>
    public void UpdateUIFromData()
    {
        if (propertyDropdown != null && comparisonDropdown != null && valueField != null)
        {
            propertyDropdown.value = SelectedProperty;
            comparisonDropdown.value = Comparison.ToString();
            valueField.value = CompareValue;
            valueField.SetEnabled(Comparison != StringComparisonType.IsNullOrEmpty);
        }
    }

    [System.Serializable]
    private class StringConditionNodeSerializedData
    {
        public string SelectedProperty;
        public string Comparison;
        public string CompareValue;
    }

    public override string SerializeNodeData()
    {
        var data = new StringConditionNodeSerializedData
        {
            SelectedProperty = SelectedProperty,
            Comparison = Comparison.ToString(),
            CompareValue = CompareValue
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<StringConditionNodeSerializedData>(jsonData);
        SelectedProperty = data.SelectedProperty;
        Comparison = (StringComparisonType)Enum.Parse(typeof(StringComparisonType), data.Comparison);
        CompareValue = data.CompareValue;

        // �������������� UI
        RefreshPropertyDropdown();
        UpdateUIFromData();
    }
}

//==== File 57 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\TimerNode.cs ====
// Assets/Scripts/Editor/DialogueGraph/Nodes/TimerNode.cs
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;
using UnityEngine;

public class TimerNode : BaseNode
{
    public float DurationSeconds = 5.0f;
    private Slider _durationSlider;
    private Label _valueLabel;

    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);
        title = "Timer";

        // Input port
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Single, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Output ports
        var optionsPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Multi, typeof(float));
        optionsPort.portName = "Options";
        outputContainer.Add(optionsPort);

        var timeoutPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        timeoutPort.portName = "Timeout";
        outputContainer.Add(timeoutPort);

        // Slider for duration
        _durationSlider = new Slider(0.1f, 60.0f)
        {
            value = DurationSeconds,
            showInputField = true
        };
        _durationSlider.RegisterValueChangedCallback(evt =>
        {
            DurationSeconds = evt.newValue;
            UpdateLabel();
        });

        // Value label
        _valueLabel = new Label();
        UpdateLabel();

        mainContainer.Add(_durationSlider);
        mainContainer.Add(_valueLabel);

        RefreshExpandedState();
        RefreshPorts();
    }

    private void UpdateLabel()
    {
        _valueLabel.text = $"{DurationSeconds:F2} sec";
    }

    public void SetDuration(float duration)
    {
        DurationSeconds = Mathf.Clamp(duration, 0.1f, 60.0f);
        _durationSlider.value = DurationSeconds;
        UpdateLabel();
    }

    [System.Serializable]
    private class TimerNodeSerializedData
    {
        public float DurationSeconds;
    }

    public override string SerializeNodeData()
    {
        var data = new TimerNodeSerializedData
        {
            DurationSeconds = DurationSeconds
        };
        return JsonUtility.ToJson(data);
    }

    public override void DeserializeNodeData(string jsonData)
    {
        var data = JsonUtility.FromJson<TimerNodeSerializedData>(jsonData);
        SetDuration(data.DurationSeconds);
    }
}

//==== File 58 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Nodes\WireNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine;

public class WireNode : BaseNode
{
    public override void Initialize(Vector2 position)
    {
        title = ""; // ��� ���������
        GUID = System.Guid.NewGuid().ToString();
        SetPosition(new Rect(position, new Vector2(30, 30))); // ����������� ������

        // Input (Multi)
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // Output (Single)
        var outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        outputPort.portName = "Output";
        outputContainer.Add(outputPort);

        // ���������
        capabilities |= Capabilities.Movable;
        capabilities |= Capabilities.Deletable;

        RefreshExpandedState();
        RefreshPorts();
    }

    public override string SerializeNodeData()
    {
        // WireNode �� ����� �������������� ������
        return "{}";
    }

    public override void DeserializeNodeData(string jsonData)
    {
        // WireNode �� ����� �������������� ������ ��� ��������������
    }
}

//==== File 59 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\ContextualDeleteCommand.cs ====
using System.Collections.Generic;
using System.Linq;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

public class ContextualDeleteCommand : GraphCommand
{
    private List<ISelectable> _nodesToDelete;
    private List<Edge> _edgesToDelete;
    // ��� Undo
    private Dictionary<string, Vector2> _nodePositions = new Dictionary<string, Vector2>();
    private List<NodeLinkData> _edgeConnections = new List<NodeLinkData>();
    private Dictionary<string, WireNodeConnectionData> _wireNodeConnections = new Dictionary<string, WireNodeConnectionData>();
    private Dictionary<ISelectable, string> _elementGuids = new Dictionary<ISelectable, string>();
    private List<string> _deletedNodeGuids = new List<string>();
    private List<string> _deletedEdgeGuids = new List<string>();

    [System.Serializable]
    public class WireNodeConnectionData
    {
        public Vector2 Position;
        public List<string> ConnectedInputGuids = new List<string>();
        public List<string> ConnectedOutputGuids = new List<string>();
    }

    public ContextualDeleteCommand(DialogueGraphView graphView, List<ISelectable> nodesToDelete, List<Edge> edgesToDelete)
        : base(graphView)
    {
        _nodesToDelete = nodesToDelete;
        _edgesToDelete = edgesToDelete;
    }

    public override void Execute()
    {
        // ��������� ���������� ��� ������
        SaveStateForUndo();

        // ������� ����� �������
        foreach (var edge in _edgesToDelete.Distinct().ToList())
        {
            DeleteEdge(edge);
            _deletedEdgeGuids.Add(edge.GetHashCode().ToString());
        }

        // ������� ����
        foreach (var element in _nodesToDelete)
        {
            if (element is BaseNode node)
            {
                // ��������� WireNode
                if (node is WireNode wireNode)
                {
                    RemoveWireNode(wireNode);
                    _deletedNodeGuids.Add(wireNode.GUID);
                    continue;
                }

                // ������������� ������� ��� ����������, ��������� � ��������� �����
                var edgesToRemove = graphView.edges
                    .Where(e => e.output?.node == node || e.input?.node == node)
                    .ToList();

                foreach (var edge in edgesToRemove)
                {
                    if (edge != null && !_edgesToDelete.Contains(edge))
                    {
                        DeleteEdge(edge);
                        _deletedEdgeGuids.Add(edge.GetHashCode().ToString());
                    }
                }

                // ������� ��� ����
                if (node.parent != null && !node.EntryPoint)
                {
                    graphView.RemoveElement(node);
                    _deletedNodeGuids.Add(node.GUID);
                }
            }
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }

    private void RemoveWireNode(WireNode wireNode)
    {
        // ������� ��� �������� � ��������� ����������
        var inputEdges = wireNode.inputContainer[0].Query<Edge>().ToList();
        var outputEdges = wireNode.outputContainer[0].Query<Edge>().ToList();

        // �������� ���������� ��� �������������� ��� ������
        var connectedInputs = inputEdges.Select(e => e.output.node).OfType<BaseNode>().Select(n => n.GUID).ToList();
        var connectedOutputs = outputEdges.Select(e => e.input.node).OfType<BaseNode>().Select(n => n.GUID).ToList();

        _wireNodeConnections[wireNode.GUID] = new WireNodeConnectionData
        {
            Position = wireNode.GetPosition().position,
            ConnectedInputGuids = connectedInputs,
            ConnectedOutputGuids = connectedOutputs
        };

        // ������� ��� �����, ��������� � ���� WireNode
        foreach (var edge in inputEdges.Concat(outputEdges).Distinct().ToList())
        {
            DeleteEdge(edge);
            _deletedEdgeGuids.Add(edge.GetHashCode().ToString());
        }

        // ������� ��� WireNode
        if (wireNode.parent != null)
        {
            graphView.RemoveElement(wireNode);
        }
    }

    private void SaveStateForUndo()
    {
        // ��������� ������� �����
        foreach (var element in _nodesToDelete)
        {
            if (element is BaseNode node && !(node is WireNode))
            {
                _nodePositions[node.GUID] = node.GetPosition().position;
                _elementGuids[element] = node.GUID;
            }
        }

        // ��������� ���������� ��� �����
        foreach (var edge in _edgesToDelete)
        {
            if (edge.output?.node is BaseNode outputNode && edge.input?.node is BaseNode inputNode)
            {
                _edgeConnections.Add(new NodeLinkData
                {
                    BaseNodeGuid = outputNode.GUID,
                    PortName = edge.output.portName,
                    TargetNodeGuid = inputNode.GUID
                });
            }
        }
    }

    private void DeleteEdge(Edge edge)
    {
        if (edge == null || edge.parent == null)
            return;

        edge.output?.Disconnect(edge);
        edge.input?.Disconnect(edge);
        graphView.RemoveElement(edge);
    }

    public override void Undo()
    {
        // ��������������� ����
        foreach (var kvp in _nodePositions)
        {
            var guid = kvp.Key;
            var position = kvp.Value;

            // �������� ����� ����������� ���� � ����
            var node = graphView.nodes.ToList().FirstOrDefault(n => n is BaseNode bn && bn.GUID == guid) as BaseNode;

            if (node == null)
            {
                Debug.LogWarning($"Node with GUID {guid} not found for undo operation");
                continue;
            }

            // ��������������� ������� ����
            node.SetPosition(new Rect(position, graphView.DefaultNodeSize));

            // ���� ���� ��� ������ �� ����� - ��������� ��� �������
            if (node.parent == null)
            {
                graphView.AddElement(node);
            }
        }

        // ��������������� WireNodes
        foreach (var connectionData in _wireNodeConnections)
        {
            var wireNode = new WireNode();
            wireNode.Initialize(connectionData.Value.Position);
            wireNode.GUID = connectionData.Key;
            graphView.AddElement(wireNode);
        }

        // ��������������� �����
        foreach (var connection in _edgeConnections)
        {
            var outputNode = graphView.nodes.ToList().FirstOrDefault(n => n is BaseNode bn && bn.GUID == connection.BaseNodeGuid) as BaseNode;
            var inputNode = graphView.nodes.ToList().FirstOrDefault(n => n is BaseNode bn && bn.GUID == connection.TargetNodeGuid) as BaseNode;

            if (outputNode == null || inputNode == null)
                continue;

            Port outputPort = null;
            Port inputPort = null;

            // ���� output ����
            foreach (Port port in outputNode.outputContainer.Children())
            {
                if (port.portName == connection.PortName)
                {
                    outputPort = port;
                    break;
                }
            }

            // ������� input ����
            if (inputNode.inputContainer.childCount > 0)
            {
                inputPort = inputNode.inputContainer[0] as Port;
            }

            // ������� � ��������� �����
            if (outputPort != null && inputPort != null)
            {
                var edge = new Edge { output = outputPort, input = inputPort };
                outputPort.Connect(edge);
                inputPort.Connect(edge);
                graphView.Add(edge);
            }
        }

        // ��������������� ���������� ��� WireNodes
        foreach (var connectionData in _wireNodeConnections)
        {
            var wireNode = graphView.nodes.ToList().FirstOrDefault(n => n is WireNode wn && wn.GUID == connectionData.Key) as WireNode;
            if (wireNode == null) continue;

            // ��������������� �������� ����������
            foreach (var inputGuid in connectionData.Value.ConnectedInputGuids)
            {
                var outputNode = graphView.nodes.ToList().FirstOrDefault(n => n is BaseNode bn && bn.GUID == inputGuid) as BaseNode;
                if (outputNode != null && wireNode.inputContainer.childCount > 0)
                {
                    var inputPort = wireNode.inputContainer[0] as Port;
                    var outputPort = outputNode.outputContainer.Children().OfType<Port>().FirstOrDefault();

                    if (outputPort != null && inputPort != null)
                    {
                        var edge = new Edge { output = outputPort, input = inputPort };
                        outputPort.Connect(edge);
                        inputPort.Connect(edge);
                        graphView.Add(edge);
                    }
                }
            }

            // ��������������� ��������� ����������
            foreach (var outputGuid in connectionData.Value.ConnectedOutputGuids)
            {
                var inputNode = graphView.nodes.ToList().FirstOrDefault(n => n is BaseNode bn && bn.GUID == outputGuid) as BaseNode;
                if (inputNode != null && wireNode.outputContainer.childCount > 0)
                {
                    var outputPort = wireNode.outputContainer[0] as Port;
                    var inputPort = inputNode.inputContainer.Children().OfType<Port>().FirstOrDefault();

                    if (outputPort != null && inputPort != null)
                    {
                        var edge = new Edge { output = outputPort, input = inputPort };
                        outputPort.Connect(edge);
                        inputPort.Connect(edge);
                        graphView.Add(edge);
                    }
                }
            }
        }

        // ��������������� ���������
        graphView.ClearSelection();
        foreach (var guid in _deletedNodeGuids)
        {
            var node = graphView.nodes.ToList().FirstOrDefault(n => n is BaseNode bn && bn.GUID == guid) as BaseNode;
            if (node != null)
            {
                graphView.AddToSelection(node);
            }
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }
}

//==== File 60 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\CreateConnectionCommand.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine;

public class CreateConnectionCommand : GraphCommand
{
    private Edge edge;
    private Port outputPort;
    private Port inputPort;

    public CreateConnectionCommand(DialogueGraphView graphView, Edge edge)
        : base(graphView)
    {
        this.edge = edge;
        this.outputPort = edge.output;
        this.inputPort = edge.input;
    }

    public override void Execute()
    {
        if (edge != null && edge.parent != null)
        {
            graphView.RemoveElement(edge);
            graphView.MarkUnsavedChangeWithoutFile();
        }
    }

    public override void Undo()
    {
        if (outputPort != null && inputPort != null)
        {
            Edge newEdge = new Edge { output = outputPort, input = inputPort };
            outputPort.Connect(newEdge);
            inputPort.Connect(newEdge);
            graphView.Add(newEdge);
            graphView.MarkUnsavedChangeWithoutFile();
        }
    }
}

//==== File 61 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\CreateNodeAndConnectionCommand.cs ====
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

public class CreateNodeAndConnectionCommand : GraphCommand
{
    private Type _nodeType;
    private Vector2 _position;
    private Port _outputPort;
    private BaseNode _createdNode;
    private Edge _createdEdge;
    private string _newGuid;
    private List<Edge> _edgesToRemove = new List<Edge>();

    public CreateNodeAndConnectionCommand(DialogueGraphView graphView, Type nodeType, Vector2 position, Port outputPort)
        : base(graphView)
    {
        _nodeType = nodeType;
        _position = position;
        _outputPort = outputPort;
        _newGuid = Guid.NewGuid().ToString();
    }

    public override void Execute()
    {
        // ���������� ��� ������������ ����
        bool isCreatingOptionNode = IsOptionNodeType(_nodeType);
        bool isCreatingSpeechNode = IsSpeechNodeType(_nodeType);

        // �������� ��� ������������ ���������� �����
        var existingConnections = _outputPort.connections.ToList();

        // ��� ������ � Single capacity ������� ��� ����������
        if (_outputPort.capacity == Port.Capacity.Single)
        {
            _edgesToRemove.AddRange(existingConnections);
        }
        else // ��� Multi capacity ������������ ��������� �� ����� �����
        {
            foreach (var edge in existingConnections)
            {
                var targetNode = edge.input?.node as BaseNode;
                if (targetNode == null) continue;

                bool isExistingOptionNode = IsOptionNode(targetNode);
                bool isExistingSpeechNode = IsSpeechNode(targetNode);

                // ���� ������� Speech node, � ������������ ���������� � Option node - �������
                if (isCreatingSpeechNode && isExistingOptionNode)
                {
                    _edgesToRemove.Add(edge);
                }
                // ���� ������� Option node, � ������������ ���������� � Speech node - �������
                else if (isCreatingOptionNode && isExistingSpeechNode)
                {
                    _edgesToRemove.Add(edge);
                }
                // ���� ������� Speech node, � ������������ ���������� ��� � ������ Speech - �������
                else if (isCreatingSpeechNode && isExistingSpeechNode)
                {
                    _edgesToRemove.Add(edge);
                }
            }
        }

        // ������� ��� ������������� ����������
        foreach (var edge in _edgesToRemove.Distinct().ToList())
        {
            if (edge != null)
            {
                _outputPort.Disconnect(edge);
                edge.input?.Disconnect(edge);
                if (edge.parent != null)
                {
                    graphView.RemoveElement(edge);
                }
            }
        }

        // ������� ����� ����
        _createdNode = NodeFactory.CreateNode(_nodeType, _position);
        if (_createdNode == null) return;
        _createdNode.GUID = _newGuid;
        graphView.AddElement(_createdNode);

        // ������� ����������
        if (_createdNode.inputContainer.childCount > 0)
        {
            Port inputPort = _createdNode.inputContainer[0] as Port;
            if (inputPort != null)
            {
                _createdEdge = new Edge { output = _outputPort, input = inputPort };
                _outputPort.Connect(_createdEdge);
                inputPort.Connect(_createdEdge);
                graphView.Add(_createdEdge);
            }
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }

    public override void Undo()
    {
        // ������� ����������
        if (_createdEdge != null && _createdEdge.parent != null)
        {
            _createdEdge.output?.Disconnect(_createdEdge);
            _createdEdge.input?.Disconnect(_createdEdge);
            graphView.RemoveElement(_createdEdge);
        }

        // ������� ����
        if (_createdNode != null && _createdNode.parent != null)
        {
            // ������� ��� ���������� ����
            var edgesToRemove = graphView.edges
                .Where(e => e.input.node == _createdNode || e.output.node == _createdNode)
                .ToList();
            foreach (var edge in edgesToRemove)
            {
                graphView.RemoveElement(edge);
            }
            graphView.RemoveElement(_createdNode);
        }

        // ��������������� ��������� ����������
        foreach (var edge in _edgesToRemove)
        {
            if (edge != null && edge.output != null && edge.input != null)
            {
                edge.output.Connect(edge);
                edge.input.Connect(edge);
                if (edge.parent == null)
                {
                    graphView.Add(edge);
                }
            }
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }

    // ��������������� ������ ��� ����������� ����� �����
    private static bool IsSpeechNodeType(Type nodeType)
    {
        return nodeType == typeof(SpeechNode) ||
               nodeType == typeof(SpeechNodeText) ||
               nodeType == typeof(SpeechNodeAudio) ||
               nodeType == typeof(SpeechNodeImage) ||
               nodeType == typeof(SpeechNodeRandText);
    }

    private static bool IsOptionNodeType(Type nodeType)
    {
        return nodeType == typeof(OptionNode) ||
               nodeType == typeof(OptionNodeText) ||
               nodeType == typeof(OptionNodeAudio) ||
               nodeType == typeof(OptionNodeImage);
    }

    private static bool IsSpeechNode(BaseNode node)
    {
        return node is SpeechNode ||
               node is SpeechNodeText ||
               node is SpeechNodeAudio ||
               node is SpeechNodeImage ||
               node is SpeechNodeRandText;
    }

    private static bool IsOptionNode(BaseNode node)
    {
        return node is OptionNode ||
               node is OptionNodeText ||
               node is OptionNodeAudio ||
               node is OptionNodeImage;
    }
}

//==== File 62 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\CreateNodeCommand.cs ====
using UnityEngine;
using System;
using System.Linq;

public class CreateNodeCommand : GraphCommand
{
    private BaseNode node;
    private Vector2 position;
    private Type nodeType;
    private string guid;

    public CreateNodeCommand(DialogueGraphView graphView, Type nodeType, Vector2 position)
        : base(graphView)
    {
        this.nodeType = nodeType;
        this.position = position;
        this.guid = Guid.NewGuid().ToString();
    }

    public override void Execute()
    {
        node = NodeFactory.CreateNode(nodeType, position);
        node.GUID = guid;
        graphView.AddElement(node);
        graphView.MarkUnsavedChangeWithoutFile();
    }

    public override void Undo()
    {
        if (node != null && node.parent != null)
        {
            // ������� ��� ����� ����
            var edgesToRemove = graphView.edges
                .Where(e => e.input.node == node || e.output.node == node)
                .ToList();

            foreach (var edge in edgesToRemove)
            {
                graphView.RemoveElement(edge);
            }

            graphView.RemoveElement(node);
            graphView.MarkUnsavedChangeWithoutFile();
        }
    }
}

//==== File 63 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\DeleteEdgeCommand.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine;

public class DeleteEdgeCommand : GraphCommand
{
    private Edge edge;
    private Port outputPort;
    private Port inputPort;

    public DeleteEdgeCommand(DialogueGraphView graphView, Edge edge) : base(graphView)
    {
        this.edge = edge;
        this.outputPort = edge.output;
        this.inputPort = edge.input;
    }

    public override void Execute()
    {
        if (edge != null && edge.parent != null)
        {
            graphView.RemoveElement(edge);
            graphView.MarkUnsavedChangeWithoutFile();
        }
    }

    public override void Undo()
    {
        if (outputPort != null && inputPort != null)
        {
            Edge newEdge = new Edge { output = outputPort, input = inputPort };
            outputPort.Connect(newEdge);
            inputPort.Connect(newEdge);
            graphView.Add(newEdge);
            graphView.MarkUnsavedChangeWithoutFile();
        }
    }
}

//==== File 64 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\DeleteElementCommand.cs ====
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEditor.Experimental.GraphView;
using System;
using DialogueSystem;

public class DeleteElementCommand : GraphCommand
{
    private ISelectable element;
    private Vector2 position;
    private System.Type elementType;
    private string guid;
    // ��������: ������ �������� ������ ��� NodeLinkData, ������ �������� Edge
    private List<Edge> connections = new List<Edge>();

    public DeleteElementCommand(DialogueGraphView graphView, ISelectable element)
        : base(graphView)
    {
        this.element = element;

        if (element is BaseNode node)
        {
            elementType = node.GetType();
            guid = node.GUID;
            position = node.GetPosition().position;

            // ��������� �������� ����� ������ ������ �� containerCache
            connections = graphView.edges
                .Where(e => e.input.node == node || e.output.node == node)
                .ToList();
        }
    }

    public override void Execute()
    {
        if (element is BaseNode node)
        {
            // ��������� ����� ����� ���������
            connections = graphView.edges
                .Where(e => e.input.node == node || e.output.node == node)
                .ToList();

            // ������� ��� ����� ����
            foreach (var edge in connections.ToList())
            {
                graphView.RemoveElement(edge);
            }

            graphView.RemoveElement(node);
        }
        else if (element is Edge edge)
        {
            graphView.RemoveElement(edge);
        }

        graphView.MarkUnsavedChangeWithoutFile();
    }

    public override void Undo()
    {
        if (elementType != null && typeof(BaseNode).IsAssignableFrom(elementType))
        {
            var node = NodeFactory.CreateNode(elementType, position);
            node.GUID = guid;
            graphView.AddElement(node);

            // ��������������� �����
            foreach (var edge in connections)
            {
                // ����������� ���� � BaseNode ��� ������� � GUID
                BaseNode edgeOutputNode = edge.output.node as BaseNode;
                BaseNode edgeInputNode = edge.input.node as BaseNode;

                // ����������, ���� �������������� �� �������
                if (edgeOutputNode == null || edgeInputNode == null)
                    continue;

                // ���� ��������������� ���� � ����� �� GUID
                var outputNode = graphView.nodes.ToList().FirstOrDefault(n =>
                    n is BaseNode bn && bn.GUID == edgeOutputNode.GUID);
                var inputNode = graphView.nodes.ToList().FirstOrDefault(n =>
                    n is BaseNode bn && bn.GUID == edgeInputNode.GUID);

                // ���������, ��� ����� ���� � ��� �������� BaseNode
                if (outputNode is BaseNode outputBaseNode &&
                    inputNode is BaseNode inputBaseNode)
                {
                    // ������� ��������������� �����
                    Port outputPort = FindPortByName(outputBaseNode, edge.output.portName);
                    Port inputPort = FindPortByName(inputBaseNode, edge.input.portName);

                    // ������� � ��������� ����� ����������
                    if (outputPort != null && inputPort != null)
                    {
                        var newEdge = new Edge
                        {
                            output = outputPort,
                            input = inputPort
                        };
                        outputPort.Connect(newEdge);
                        inputPort.Connect(newEdge);
                        graphView.Add(newEdge);
                    }
                }
            }
        }
        graphView.MarkUnsavedChangeWithoutFile();
    }

    private Port FindPortByName(BaseNode node, string portName)
    {
        return node.outputContainer.Children().OfType<Port>().FirstOrDefault(p => p.portName == portName) ??
               node.inputContainer.Children().OfType<Port>().FirstOrDefault(p => p.portName == portName);
    }
}

//==== File 65 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\GraphCommand.cs ====
public abstract class GraphCommand : ICommand
{
    protected DialogueGraphView graphView;

    public GraphCommand(DialogueGraphView graphView)
    {
        this.graphView = graphView;
    }

    public abstract void Execute();
    public abstract void Undo();
    public virtual void Redo() => Execute();
}

//==== File 66 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\ICommand.cs ====
public interface ICommand
{
    void Execute();
    void Undo();
    void Redo();
}


//==== File 67 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\UndoSystem\UndoManager.cs ====
public class UndoManager
{
    private readonly DialogueGraphView graphView;

    public UndoManager(DialogueGraphView graphView)
    {
        this.graphView = graphView;
    }

    // ��������� ������� �������� ��� ���������� ��� ������
    public void ExecuteCommand(ICommand command)
    {
        command.Execute();
    }

    // ��������� ���������������� ������
    public void Undo() { }

    // ��������� ���������������� �������
    public void Redo() { }

    // ������� ����� (���� ��� ������ �� ������������)
    public void ClearStacks() { }
}

//==== File 68 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Utilities\AssetDatabaseHelper.cs ====
using UnityEditor;
using UnityEngine;

public static class AssetDatabaseHelper
{
    public static string GetAssetGuid(Object asset)
    {
        if (asset == null) return string.Empty;
        return AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(asset));
    }

    public static T LoadAssetFromGuid<T>(string guid) where T : Object
    {
        if (string.IsNullOrEmpty(guid)) return null;
        string path = AssetDatabase.GUIDToAssetPath(guid);
        return AssetDatabase.LoadAssetAtPath<T>(path);
    }

    public static bool IsValidGuid(string guid)
    {
        if (string.IsNullOrEmpty(guid)) return false;
        string path = AssetDatabase.GUIDToAssetPath(guid);
        return !string.IsNullOrEmpty(path) && AssetDatabase.LoadAssetAtPath<Object>(path) != null;
    }
}


//==== File 69 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Utilities\DialogueValidator.cs ====
using UnityEngine;


public static class DialogueValidator
{
    public static void ValidateSpeechNodes(DialogueContainer container)
    {
        foreach (var nodeData in container.SpeechNodeDatas)
        {
            if (string.IsNullOrEmpty(nodeData.SpeakerGuid) ||
                !AssetDatabaseHelper.IsValidGuid(nodeData.SpeakerGuid))
            {
                Debug.LogError($"SpeechNode (GUID: {nodeData.Guid}) has no speaker assigned! Text: \"{nodeData.DialogueText}\"");
            }
        }
    }
}

//==== File 70 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Utilities\GraphSaveUtility.cs ====
using UnityEditor.Experimental.GraphView;
using System.Collections.Generic;
using UnityEngine.UIElements;
using System.Linq;
using UnityEngine;
using UnityEditor;
using System;
using UnityEngine.Events;

/// <summary>
/// Утилита для сохранения и загрузки диалоговых графов
/// </summary>
public class GraphSaveUtility
{
    private DialogueGraphView targetGraphView;
    private DialogueContainer containerCache;

    private List<BaseNode> GetNodes() => targetGraphView.nodes.ToList().Cast<BaseNode>().ToList();
    private List<Edge> GetEdges() => targetGraphView.edges.ToList();

    /// <summary>
    /// Получение экземпляра утилиты для сохранения
    /// </summary>
    public static GraphSaveUtility GetInstance(DialogueGraphView targetGraphView)
    {
        return new GraphSaveUtility { targetGraphView = targetGraphView };
    }

    #region Saving
    /// <summary>
    /// Сохранение графа в файл
    /// </summary>
    /// <summary>
    /// Сохранение графа в файл
    /// </summary>
    public void SaveGraph(string fileName)
    {
        DialogueSettingsData settings = LoadDialogueSettings();
        string savePath = null;

        // Сначала проверяем, включено ли автосохранение
        bool useAutoSave = false;
        if (settings != null && settings.General.enableAutoSaveLocation)
        {
            // Только если автосохранение включено, проверяем валидность пути
            if (!string.IsNullOrEmpty(settings.General.autoSaveFolderPath) &&
                settings.IsValidSavePath(settings.General.autoSaveFolderPath))
            {
                useAutoSave = true;
            }
        }

        if (useAutoSave)
        {
            string folderPath = settings.GetFullPath();
            savePath = System.IO.Path.Combine(folderPath, $"{fileName}.asset");
            savePath = savePath.Replace("\\", "/");
        }
        else
        {
            // Всегда показываем диалог выбора пути, если автосохранение отключено
            savePath = EditorUtility.SaveFilePanelInProject(
                "Save Dialogue",
                fileName,
                "asset",
                "Save dialogue asset"
            );
        }

        if (string.IsNullOrEmpty(savePath))
            return;

        // Создаем контейнер для данных диалога
        var dialogueContainer = ScriptableObject.CreateInstance<DialogueContainer>();
        // Сохраняем узлы и связи
        SaveNodes(dialogueContainer);
        // Сохраняем свойства черной доски
        SaveExposedProperties(dialogueContainer);
        // Сохраняем ассет
        AssetDatabase.CreateAsset(dialogueContainer, savePath);
        AssetDatabase.SaveAssets();
        EditorUtility.DisplayDialog("Success", $"Graph saved as {fileName}", "OK");
    }

    /// <summary>
    /// Сохраняет узлы в контейнер
    /// </summary>
    private void SaveNodes(DialogueContainer dialogueContainer)
    {
        dialogueContainer.BaseCharacterGuid = targetGraphView.BaseCharacterGuid;

        // Сохраняем связи между узлами
        var edgesList = targetGraphView.edges.ToList();
        var connectedPorts = edgesList.Where(x => x.input.node != null).ToArray();
        foreach (var edge in connectedPorts)
        {;
            var outputNode = edge.output.node as BaseNode;
            var inputNode = edge.input.node as BaseNode;
            dialogueContainer.NodeLinks.Add(new NodeLinkData
            {
                BaseNodeGuid = outputNode.GUID,
                PortName = edge.output.portName,
                TargetNodeGuid = inputNode.GUID
            });
        }

        // Сохраняем данные узлов
        foreach (var node in GetNodes())
        {
            if (node.EntryPoint)
            {
                dialogueContainer.EntryNodeData = new EntryNodeData
                {
                    Guid = node.GUID,
                    Position = node.GetPosition().position
                };
            }
            else if (node is SpeechNodeText speechNodeText)
            {
                dialogueContainer.SpeechNodeDatas.Add(new SpeechNodeData
                {
                    Guid = speechNodeText.GUID,
                    DialogueText = speechNodeText.DialogueText,
                    Position = node.GetPosition().position,
                    AudioClipGuid = "",
                    SpeakerGuid = speechNodeText.Speaker ? AssetDatabaseHelper.GetAssetGuid(speechNodeText.Speaker) : "",
                    SpeakerName = speechNodeText.Speaker ? speechNodeText.Speaker.name : "",
                    NodeType = "SpeechNodeText"
                });
            }
            else if (node is SpeechNodeAudio speechNodeAudio)
            {
                dialogueContainer.SpeechNodeDatas.Add(new SpeechNodeData
                {
                    Guid = speechNodeAudio.GUID,
                    DialogueText = "", // Аудио-ноды не используют текст
                    Position = node.GetPosition().position,
                    AudioClipGuid = speechNodeAudio.AudioClip ? AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(speechNodeAudio.AudioClip)) : "",
                    SpeakerGuid = speechNodeAudio.Speaker ? AssetDatabaseHelper.GetAssetGuid(speechNodeAudio.Speaker) : "",
                    NodeType = "SpeechNodeAudio"
                });
            }
            else if (node is SpeechNodeImage speechNodeImage)
            {
                dialogueContainer.SpeechNodeImageDatas.Add(new SpeechNodeImageData
                {
                    Guid = speechNodeImage.GUID,
                    Position = node.GetPosition().position,
                    ImageSpritePath = speechNodeImage.ImageSprite ? GetResourcePath(speechNodeImage.ImageSprite) : "",
                    ImageSpriteGuid = speechNodeImage.ImageSprite ? AssetDatabase.GetAssetPath(speechNodeImage.ImageSprite) : "",
                    SpeakerName = speechNodeImage.Speaker ? speechNodeImage.Speaker.name : "",
                    SpeakerGuid = speechNodeImage.Speaker ? AssetDatabaseHelper.GetAssetGuid(speechNodeImage.Speaker) : "",
                    NodeType = "SpeechNodeImage"
                });
            }
            else if (node is OptionNodeText optionNodeText)
            {
                dialogueContainer.OptionNodeDatas.Add(new OptionNodeData
                {
                    Guid = optionNodeText.GUID,
                    ResponseText = optionNodeText.ResponseText,
                    Position = node.GetPosition().position,
                    AudioClipGuid = "",
                    NodeType = "OptionNodeText"
                });
            }
            else if (node is OptionNodeAudio optionNodeAudio)
            {
                dialogueContainer.OptionNodeDatas.Add(new OptionNodeData
                {
                    Guid = optionNodeAudio.GUID,
                    ResponseText = "", // Аудио-опции не используют текст
                    Position = node.GetPosition().position,
                    AudioClipGuid = optionNodeAudio.AudioClip ? AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(optionNodeAudio.AudioClip)) : "",
                    NodeType = "OptionNodeAudio"
                });
            }
            else if (node is OptionNodeImage optionNodeImage)
            {
                dialogueContainer.OptionNodeImageDatas.Add(new OptionNodeImageData
                {
                    Guid = optionNodeImage.GUID,
                    Position = node.GetPosition().position,
                    ImageSpriteGuid = optionNodeImage.ImageSprite ? AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(optionNodeImage.ImageSprite)) : "",
                    NodeType = "OptionNodeImage"
                });
            }
            else if (node is IntConditionNode intConditionNode)
            {
                dialogueContainer.IntConditionNodeDatas.Add(new IntConditionNodeData
                {
                    Guid = intConditionNode.GUID,
                    Position = node.GetPosition().position,
                    SelectedProperty = intConditionNode.SelectedProperty,
                    Comparison = intConditionNode.Comparison,
                    CompareValue = intConditionNode.CompareValue
                });
            }
            else if (node is StringConditionNode stringConditionNode)
            {
                dialogueContainer.StringConditionNodeDatas.Add(new StringConditionNodeData
                {
                    Guid = stringConditionNode.GUID,
                    Position = node.GetPosition().position,
                    SelectedProperty = stringConditionNode.SelectedProperty,
                    Comparison = (DialogueSystem.StringComparisonType)stringConditionNode.Comparison,
                    CompareValue = stringConditionNode.CompareValue
                });
            }
            else if (node is ModifyIntNode modifyIntNode)
            {
                dialogueContainer.ModifyIntNodeDatas.Add(new ModifyIntNodeData
                {
                    Guid = modifyIntNode.GUID,
                    Position = node.GetPosition().position,
                    SelectedProperty = modifyIntNode.SelectedProperty,
                    Operator = modifyIntNode.Operator,
                    Value = modifyIntNode.Value
                });
            }
            else if (node is EndNode endNode)
            {
                dialogueContainer.EndNodeDatas.Add(new EndNodeData
                {
                    Guid = endNode.GUID,
                    Position = node.GetPosition().position,
                    NextDialogueName = endNode.GetNextDialoguePath()
                });
            }
            else if (node is EventNode eventNode)
            {
                dialogueContainer.EventNodeDatas.Add(new EventNodeData
                {
                    Guid = eventNode.GUID,
                    Position = node.GetPosition().position,
                    Event = eventNode.RuntimeEvent
                });
            }
            else if (node is CharacterIntConditionNode charIntCond)
            {
                dialogueContainer.CharacterIntConditionNodeDatas.Add(new CharacterIntConditionNodeData
                {
                    Guid = charIntCond.GUID,
                    Position = node.GetPosition().position,
                    CharacterName = charIntCond.CharacterName,
                    SelectedVariable = charIntCond.SelectedVariable,
                    Comparison = charIntCond.Comparison,
                    CompareValue = charIntCond.CompareValue
                });
            }
            else if (node is CharacterModifyIntNode charModify)
            {
                dialogueContainer.CharacterModifyIntNodeDatas.Add(new CharacterModifyIntNodeData
                {
                    Guid = charModify.GUID,
                    Position = node.GetPosition().position,
                    CharacterName = charModify.CharacterAsset ? charModify.CharacterAsset.name : "",
                    SelectedVariable = charModify.SelectedVariable,
                    Operator = charModify.Operator,
                    Value = charModify.Value
                });
            }
            else if (node is DebugLogNode debugLog)
            {
                dialogueContainer.DebugLogNodeDatas.Add(new DebugLogNodeData
                {
                    Guid = debugLog.GUID,
                    Position = node.GetPosition().position,
                    MessageText = debugLog.MessageText
                });
            }
            else if (node is DebugWarningNode debugWarn)
            {
                dialogueContainer.DebugWarningNodeDatas.Add(new DebugWarningNodeData
                {
                    Guid = debugWarn.GUID,
                    Position = node.GetPosition().position,
                    MessageText = debugWarn.MessageText
                });
            }
            else if (node is DebugErrorNode debugErr)
            {
                dialogueContainer.DebugErrorNodeDatas.Add(new DebugErrorNodeData
                {
                    Guid = debugErr.GUID,
                    Position = node.GetPosition().position,
                    MessageText = debugErr.MessageText
                });
            }
            else if (node is SpeechNodeRandText speechRandNode)
            {
                dialogueContainer.SpeechRandNodeDatas.Add(new SpeechRandNodeData
                {
                    Guid = speechRandNode.GUID,
                    Position = node.GetPosition().position,
                    SpeakerName = speechRandNode.Speaker ? speechRandNode.Speaker.name : "",
                    Variants = speechRandNode.GetVariants()
                });
            }
            else if (node is RandomBranchNode randomBranchNode)
            {
                dialogueContainer.RandomBranchNodeDatas.Add(new RandomBranchNodeData
                {
                    Guid = randomBranchNode.GUID,
                    Position = node.GetPosition().position,
                    Variants = randomBranchNode.GetVariants()
                });
            }
            else if (node is NoteNode noteNode)
            {
                dialogueContainer.NoteNodeDatas.Add(new NoteNodeData
                {
                    Guid = noteNode.GUID,
                    Position = node.GetPosition().position,
                    NoteText = noteNode.NoteText,
                    BackgroundColor = noteNode.BackgroundColor,
                    ConnectedNodeGuids = noteNode.ConnectedNodeGuids
                });
            }
            else if (node is TimerNode timerNode)
            {
                dialogueContainer.TimerNodeDatas.Add(new TimerNodeData
                {
                    Guid = timerNode.GUID,
                    Position = node.GetPosition().position,
                    DurationSeconds = timerNode.DurationSeconds
                });
            }
            else if (node is PauseNode pauseNode)
            {
                dialogueContainer.PauseNodeDatas.Add(new PauseNodeData
                {
                    Guid = pauseNode.GUID,
                    Position = node.GetPosition().position,
                    DurationSeconds = pauseNode.DurationSeconds
                });
            }
            else if (node is WireNode wireNode)
            {
                dialogueContainer.WireNodeDatas.Add(new WireNodeData
                {
                    Guid = wireNode.GUID,
                    Position = node.GetPosition().position
                });
            }
            else if (node is CharacterButtonPressNode charButtonPressNode)
            {
                dialogueContainer.CharacterButtonPressNodeDatas.Add(new CharacterButtonPressNodeData
                {
                    Guid = charButtonPressNode.GUID,
                    Position = node.GetPosition().position,
                    CharacterName = charButtonPressNode.CharacterAsset ? charButtonPressNode.CharacterAsset.name : "",
                    RequireButtonPress = charButtonPressNode.RequireButtonPress
                });
            }
        }
    }

    private string GetResourcePath(Sprite sprite)
    {
        if (sprite == null) return "";
        string path = AssetDatabase.GetAssetPath(sprite);
        if (!path.StartsWith("Assets/Resources/"))
        {
            Debug.LogError($"Sprite {sprite.name} must be in Assets/Resources!");
            return "";
        }
        path = path.Substring("Assets/Resources/".Length);
        if (path.LastIndexOf('.') > 0)
            path = path.Substring(0, path.LastIndexOf('.'));
        return path;
    }

    /// <summary>
    /// Сохранение свойств черной доски
    /// </summary>
    private void SaveExposedProperties(DialogueContainer dialogueContainer)
    {
        // Очистка старых данных
        dialogueContainer.ExposedProperties.Clear(); // для обратной совместимости, если используется
        dialogueContainer.IntExposedProperties.Clear();
        dialogueContainer.StringExposedProperties.Clear();

        // Сохранение актуальных данных
        dialogueContainer.IntExposedProperties.AddRange(targetGraphView.IntExposedProperties);
        dialogueContainer.StringExposedProperties.AddRange(targetGraphView.StringExposedProperties);
    }
    #endregion

    #region Loading
    /// <summary>
    /// Загрузка графа из файла
    /// </summary>
    public void LoadGraph(string fileName)
    {
        containerCache = Resources.Load<DialogueContainer>(fileName);
        if (containerCache == null)
        {
            EditorUtility.DisplayDialog("File Not Found", "Target dialogue graph file does not exist", "OK");
            return;
        }

        ClearGraph();
        CreateNodes();
        ConnectNodes();
        CreateExposedProperties();

        EditorUtility.DisplayDialog("Success", $"Graph {fileName} loaded", "OK");
    }

    /// <summary>
    /// Создает узлы из загруженных данных
    /// </summary>
    private void CreateNodes()
    {
        // Восстанавливаем EntryNode
        if (containerCache.EntryNodeData != null)
        {
            var entryNode = GetNodes().Find(x => x.EntryPoint);
            if (entryNode != null)
            {
                entryNode.GUID = containerCache.EntryNodeData.Guid;
                entryNode.SetPosition(new Rect(containerCache.EntryNodeData.Position, targetGraphView.DefaultNodeSize));
            }
        }

        // Создаем SpeechNode
        foreach (var nodeData in containerCache.SpeechNodeDatas)
        {
            BaseNode tempNode = null;
            switch (nodeData.NodeType)
            {
                case "SpeechNodeText":
                    tempNode = NodeFactory.CreateSpeechNodeText(nodeData.Position);
                    if (tempNode is SpeechNode speechNodeText)
                    {
                        speechNodeText.SetDialogueText(nodeData.DialogueText);
                    }
                    break;
                case "SpeechNodeAudio":
                    tempNode = NodeFactory.CreateSpeechNodeAudio(nodeData.Position);
                    break;
                default:
                    tempNode = NodeFactory.CreateSpeechNode(nodeData.Position);
                    if (tempNode is SpeechNode speechNode)
                    {
                        speechNode.SetDialogueText(nodeData.DialogueText);
                    }
                    break;
            }
            tempNode.GUID = nodeData.Guid;

            // Восстанавливаем аудио клип по GUID
            if (!string.IsNullOrEmpty(nodeData.AudioClipGuid))
            {
                var audioClip = AssetDatabase.LoadAssetAtPath<AudioClip>(
                    AssetDatabase.GUIDToAssetPath(nodeData.AudioClipGuid));
                if (tempNode is SpeechNode speechNode)
                {
                    speechNode.AudioClip = audioClip;
                }
            }

            // Восстанавливаем спикера по GUID
            if (!string.IsNullOrEmpty(nodeData.SpeakerGuid))
            {
                var speaker = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(nodeData.SpeakerGuid);
                if (tempNode is SpeechNode speechNode)
                {
                    speechNode.SetSpeaker(speaker);
                }
            }

            targetGraphView.AddElement(tempNode);
        }

        // Создаем SpeechNodeImage
        // Создаем SpeechNodeImage
        foreach (var nodeData in containerCache.SpeechNodeImageDatas)
        {
            var tempNode = NodeFactory.CreateSpeechNodeImage(nodeData.Position);
            tempNode.GUID = nodeData.Guid;

            if (tempNode is SpeechNodeImage speechNodeImage)
            {
                // Восстанавливаем спрайт
                if (!string.IsNullOrEmpty(nodeData.ImageSpritePath))
                {
                    string fullPath = $"Assets/Resources/{nodeData.ImageSpritePath}.sprite";
                    var sprite = AssetDatabase.LoadAssetAtPath<Sprite>(fullPath);
                    if (sprite == null)
                    {
                        fullPath = $"Assets/Resources/{nodeData.ImageSpritePath}";
                        sprite = AssetDatabase.LoadAssetAtPath<Sprite>(fullPath);
                    }
                    speechNodeImage.ImageSprite = sprite;
                }

                CharacterData speaker = null;
                if (!string.IsNullOrEmpty(nodeData.SpeakerGuid))
                {
                    speaker = AssetDatabaseHelper.LoadAssetFromGuid<CharacterData>(nodeData.SpeakerGuid);
                }
                else if (!string.IsNullOrEmpty(nodeData.SpeakerName))
                {
                    speaker = CharacterManager.Instance?.GetCharacter(nodeData.SpeakerName);
                }
                speechNodeImage.SetSpeaker(speaker);

                // Восстанавливаем спикера
                if (!string.IsNullOrEmpty(nodeData.ImageSpriteGuid))
                {
                    var sprite = AssetDatabase.LoadAssetAtPath<Sprite>(nodeData.ImageSpriteGuid);
                    speechNodeImage.ImageSprite = sprite;
                    if (speechNodeImage.imageField != null)
                        speechNodeImage.imageField.SetValueWithoutNotify(sprite);
                }
            }

            targetGraphView.AddElement(tempNode);
        }

        // Создаем OptionNode
        foreach (var nodeData in containerCache.OptionNodeDatas)
        {
            BaseNode tempNode = null;
            switch (nodeData.NodeType)
            {
                case "OptionNodeText":
                    tempNode = NodeFactory.CreateOptionNodeText(nodeData.Position);
                    if (tempNode is OptionNode optionNodeText)
                    {
                        optionNodeText.SetResponseText(nodeData.ResponseText);
                    }
                    break;
                case "OptionNodeAudio":
                    tempNode = NodeFactory.CreateOptionNodeAudio(nodeData.Position);
                    break;
                default:
                    tempNode = NodeFactory.CreateOptionNode(nodeData.Position);
                    if (tempNode is OptionNode optionNode)
                    {
                        optionNode.SetResponseText(nodeData.ResponseText);
                    }
                    break;
            }
            tempNode.GUID = nodeData.Guid;

            // Восстанавливаем аудио клип по GUID
            if (!string.IsNullOrEmpty(nodeData.AudioClipGuid))
            {
                var audioClip = AssetDatabase.LoadAssetAtPath<AudioClip>(
                    AssetDatabase.GUIDToAssetPath(nodeData.AudioClipGuid));
                if (tempNode is OptionNode optionNode)
                {
                    optionNode.AudioClip = audioClip;
                }
            }

            targetGraphView.AddElement(tempNode);
        }

        // Создаем OptionNodeImage
        foreach (var nodeData in containerCache.OptionNodeImageDatas)
        {
            var tempNode = NodeFactory.CreateOptionNodeImage(nodeData.Position);
            tempNode.GUID = nodeData.Guid;

            // Восстанавливаем изображение по GUID
            if (!string.IsNullOrEmpty(nodeData.ImageSpriteGuid))
            {
                var imageSprite = AssetDatabase.LoadAssetAtPath<Sprite>(
                    AssetDatabase.GUIDToAssetPath(nodeData.ImageSpriteGuid));
                if (tempNode is OptionNodeImage optionNodeImage)
                {
                    optionNodeImage.ImageSprite = imageSprite;
                }
            }

            targetGraphView.AddElement(tempNode);
        }

        // Создаем IntConditionNode
        foreach (var nodeData in containerCache.IntConditionNodeDatas)
        {
            var tempNode = NodeFactory.CreateIntConditionNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is IntConditionNode intConditionNode)
            {
                intConditionNode.SelectedProperty = nodeData.SelectedProperty;
                intConditionNode.Comparison = nodeData.Comparison;
                intConditionNode.CompareValue = nodeData.CompareValue;
            }
            targetGraphView.AddElement(tempNode);
            // Обновляем UI после добавления в граф
            if (tempNode is IntConditionNode icn)
                icn.UpdateUIFromData();
        }

        // Создаем StringConditionNode
        foreach (var nodeData in containerCache.StringConditionNodeDatas)
        {
            var tempNode = NodeFactory.CreateStringConditionNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is StringConditionNode stringConditionNode)
            {
                stringConditionNode.SelectedProperty = nodeData.SelectedProperty;
                stringConditionNode.Comparison = (StringConditionNode.StringComparisonType)nodeData.Comparison;
                stringConditionNode.CompareValue = nodeData.CompareValue;
            }
            targetGraphView.AddElement(tempNode);
            // Обновляем UI после добавления в граф
            if (tempNode is StringConditionNode scn)
                scn.UpdateUIFromData();
        }

        // Создаем ModifyIntNode
        foreach (var nodeData in containerCache.ModifyIntNodeDatas)
        {
            var tempNode = NodeFactory.CreateModifyIntNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is ModifyIntNode modifyIntNode)
            {
                modifyIntNode.SelectedProperty = nodeData.SelectedProperty;
                modifyIntNode.Operator = nodeData.Operator;
                modifyIntNode.Value = nodeData.Value;
                modifyIntNode.UpdateUIFromData(); // ← добавлено
            }
            targetGraphView.AddElement(tempNode);
        }

        // Создаем EndNode
        foreach (var nodeData in containerCache.EndNodeDatas)
        {
            var tempNode = NodeFactory.CreateEndNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is EndNode endNodeEditor)
            {
                endNodeEditor.SetNextDialogueFromPath(nodeData.NextDialogueName);
            }
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.EventNodeDatas)
        {
            var tempNode = new EventNode();
            tempNode.Initialize(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            tempNode.RuntimeEvent = nodeData.Event;
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.CharacterIntConditionNodeDatas)
        {
            var tempNode = NodeFactory.CreateCharacterIntConditionNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is CharacterIntConditionNode n)
            {
                n.SetInitialData(nodeData.CharacterName, nodeData.SelectedVariable, nodeData.Comparison, nodeData.CompareValue);
                n.UpdateUIFromData();
            }
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.CharacterModifyIntNodeDatas)
        {
            var tempNode = NodeFactory.CreateCharacterModifyIntNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is CharacterModifyIntNode n)
            {
                n.CharacterAsset = CharacterManager.Instance?.GetCharacter(nodeData.CharacterName);
                n.SelectedVariable = nodeData.SelectedVariable;
                n.Operator = nodeData.Operator;
                n.Value = nodeData.Value;
                n.UpdateUIFromData();
            }
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.DebugLogNodeDatas)
        {
            var node = new DebugLogNode();
            node.Initialize(nodeData.Position);
            node.GUID = nodeData.Guid;
            node.MessageText = nodeData.MessageText;
            if (node._previewLabel != null) node._previewLabel.text = nodeData.MessageText;
            targetGraphView.AddElement(node);
        }

        foreach (var nodeData in containerCache.DebugWarningNodeDatas)
        {
            var node = new DebugWarningNode();
            node.Initialize(nodeData.Position);
            node.GUID = nodeData.Guid;
            node.MessageText = nodeData.MessageText;
            if (node._previewLabel != null) node._previewLabel.text = nodeData.MessageText;
            targetGraphView.AddElement(node);
        }

        foreach (var nodeData in containerCache.DebugErrorNodeDatas)
        {
            var node = new DebugErrorNode();
            node.Initialize(nodeData.Position);
            node.GUID = nodeData.Guid;
            node.MessageText = nodeData.MessageText;
            if (node._previewLabel != null) node._previewLabel.text = nodeData.MessageText;
            targetGraphView.AddElement(node);
        }

        foreach (var nodeData in containerCache.SpeechRandNodeDatas)
        {
            var tempNode = NodeFactory.CreateSpeechNodeRandText(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (!string.IsNullOrEmpty(nodeData.SpeakerName))
            {
                var speaker = CharacterManager.Instance?.GetCharacter(nodeData.SpeakerName);
                tempNode.SetSpeaker(speaker);
            }
            tempNode.LoadVariants(nodeData.Variants);
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.RandomBranchNodeDatas)
        {
            var tempNode = NodeFactory.CreateRandomBranchNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is RandomBranchNode randomBranchNode)
            {
                randomBranchNode.LoadVariants(nodeData.Variants);
            }
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.NoteNodeDatas)
        {
            var tempNode = NodeFactory.CreateNoteNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is NoteNode noteNode)
            {
                noteNode.SetNoteText(nodeData.NoteText);
                noteNode.SetBackgroundColor(nodeData.BackgroundColor);
                noteNode.ConnectedNodeGuids = nodeData.ConnectedNodeGuids ?? new List<string>();
            }
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.TimerNodeDatas)
        {
            var tempNode = NodeFactory.CreateTimerNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            tempNode.SetDuration(nodeData.DurationSeconds);
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.TimerNodeDatas)
        {
            // Проверяем, существует ли уже узел с таким GUID
            var existingNode = GetNodes().FirstOrDefault(n => n.GUID == nodeData.Guid);
            BaseNode tempNode;
            if (existingNode != null)
            {
                // Если существует — используем его
                tempNode = existingNode;
                // Обновляем позицию
                tempNode.SetPosition(new Rect(nodeData.Position, targetGraphView.DefaultNodeSize));
            }
            else
            {
                // Если не существует — создаём новый
                tempNode = NodeFactory.CreateTimerNode(nodeData.Position);
                tempNode.GUID = nodeData.Guid;
                targetGraphView.AddElement(tempNode);
            }
            // Обновляем данные узла
            if (tempNode is TimerNode timerNode)
            {
                timerNode.SetDuration(nodeData.DurationSeconds);
            }
        }

        foreach (var nodeData in containerCache.PauseNodeDatas)
        {
            var tempNode = NodeFactory.CreatePauseNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            tempNode.SetDuration(nodeData.DurationSeconds);
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.WireNodeDatas)
        {
            var tempNode = NodeFactory.CreateWireNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            targetGraphView.AddElement(tempNode);
        }

        foreach (var nodeData in containerCache.CharacterButtonPressNodeDatas)
        {
            var tempNode = NodeFactory.CreateCharacterButtonPressNode(nodeData.Position);
            tempNode.GUID = nodeData.Guid;
            if (tempNode is CharacterButtonPressNode node)
            {
                CharacterData character = null;

                // 1. Сначала пытаемся загрузить через CharacterManager
                if (CharacterManager.Instance != null && !string.IsNullOrEmpty(nodeData.CharacterName))
                {
                    character = CharacterManager.Instance.GetCharacter(nodeData.CharacterName);
                }

                // 2. Если не получилось, ищем напрямую через AssetDatabase
                if (character == null && !string.IsNullOrEmpty(nodeData.CharacterName))
                {
                    string[] characterGuids = AssetDatabase.FindAssets($"t:CharacterData {nodeData.CharacterName}");
                    if (characterGuids.Length > 0)
                    {
                        string characterPath = AssetDatabase.GUIDToAssetPath(characterGuids[0]);
                        character = AssetDatabase.LoadAssetAtPath<CharacterData>(characterPath);
                    }
                }

                node.CharacterAsset = character;
                node.RequireButtonPress = nodeData.RequireButtonPress;

                // 3. Обновляем UI через метод UpdateUIFromData
                if (node.characterField != null)
                    node.characterField.SetValueWithoutNotify(character);
                if (node.buttonPressToggle != null)
                    node.buttonPressToggle.SetValueWithoutNotify(node.RequireButtonPress);
            }
            targetGraphView.AddElement(tempNode);
        }
    }

    /// <summary>
    /// Восстановление связей между узлами
    /// </summary>
    /// <summary>
    /// Восстановление связей между узлами
    /// </summary>
    private void ConnectNodes()
    {
        try
        {
            var nodeList = this.targetGraphView.nodes.ToList().Cast<BaseNode>().ToList();
            for (int i = 0; i < nodeList.Count; i++)
            {
                var connections = containerCache.NodeLinks.Where(x => x.BaseNodeGuid == nodeList[i].GUID).ToList();
                foreach (var connection in connections)
                {
                    var targetNodeGuid = connection.TargetNodeGuid;
                    var targetNode = nodeList.FirstOrDefault(x => x.GUID == targetNodeGuid);
                    if (targetNode == null)
                    {
                        Debug.LogWarning($"Target node not found for GUID: {targetNodeGuid}");
                        continue;
                    }

                    Port outputPort = null;

                    // Определяем outputPort в зависимости от типа узла
                    if (nodeList[i] is SpeechNode speechNode)
                    {
                        foreach (var port in speechNode.outputContainer.Children())
                        {
                            if (port is Port portElement && portElement.portName == connection.PortName)
                            {
                                outputPort = portElement;
                                break;
                            }
                        }
                        if (outputPort == null)
                        {
                            outputPort = speechNode.InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
                            outputPort.portName = connection.PortName;
                            speechNode.outputContainer.Add(outputPort);
                            speechNode.RefreshPorts();
                            speechNode.RefreshExpandedState();
                        }
                    }
                    else if (nodeList[i] is OptionNode optionNode)
                    {
                        outputPort = optionNode.outputContainer[0].Q<Port>();
                    }
                    else if (nodeList[i] is EntryNode entryNode)
                    {
                        outputPort = entryNode.outputContainer[0].Q<Port>();
                    }
                    else if (nodeList[i] is IntConditionNode || nodeList[i] is StringConditionNode)
                    {
                        foreach (var port in nodeList[i].outputContainer.Children())
                        {
                            if (port is Port portElement && portElement.portName == connection.PortName)
                            {
                                outputPort = portElement;
                                break;
                            }
                        }
                        if (outputPort == null)
                        {
                            Debug.LogWarning($"Port '{connection.PortName}' not found on condition node {nodeList[i].GUID}");
                        }
                    }
                    else if (nodeList[i] is TimerNode timerNode)
                    {
                        foreach (var port in timerNode.outputContainer.Children())
                        {
                            if (port is Port portElement && portElement.portName == connection.PortName)
                            {
                                outputPort = portElement;
                                break;
                            }
                        }
                        if (outputPort == null)
                        {
                            // Восстанавливаем порт, если его нет (например, после загрузки)
                            outputPort = timerNode.InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
                            outputPort.portName = connection.PortName;
                            timerNode.outputContainer.Add(outputPort);
                            timerNode.RefreshPorts();
                            timerNode.RefreshExpandedState();
                        }
                    }
                    else if (nodeList[i] is PauseNode pauseNode)
                    {
                        foreach (var port in pauseNode.outputContainer.Children())
                        {
                            if (port is Port portElement && portElement.portName == connection.PortName)
                            {
                                outputPort = portElement;
                                break;
                            }
                        }
                        if (outputPort == null)
                        {
                            // Восстанавливаем порт, если его нет (например, после загрузки)
                            outputPort = pauseNode.InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
                            outputPort.portName = connection.PortName;
                            pauseNode.outputContainer.Add(outputPort);
                            pauseNode.RefreshPorts();
                            pauseNode.RefreshExpandedState();
                        }
                    }
                    else if (nodeList[i] is ModifyIntNode modifyNode)
                    {
                        outputPort = modifyNode.outputContainer[0].Q<Port>();
                    }
                    else if (nodeList[i] is EndNode endNode)
                    {
                        outputPort = endNode.outputContainer[0].Q<Port>();
                    }
                    else if (nodeList[i] is EventNode eventNode)
                    {
                        outputPort = eventNode.outputContainer[0].Q<Port>();
                    }
                    else if (nodeList[i] is WireNode wireNode)
                    {
                        foreach (var port in wireNode.outputContainer.Children())
                        {
                            if (port is Port portElement && portElement.portName == connection.PortName)
                            {
                                outputPort = portElement;
                                break;
                            }
                        }
                        if (outputPort == null)
                        {
                            // Восстанавливаем порт, если его нет
                            outputPort = wireNode.InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
                            outputPort.portName = connection.PortName; // Должно быть "Output"
                            wireNode.outputContainer.Add(outputPort);
                            wireNode.RefreshPorts();
                            wireNode.RefreshExpandedState();
                        }
                    }
                    else if (nodeList[i] is CharacterButtonPressNode charButtonPressNode)
                    {
                        foreach (var port in charButtonPressNode.outputContainer.Children())
                        {
                            if (port is Port portElement && portElement.portName == connection.PortName)
                            {
                                outputPort = portElement;
                                break;
                            }
                        }
                        if (outputPort == null)
                        {
                            // Восстанавливаем порт, если его нет
                            outputPort = charButtonPressNode.InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
                            outputPort.portName = connection.PortName; // Должно быть "Output"
                            charButtonPressNode.outputContainer.Add(outputPort);
                            charButtonPressNode.RefreshPorts();
                            charButtonPressNode.RefreshExpandedState();
                        }
                    }

                    // Получаем inputPort у целевого узла
                    Port inputPort = null;
                    if (targetNode.inputContainer.childCount > 0)
                    {
                        inputPort = targetNode.inputContainer[0] as Port;
                    }

                    // Соединяем порты
                    if (outputPort != null && inputPort != null)
                    {
                        LinkNodes(outputPort, inputPort);
                    }
                    else
                    {
                        Debug.LogWarning($"Failed to connect {nodeList[i].GUID} -> {targetNodeGuid}. outputPort: {outputPort != null}, inputPort: {inputPort != null}");
                    }
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error connecting nodes: {e.Message}\n{e.StackTrace}");
        }
    }

    /// <summary>
    /// Связывание двух портов
    /// </summary>
    private void LinkNodes(Port output, Port input)
    {
        var tempEdge = new Edge { output = output, input = input };
        tempEdge.input.Connect(tempEdge);
        tempEdge.output.Connect(tempEdge);
        targetGraphView.Add(tempEdge);
    }

    /// <summary>
    /// Восстановление свойств черной доски
    /// </summary>
    private void CreateExposedProperties()
    {
        targetGraphView.ClearBlackBoardAndExposedProperties();
        // Загружаем Int свойства
        foreach (var prop in containerCache.IntExposedProperties)
        {
            var newProp = new IntExposedProperty
            {
                PropertyName = prop.PropertyName,
                IntValue = prop.IntValue,
                MinValue = prop.MinValue,
                MaxValue = prop.MaxValue
            };
            // Заменяем на существующий метод для добавления Int свойства
            targetGraphView.IntExposedProperties.Add(newProp);
            targetGraphView.AddIntPropertyToBlackBoard(newProp);
        }
        // Загружаем String свойства
        foreach (var prop in containerCache.StringExposedProperties)
        {
            var newProp = new StringExposedProperty
            {
                PropertyName = prop.PropertyName,
                StringValue = prop.StringValue
            };
            // Заменяем на существующий метод для добавления String свойства
            targetGraphView.StringExposedProperties.Add(newProp);
            targetGraphView.AddStringPropertyToBlackBoard(newProp);
        }
        // Принудительно обновляем все выпадающие списки после загрузки свойств
        var propertyNodes = targetGraphView.nodes.ToList().OfType<IPropertyNode>();
        foreach (var node in propertyNodes)
            node.RefreshPropertyDropdown();
    }

    /// <summary>
    /// Очистка текущего графа перед загрузкой
    /// </summary>
    private void ClearGraph()
    {
        // Удаляем все узлы кроме стартового
        foreach (var node in GetNodes().Where(node => !node.EntryPoint).ToList())
        {
            // Удаляем связанные связи
            var edgesToRemove = GetEdges().Where(x => x.input.node == node || x.output.node == node).ToList();
            foreach (var edge in edgesToRemove)
            {
                targetGraphView.RemoveElement(edge);
            }

            targetGraphView.RemoveElement(node);
        }

    }
    #endregion

    /// <summary>
    /// Загружает граф из уже загруженного DialogueContainer
    /// </summary>
    public void LoadGraphFromContainer(DialogueContainer container)
    {
        if (container == null)
        {
            Debug.LogError("Cannot load null container");
            return;
        }

        targetGraphView.containerCache = container;

        // Очищаем стеки отмены перед загрузкой
        targetGraphView.ClearUndoRedoStacks();

        containerCache = container;
        ClearGraph();
        CreateNodes();
        ConnectNodes();
        CreateExposedProperties();
    }

    private DialogueSettingsData LoadDialogueSettings()
    {
        string[] guids = AssetDatabase.FindAssets("t:DialogueSettingsData");
        if (guids.Length > 0)
        {
            string path = AssetDatabase.GUIDToAssetPath(guids[0]);
            return AssetDatabase.LoadAssetAtPath<DialogueSettingsData>(path);
        }
        return null;
    }

    /// <summary>
    /// Сохраняет граф в существующий DialogueContainer
    /// </summary>
    public void SaveGraphToExistingContainer(DialogueContainer existingContainer)
    {
        if (existingContainer == null)
        {
            Debug.LogError("Cannot save to null container");
            return;
        }

        // === ОЧИЩАЕМ ВСЕ СПИСКИ, ВКЛЮЧАЯ TimerNodeDatas ===
        existingContainer.NodeLinks.Clear();
        existingContainer.SpeechNodeDatas.Clear();
        existingContainer.OptionNodeDatas.Clear();
        existingContainer.IntConditionNodeDatas.Clear();
        existingContainer.StringConditionNodeDatas.Clear();
        existingContainer.ModifyIntNodeDatas.Clear();
        existingContainer.EndNodeDatas.Clear();
        existingContainer.SpeechNodeImageDatas.Clear();
        existingContainer.OptionNodeImageDatas.Clear();
        existingContainer.TimerNodeDatas.Clear();
        existingContainer.PauseNodeDatas.Clear();
        existingContainer.WireNodeDatas.Clear();
        existingContainer.IntExposedProperties.Clear();
        existingContainer.StringExposedProperties.Clear();
        existingContainer.SpeechRandNodeDatas.Clear();
        existingContainer.NoteNodeDatas.Clear();
        existingContainer.CharacterIntConditionNodeDatas.Clear();
        existingContainer.RandomBranchNodeDatas.Clear();
        existingContainer.CharacterModifyIntNodeDatas.Clear();
        existingContainer.EventNodeDatas.Clear();
        existingContainer.DebugLogNodeDatas.Clear();
        existingContainer.DebugWarningNodeDatas.Clear();
        existingContainer.DebugErrorNodeDatas.Clear();
        existingContainer.CharacterButtonPressNodeDatas.Clear();

        targetGraphView.ClearUndoRedoStacks();

        // === Сохраняем новые данные ===
        SaveNodes(existingContainer);
        SaveExposedProperties(existingContainer);

        EditorUtility.SetDirty(existingContainer);
        AssetDatabase.SaveAssets();
        EditorUtility.SetDirty(existingContainer);
        AssetDatabase.SaveAssets();
    }
}

//==== File 71 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Editor\DialogueGraph\Utilities\NodeFactory.cs ====
// Assets/Scripts/Editor/DialogueGraph/Utilities/NodeFactory.cs
using UnityEngine;
using System;
using System.Collections.Generic;

public static class NodeFactory
{
    public static BaseNode CreateNode(Type nodeType, Vector2 position)
    {
        if (nodeType == typeof(EntryNode))
            return CreateEntryNode(position);
        else if (nodeType == typeof(SpeechNode))
            return CreateSpeechNode(position);
        else if (nodeType == typeof(SpeechNodeText))
            return CreateSpeechNodeText(position);
        else if (nodeType == typeof(SpeechNodeAudio))
            return CreateSpeechNodeAudio(position);
        else if (nodeType == typeof(SpeechNodeImage))
            return CreateSpeechNodeImage(position);
        else if (nodeType == typeof(SpeechNodeRandText))
            return CreateSpeechNodeRandText(position);
        else if (nodeType == typeof(OptionNode))
            return CreateOptionNode(position);
        else if (nodeType == typeof(OptionNodeText))
            return CreateOptionNodeText(position);
        else if (nodeType == typeof(OptionNodeAudio))
            return CreateOptionNodeAudio(position);
        else if (nodeType == typeof(OptionNodeImage))
            return CreateOptionNodeImage(position);
        else if (nodeType == typeof(IntConditionNode))
            return CreateIntConditionNode(position);
        else if (nodeType == typeof(StringConditionNode))
            return CreateStringConditionNode(position);
        else if (nodeType == typeof(ModifyIntNode))
            return CreateModifyIntNode(position);
        else if (nodeType == typeof(EndNode))
            return CreateEndNode(position);
        else if (nodeType == typeof(EventNode))
            return CreateEventNode(position);
        else if (nodeType == typeof(CharacterIntConditionNode))
            return CreateCharacterIntConditionNode(position);
        else if (nodeType == typeof(CharacterModifyIntNode))
            return CreateCharacterModifyIntNode(position);
        else if (nodeType == typeof(DebugLogNode))
            return CreateDebugLogNode(position);
        else if (nodeType == typeof(DebugWarningNode))
            return CreateDebugWarningNode(position);
        else if (nodeType == typeof(DebugErrorNode))
            return CreateDebugErrorNode(position);
        else if (nodeType == typeof(RandomBranchNode))
            return CreateRandomBranchNode(position);
        if (nodeType == typeof(NoteNode))
            return CreateNoteNode(position);
        else if (nodeType == typeof(TimerNode))
            return CreateTimerNode(position);
        else if (nodeType == typeof(PauseNode))
            return CreatePauseNode(position);
        else if (nodeType == typeof(WireNode))
            return CreateWireNode(position);
        else if (nodeType == typeof(CharacterButtonPressNode))
            return CreateCharacterButtonPressNode(position);
        else
        {
            Debug.LogError($"NodeFactory: Unknown node type {nodeType}");
            return null;
        }
    }
    public static CharacterButtonPressNode CreateCharacterButtonPressNode(Vector2 position)
    {
        var node = new CharacterButtonPressNode();
        node.Initialize(position);
        return node;
    }

    public static WireNode CreateWireNode(Vector2 position)
    {
        var node = new WireNode();
        node.Initialize(position);
        return node;
    }

    public static PauseNode CreatePauseNode(Vector2 position)
    {
        var node = new PauseNode();
        node.Initialize(position);
        return node;
    }

    public static TimerNode CreateTimerNode(Vector2 position)
    {
        var node = new TimerNode();
        node.Initialize(position);
        return node;
    }

    public static BaseNode CreateNoteNode(Vector2 position)
    {
        var node = new NoteNode();
        node.Initialize(position);
        node.SetPosition(new Rect(position, new Vector2(300, 150)));
        return node;
    }


    public static EntryNode CreateEntryNode(Vector2 position)
    {
        var node = new EntryNode();
        node.Initialize(position);
        return node;
    }

    public static SpeechNode CreateSpeechNode(Vector2 position)
    {
        var node = new SpeechNode();
        node.Initialize(position);
        return node;
    }

    public static SpeechNodeText CreateSpeechNodeText(Vector2 position)
    {
        var node = new SpeechNodeText();
        node.Initialize(position);
        return node;
    }

    public static SpeechNodeAudio CreateSpeechNodeAudio(Vector2 position)
    {
        var node = new SpeechNodeAudio();
        node.Initialize(position);
        return node;
    }

    public static SpeechNodeImage CreateSpeechNodeImage(Vector2 position)
    {
        var node = new SpeechNodeImage();
        node.Initialize(position);
        return node;
    }

    public static SpeechNodeRandText CreateSpeechNodeRandText(Vector2 position)
    {
        var node = new SpeechNodeRandText();
        node.Initialize(position);
        return node;
    }

    public static OptionNode CreateOptionNode(Vector2 position)
    {
        var node = new OptionNode();
        node.Initialize(position);
        return node;
    }

    public static OptionNodeText CreateOptionNodeText(Vector2 position)
    {
        var node = new OptionNodeText();
        node.Initialize(position);
        return node;
    }

    public static OptionNodeAudio CreateOptionNodeAudio(Vector2 position)
    {
        var node = new OptionNodeAudio();
        node.Initialize(position);
        return node;
    }

    public static OptionNodeImage CreateOptionNodeImage(Vector2 position)
    {
        var node = new OptionNodeImage();
        node.Initialize(position);
        return node;
    }

    public static IntConditionNode CreateIntConditionNode(Vector2 position)
    {
        var node = new IntConditionNode();
        node.Initialize(position);
        return node;
    }

    public static StringConditionNode CreateStringConditionNode(Vector2 position)
    {
        var node = new StringConditionNode();
        node.Initialize(position);
        return node;
    }

    public static ModifyIntNode CreateModifyIntNode(Vector2 position)
    {
        var node = new ModifyIntNode();
        node.Initialize(position);
        return node;
    }

    public static EndNode CreateEndNode(Vector2 position)
    {
        var node = new EndNode();
        node.Initialize(position);
        return node;
    }

    public static EventNode CreateEventNode(Vector2 position)
    {
        var node = new EventNode();
        node.Initialize(position);
        return node;
    }

    public static CharacterIntConditionNode CreateCharacterIntConditionNode(Vector2 position)
    {
        var node = new CharacterIntConditionNode();
        node.Initialize(position);
        return node;
    }

    public static CharacterModifyIntNode CreateCharacterModifyIntNode(Vector2 position)
    {
        var node = new CharacterModifyIntNode();
        node.Initialize(position);
        return node;
    }

    public static DebugLogNode CreateDebugLogNode(Vector2 position)
    {
        var node = new DebugLogNode();
        node.Initialize(position);
        return node;
    }

    public static DebugWarningNode CreateDebugWarningNode(Vector2 position)
    {
        var node = new DebugWarningNode();
        node.Initialize(position);
        return node;
    }

    public static DebugErrorNode CreateDebugErrorNode(Vector2 position)
    {
        var node = new DebugErrorNode();
        node.Initialize(position);
        return node;
    }

    public static RandomBranchNode CreateRandomBranchNode(Vector2 position)
    {
        var node = new RandomBranchNode();
        node.Initialize(position);
        return node;
    }
}

//==== File 72 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Core\BaseConditionNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine;

public abstract class BaseConditionNode : BaseNode
{
    public override void Initialize(Vector2 position)
    {
        base.Initialize(position);

        // ������� ������� ����
        var inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(float));
        inputPort.portName = "Input";
        inputContainer.Add(inputPort);

        // ������� �������� ����� True � False
        var truePort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        truePort.portName = "True";
        outputContainer.Add(truePort);

        var falsePort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Single, typeof(float));
        falsePort.portName = "False";
        outputContainer.Add(falsePort);
    }
}


//==== File 73 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Core\BaseNode.cs ====
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using System;

/// <summary>
/// ������� ����� ��� ���� ����� ����������� �����
/// �������� ����� ������ � �������� ��� ���� �����
/// </summary>
public abstract class BaseNode : Node
{
    public string GUID { get; set; } // ���������� ������������� ����
    public bool EntryPoint { get; set; } = false; // �������� �� ���� ������ �����

    /// <summary>
    /// ������������� ���� � ��������� ��������
    /// </summary>
    public virtual void Initialize(Vector2 position)
    {
        GUID = Guid.NewGuid().ToString();
        SetPosition(new Rect(position, new Vector2(200, 150)));
    }

    public virtual string SerializeNodeData()
    {
        // ������� ���������� �� ���������
        return "{}";
    }

    public virtual void DeserializeNodeData(string jsonData)
    {
        // ������ ���������� �� ���������
    }
}


//==== File 74 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Core\IPropertyNode.cs ====
public interface IPropertyNode
{
    void RefreshPropertyDropdown();
}

//==== File 75 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\DialogueContainer.cs ====
using System.Collections.Generic;
using UnityEngine;
using System;

/// <summary>
/// ��������� ��� �������� ������ ����������� ����
/// </summary>
[Serializable]
public class DialogueContainer : ScriptableObject
{
    [Header("Entry Node")]
    public EntryNodeData EntryNodeData;

    [Header("Node Connections")]
    public List<NodeLinkData> NodeLinks = new List<NodeLinkData>();

    [Header("Speech Nodes")]
    public List<SpeechNodeData> SpeechNodeDatas = new List<SpeechNodeData>();

    [Header("Option Nodes")]
    public List<OptionNodeData> OptionNodeDatas = new List<OptionNodeData>();

    [Header("Exposed Properties")]
    public List<ExposedProperty> ExposedProperties = new List<ExposedProperty>();

    [Header("Exposed Properties")]
    public List<IntExposedProperty> IntExposedProperties = new List<IntExposedProperty>();
    public List<StringExposedProperty> StringExposedProperties = new List<StringExposedProperty>();

    [Header("Condition Nodes")]
    public List<IntConditionNodeData> IntConditionNodeDatas = new List<IntConditionNodeData>();
    public List<StringConditionNodeData> StringConditionNodeDatas = new List<StringConditionNodeData>();

    [Header("Modify Int Nodes")]
    public List<ModifyIntNodeData> ModifyIntNodeDatas = new List<ModifyIntNodeData>();

    [Header("End Nodes")]
    public List<EndNodeData> EndNodeDatas = new List<EndNodeData>();

    [Header("Speech Image Nodes")]
    public List<SpeechNodeImageData> SpeechNodeImageDatas = new List<SpeechNodeImageData>();

    [Header("Option Image Nodes")]
    public List<OptionNodeImageData> OptionNodeImageDatas = new List<OptionNodeImageData>();

    [Header("Base Character")]
    public string BaseCharacterGuid;

    [Header("Event Nodes")]
    public List<EventNodeData> EventNodeDatas = new List<EventNodeData>();

    [Header("Character Condition Nodes")]
    public List<CharacterIntConditionNodeData> CharacterIntConditionNodeDatas = new List<CharacterIntConditionNodeData>();

    [Header("Character Modify Int Nodes")]
    public List<CharacterModifyIntNodeData> CharacterModifyIntNodeDatas = new List<CharacterModifyIntNodeData>();

    [Header("Debug Nodes")]
    public List<DebugLogNodeData> DebugLogNodeDatas = new List<DebugLogNodeData>();
    public List<DebugWarningNodeData> DebugWarningNodeDatas = new List<DebugWarningNodeData>();
    public List<DebugErrorNodeData> DebugErrorNodeDatas = new List<DebugErrorNodeData>();

    [Header("Speech Rand Nodes")]
    public List<SpeechRandNodeData> SpeechRandNodeDatas = new List<SpeechRandNodeData>();

    public List<RandomBranchNodeData> RandomBranchNodeDatas = new List<RandomBranchNodeData>();

    [SerializeField] private List<NoteNodeData> noteNodeDatas = new List<NoteNodeData>();
    public List<NoteNodeData> NoteNodeDatas => noteNodeDatas;

    [Header("Timer Nodes")]
    public List<TimerNodeData> TimerNodeDatas = new List<TimerNodeData>();

    [Header("Pause Nodes")]
    public List<PauseNodeData> PauseNodeDatas = new List<PauseNodeData>();

    [Header("Wire Nodes")]
    public List<WireNodeData> WireNodeDatas = new List<WireNodeData>();

    [Header("Character Button Press Nodes")]
    public List<CharacterButtonPressNodeData> CharacterButtonPressNodeDatas = new List<CharacterButtonPressNodeData>();
}


//==== File 76 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\ExposedProperty.cs ====
using UnityEngine;

/// <summary>
/// �������� ��� ������ ����� - ����������, ������� ����� ������������ � ��������
/// </summary>
[System.Serializable]
public class ExposedProperty
{
    public string PropertyName = "New Property"; // ��� ��������
    public string PropertyValue = "New Value";   // �������� ��������
}

//==== File 77 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\IntExposedProperty.cs ====
[System.Serializable]
public class IntExposedProperty
{
    public string PropertyName = "New Int Property";
    public int IntValue = 0;
    public int MinValue = 0;
    public int MaxValue = 100;
}


//==== File 78 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\NodeLinkData.cs ====
[System.Serializable]
public class NodeLinkData
{
    public string BaseNodeGuid;
    public string PortName;
    public string TargetNodeGuid;
}


//==== File 79 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\StringExposedProperty.cs ====
[System.Serializable]
public class StringExposedProperty
{
    public string PropertyName = "New String Property";
    public string StringValue = "New Value";
}


//==== File 80 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Enums\ComparisonEnums.cs ====
namespace DialogueSystem
{
    public enum ComparisonType
    {
        Equal,
        NotEqual,
        Greater,
        Less,
        GreaterOrEqual,
        LessOrEqual
    }

    public enum StringComparisonType
    {
        Equal,
        NotEqual,
        IsNullOrEmpty
    }

    public enum OperatorType
    {
        Set,
        Add,
        Subtract,
        Multiply,
        Divide,
        Increment,
        Decrement
    }
}


//==== File 81 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\CharacterButtonPressNodeData.cs ====
// File: Assets/Scripts/Runtime/DialogueSystem/Data/Node Data/CharacterButtonPressNodeData.cs
using System;
using UnityEngine;

[Serializable]
public class CharacterButtonPressNodeData : BaseNodeData
{
    public string CharacterName;
    public bool RequireButtonPress;
}

//==== File 82 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\CharacterIntConditionNodeData.cs ====
using DialogueSystem;
using UnityEngine;
using System;

[Serializable]
public class CharacterIntConditionNodeData : BaseNodeData
{
    public string CharacterName;
    public string SelectedVariable;
    public ComparisonType Comparison;
    public int CompareValue;
}

//==== File 83 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\CharacterModifyIntNodeData.cs ====
using DialogueSystem;
using UnityEngine;
using System;

[Serializable]
public class CharacterModifyIntNodeData : BaseNodeData
{
    public string CharacterName;
    public string SelectedVariable;
    public OperatorType Operator;
    public int Value;
}

//==== File 84 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\DebugErrorNodeData.cs ====
using System;

[Serializable]
public class DebugErrorNodeData : BaseNodeData
{
    public string MessageText;
}

//==== File 85 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\DebugLogNodeData.cs ====
using System;

[Serializable]
public class DebugLogNodeData : BaseNodeData
{
    public string MessageText;
}


//==== File 86 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\DebugWarningNodeData.cs ====
using System;

[Serializable]
public class DebugWarningNodeData : BaseNodeData
{
    public string MessageText;
}


//==== File 87 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\EndNodeData.cs ====
using UnityEngine;
using System;

[Serializable]
public class EndNodeData : BaseNodeData
{
    public string NextDialogueName;
}

//==== File 88 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\EntryNodeData.cs ====
using UnityEngine;
using System;

/// <summary>
/// ������ ���������� ���� ��� ������������
/// </summary>
[Serializable]
public class EntryNodeData : BaseNodeData
{

}


//==== File 89 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\EventNodeData.cs ====
using UnityEngine;
using UnityEngine.Events;
using System;

[Serializable]
public class EventNodeData : BaseNodeData
{
    public UnityEvent Event = new UnityEvent();
}

//==== File 90 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\IntConditionNodeData.cs ====
using DialogueSystem;
using UnityEngine;
using System;

[Serializable]
public class IntConditionNodeData
{
    public string Guid;
    public Vector2 Position;
    public string SelectedProperty;
    public ComparisonType Comparison;
    public int CompareValue;
}


//==== File 91 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\ModifyIntNodeData.cs ====
using DialogueSystem;
using UnityEngine;
using System;

[Serializable]
public class ModifyIntNodeData : BaseNodeData
{
    public string SelectedProperty;
    public OperatorType Operator;
    public int Value;
}


//==== File 92 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\OptionNodeData.cs ====
using UnityEngine;
using System;

/// <summary>
/// ������ ���� �������� ������ ������ ��� ������������
/// </summary>
[Serializable]
public class OptionNodeData : BaseNodeData
{
    [TextArea, Tooltip("Response text content")]
    public string ResponseText;

    [Tooltip("GUID of the audio clip asset")]
    public string AudioClipGuid;

    public string NodeType;
}


//==== File 93 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\OptionNodeImageData.cs ====
using UnityEngine;
using System;

[Serializable]
public class OptionNodeImageData : BaseNodeData
{
    public string ImageSpriteGuid;

    public string NodeType;
}

//==== File 94 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\PauseNodeData.cs ====
using System;

[Serializable]
public class PauseNodeData : BaseNodeData
{
    public float DurationSeconds = 1.0f;
}


//==== File 95 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\SpeechNodeData.cs ====
using UnityEngine;
using System;

/// <summary>
/// ������ ���� ���� NPC ��� ������������
/// </summary>
[Serializable]
public class SpeechNodeData : BaseNodeData
{
    [TextArea, Tooltip("Dialogue text content")]
    public string DialogueText;

    [Tooltip("GUID of the audio clip asset")]
    public string AudioClipGuid;

    [Tooltip("GUID of the speaker character asset")]
    public string SpeakerGuid;
    public string SpeakerName;

    public string NodeType;
}


//==== File 96 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\SpeechNodeImageData.cs ====
using UnityEngine;
using System;

[Serializable]
public class SpeechNodeImageData : BaseNodeData
{
    public string ImageSpriteGuid = "";
    public string ImageSpritePath = "";

    public string NodeType;
    public string SpeakerGuid;
    public string SpeakerName;
}

//==== File 97 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\SpeechRandNodeData.cs ====
using System;
using System.Collections.Generic;

[Serializable]
public class SpeechRandNodeData : BaseNodeData
{
    public string SpeakerName;
    public List<SpeechVariant> Variants = new List<SpeechVariant>();
}

[Serializable]
public class SpeechVariant
{
    public string Text = "";
    public float WeightPercent = 0f; // 0�100, ����� ���� = 100
}


//==== File 98 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\StringConditionNodeData.cs ====
using DialogueSystem;
using UnityEngine;
using System;

[Serializable]
public class StringConditionNodeData : BaseNodeData
{
    public string SelectedProperty;
    public StringComparisonType Comparison;
    public string CompareValue;
}


//==== File 99 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\TimerNodeData.cs ====
using System;

[Serializable]
public class TimerNodeData : BaseNodeData
{
    public float DurationSeconds = 5.0f;
}


//==== File 100 of 100: D:/Work/REDDialogSystemProject/Assets\Scripts\Runtime\DialogueSystem\Data\Node Data\WireNodeData.cs ====
using System;

[Serializable]
public class WireNodeData : BaseNodeData
{
    // ������ �������������� ����: Guid, Position
}


// ============ Statistics =============
// Total Files: 100
// Total Size: 432,24 KB
// Total Lines: 12063
// Classes: 129
// Methods: 733
// Comments: 965
// =====================================
